<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Codroc Blog</title>
  
  
  <link href="https://codroc.github.io/atom.xml" rel="self"/>
  
  <link href="https://codroc.github.io/"/>
  <updated>2022-07-05T11:57:21.573Z</updated>
  <id>https://codroc.github.io/</id>
  
  <author>
    <name>Codroc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Config System</title>
    <link href="https://codroc.github.io/2022/07/05/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/"/>
    <id>https://codroc.github.io/2022/07/05/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-07-05T11:57:21.573Z</published>
    <updated>2022-07-05T11:57:21.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><p><strong>配置系统有什么用？</strong></p><p>我的理解是方便程序的运行和发布。把配置变量都抽离出来放在配置文件中，如果要修改配置变量，就直接在配置文件里修改，然后重新运行程序就可以了。如果没有配置系统的情况下要修改配置变量，一般都是直接改程序源代码，然后重新编译连接，毫无疑问这将会是费时费力的（找对应版本的各种库，对应版本的编译器等等，还要等待漫长的编译连接过程。。。），对于那些非开源软件，想改源代码就更不可能了。。。。</p><p>配置系统就能够很好地解决这些问题。</p><h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><p>选择一种用于配置文件的语言，我选的是 YAML。它是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。</p><p>YAML 实质上是一种通用的数据串行化格式。它的基本语法规则如下：</p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用 Tab 键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li></ul><p><code>#</code>  表示注释，从这个字符一直到行尾，都会被解析器忽略。</p><p>YAML 支持的数据结构有三种：</p><ul><li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li><li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li><li>纯量（scalars）：单个的、不可再分的值</li></ul><p>和 JSON 对比，它数据类型更单调简单（JSON 有 6 种类型）</p><p>YAML 下载与安装：</p><p><code>yaml-cpp: github repo</code></p><p><code>mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make install</code></p><h3 id="基于-YAML-实现-配置系统"><a href="#基于-YAML-实现-配置系统" class="headerlink" title="基于 YAML 实现 配置系统"></a>基于 YAML 实现 配置系统</h3><p>配置系统的原则：</p><ul><li><strong>约定优于配置：</strong>约定即源代码中写死的值，而配置是指在配置文件 (.yaml) 中指定的值。</li><li><strong>不能无中生有：</strong>在源文件中未定义的配置变量，即使在配置文件 (.yaml) 中定义了也不会生效。</li></ul><p>总体的结构是这样的：</p><p>​    由于配置变量一般都由：变量名，变量值，变量描述构成。因此可以抽一个基类出来存放这些共通的属性，必然的，有时候会需要把配置变量输出到控制台给用户看，或根据字符串来重置变量值，因此还需要一个 fromString 和 toString 方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVarBase</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ConfigVarBase&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span>; <span class="comment">// 根据 str 来设置 配置变量值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>;  <span class="comment">// 把配置变量值转成字符串，便于输出</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _description;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    其中变量名和变量描述由于类型固定，可以放在基类中，而变量值则不固定了，它可以是任意类型，因此就可以根据基类派生出一个模板子类来表示具体的配置变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> :</span> <span class="keyword">public</span> ConfigVarBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    现在有配置变量了，缺一个管理这些配置变量的类，我使用 map 来进行管理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    static std::map&lt;std::string, ConfigVarBase::ptr&gt;&amp; GetConfigVars() &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, ConfigVarBase::ptr&gt; g_configVars;</span><br><span class="line">        <span class="keyword">return</span> g_configVars;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里为什么要用 static 函数来返回一个 local static 变量 map 呢？这是因为，配置系统可以被其他编译单元内的数据结构使用，如果其他编译单元想要使用 <strong>g_configVars</strong> 时，它还没有初始化完毕就会产生 runtime error，这种情况就是所谓的 non-local static 初始化顺序不一致。可以使用 local static 的方式来解决，也就是让别的编译单元通过调用函数的方式获取 <strong>g_configVars</strong>，这样使用它之前肯定被初始化好了。</p><p>这样一来 <strong>约定的变量</strong> 就实现了！</p><p>接下来就是怎么实现，从配置文件 (.yaml) 中读取配置变量。yaml-cpp 库提供了 LoadFile 函数，能从 .yaml 文件中读取 YAML::Node。</p><p>由于 .yaml 中的格式和我源代码中变量名字的格式是不一样的：</p><p>yaml 中是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A:</span></span><br><span class="line"><span class="attr">B:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">C:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>源文件中的变量名则为：A.B = 10，A.C = 20</p><p>因此这里需要一个从 YAML 名称格式到 源代码中的变量名称格式的转换。可以借助 yaml-cpp 中的 <code>IsNull, IsScalar, IsSequence, Ismap</code> 对 node 进行递归解析，然后将变量名进行转换。只有对象类型才需要递归解析下去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listAllNodes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> YAML::Node&amp; node,  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, YAML::Node&gt;&gt;&amp; allNodes)</span> </span>&#123;</span><br><span class="line">    allNodes.push_back(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(name, node));</span><br><span class="line">    <span class="keyword">if</span> (node.IsNull()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsScalar()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsSequence()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsMap()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = node.begin(); it != node.end(); ++it) &#123;</span><br><span class="line">            listAllNodes(name.empty() ? it-&gt;first.as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;() :</span><br><span class="line">                    name + <span class="string">&quot;.&quot;</span> + it-&gt;first.Scalar(), it-&gt;second, allNodes); <span class="comment">// 这里是名字转换的关键所在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config::loadFromYaml</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    YAML::Node node = YAML::LoadFile(filename);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, YAML::Node&gt;&gt; allNodes;</span><br><span class="line">    listAllNodes(<span class="string">&quot;&quot;</span>, node, allNodes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : allNodes) &#123; <span class="comment">// 对所有的 name、node 进行遍历</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name = i.first;</span><br><span class="line">        <span class="keyword">if</span> (name.empty())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ConfigVarBase::ptr p = Config::find(name);</span><br><span class="line">        <span class="keyword">if</span> (p) &#123; <span class="comment">// 这里保证了不会无中生有的原则</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">            ss &lt;&lt; i.second;</span><br><span class="line">            p-&gt;fromString(ss.str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道，YAML 文件中仅仅是一些文本，而我们需要根据 YAML 文本得到内存中的对象；或者根据内存中的对象得到 YAML 文本；这本质就是序列化和反序列化。和 JSON 的十分相似。<br>我做出了这样的总结：</p><ul><li>YAML::Node –&gt; std::string –&gt; Type<ul><li>通过 std::stringstream 来实现 YAML::Node –&gt; std::string. 这一部分 YAML 库已经做好了</li><li>通过 自己实现的 <code>LexicalCast\&lt;F, T\&gt;</code> 来做 std::string –&gt; Type 的转换</li></ul></li><li>Type –&gt; std::string –&gt; YAML::Node<ul><li>通过 YAML::Load 来实现 std::string –&gt; YAML::Node. 这一部分 YAML 库已经做好了</li><li>通过 自己实现的 <code>LexicalCast\&lt;F, T\&gt;</code> 来做 Type –&gt; std::string 的转换</li></ul></li></ul><h3 id="fromStr-和-toStr-的实现"><a href="#fromStr-和-toStr-的实现" class="headerlink" title="fromStr 和 toStr 的实现"></a>fromStr 和 toStr 的实现</h3><p>对于普通的内置类型可以用 boost::lexical_cast 来实现，而对于复杂的数据类型，例如：vector,list,set,map,unordered_set,unordered_map, 自定义类型 等，就要自己去实现了。</p><p><strong>STL 类型的支持：</strong></p><p>可以实现一个 LexicalCast 模板类，然后根据具体的 STL 容器对 LexicalCast 进行偏特化就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于普通内置类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> F&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boost::lexical_cast&lt;T&gt;(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cast from std::string to std::vector&lt;T&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        ...<span class="comment">// 利用 yaml-cpp 的 Load 得到 node 然后遍历 node，利用 stringstream 格式化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// cast from std::vector&lt;T&gt; to std::string</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">FromStr</span> =</span> LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, T&gt;, </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToStr</span> =</span> LexicalCast&lt;T, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> :</span> <span class="keyword">public</span> ConfigVarBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _val = FromStr()(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ToStr()(_val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>自定义类型的支持：</strong></p><p>自定义类型，需要实现 LexicalCast 偏特化，实现后，就可以支持 Config 解析自定义类型，自定义类型可以和常规 STL 容器一起使用。</p><p>例如，增加 Person 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">bool</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from std::string to Person</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, Person&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Person <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        YAML::Node node = YAML::Load(str);</span><br><span class="line">        Person p;</span><br><span class="line">        p.name = node[<span class="string">&quot;name&quot;</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        p.age = node[<span class="string">&quot;age&quot;</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        p.sex = node[<span class="string">&quot;sex&quot;</span>].as&lt;<span class="keyword">bool</span>&gt;();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from Person to std::string</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span>Person, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span> </span>&#123;</span><br><span class="line">        YAML::Node node;</span><br><span class="line">        node[<span class="string">&quot;name&quot;</span>] = p.name;</span><br><span class="line">        node[<span class="string">&quot;age&quot;</span>] = p.age;</span><br><span class="line">        node[<span class="string">&quot;sex&quot;</span>] = p.sex;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="配置的事件机制"><a href="#配置的事件机制" class="headerlink" title="配置的事件机制"></a>配置的事件机制</h3><p>当一个配置项发生修改的时候，可以反向通知对应的代码。</p><p>这个其实挺容易实现的，在 ConfigVar 模板类中添加一个 OnChangeCallBack _cb 回调，它是 </p><p>std::function&lt;const T&amp; oldVal, const T&amp; newVal&gt; 类型的，每当要改变 ConfigVar::_val 时，先判断一下，新的值是否与旧值不同，如果是的化则回调 _cb</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> &#123;</span></span><br><span class="line">... </span><br><span class="line"><span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == _val)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (_cb)</span><br><span class="line">            _cb(_val, v);</span><br><span class="line">        _val = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnChangeCallBack</span><span class="params">(OnChangeCallBack cb)</span> </span>&#123; _cb = cb; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delOnChangeCallBack</span><span class="params">()</span> </span>&#123; _cb = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">    OnChangeCallBack _cb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样配置系统基本就完成了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;配置系统&quot;&gt;&lt;a href=&quot;#配置系统&quot; class=&quot;headerlink&quot; title=&quot;配置系统&quot;&gt;&lt;/a&gt;配置系统&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;配置系统有什么用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的理解是方便程序的运行和发布。把配置变量都抽离出来放在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>rapidjson——dump/load json data to/from file</title>
    <link href="https://codroc.github.io/2022/06/14/rw_file_by_json/"/>
    <id>https://codroc.github.io/2022/06/14/rw_file_by_json/</id>
    <published>2022-06-14T11:57:16.000Z</published>
    <updated>2022-06-14T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rapidjson-dump-load-json-data-to-from-file"><a href="#rapidjson-dump-load-json-data-to-from-file" class="headerlink" title="rapidjson: dump/load json data to/from file"></a>rapidjson: dump/load json data to/from file</h2><p>这里不讨论为什么要用 json，仅仅记录如何把内存中的结构体存储为 json 格式的文件，以及如何把 json 格式的文件内容读入内存；</p><h4 id="从内存中的字符串得到-json-对象"><a href="#从内存中的字符串得到-json-对象" class="headerlink" title="从内存中的字符串得到 json 对象"></a>从内存中的字符串得到 json 对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 假设我们用 C 语言的字符串储存一个 JSON（const char* json）：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    &quot;hello&quot;: &quot;world&quot;,</span></span><br><span class="line"><span class="comment">    &quot;t&quot;: true ,</span></span><br><span class="line"><span class="comment">    &quot;f&quot;: false,</span></span><br><span class="line"><span class="comment">    &quot;n&quot;: null,</span></span><br><span class="line"><span class="comment">    &quot;i&quot;: 123,</span></span><br><span class="line"><span class="comment">    &quot;pi&quot;: 3.1416,</span></span><br><span class="line"><span class="comment">    &quot;a&quot;: [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 把它解析至一个 Document：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rapidjson/document.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> rapidjson;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Document document;</span><br><span class="line">document.Parse(json);</span><br></pre></td></tr></table></figure><h4 id="通过自定义从-0-构造一个-json-对象"><a href="#通过自定义从-0-构造一个-json-对象" class="headerlink" title="通过自定义从 0 构造一个 json 对象"></a>通过自定义从 0 构造一个 json 对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rapidjson/document.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> rapidjson;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Document d;</span><br><span class="line">Document::AllocatorType&amp; allocator = d.GetAllocator();</span><br><span class="line"><span class="comment">// Create the block object at root of DOM</span></span><br><span class="line">d.SetObject();</span><br><span class="line">d.AddMember(<span class="string">&quot;ID&quot;</span>, <span class="number">8086</span>, allocator);</span><br></pre></td></tr></table></figure><h4 id="从文件解析一个-json"><a href="#从文件解析一个-json" class="headerlink" title="从文件解析一个 json"></a>从文件解析一个 json</h4><ul><li>如果文件很小，可以全部读入内存，那么可以使用<strong>内存流</strong>把 json 存储在内存中，然后去解析</li><li>如果文件很大，不能一次性全部读入内存，那么可以使用<strong>文件流</strong>，每次读入一部分去做解析</li></ul><p><strong>内存流输入：</strong></p><p>用 <strong>StringStream</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rapidjson/document.h&quot;</span> <span class="comment">// 会包含 &quot;rapidjson/rapidjson.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> rapidjson;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> json[] = <span class="string">&quot;[1, 2, 3, 4]&quot;</span>; <span class="comment">// json 可以看作是从文件中读入的内容</span></span><br><span class="line"><span class="function">StringStream <span class="title">s</span><span class="params">(json)</span></span>;</span><br><span class="line"> </span><br><span class="line">Document d;</span><br><span class="line">d.ParseStream(s);</span><br></pre></td></tr></table></figure><p><strong>内存流输出：</strong></p><p>用 <strong>StringBuffer</strong></p><p><strong>StringBuffer</strong> 是一个简单的输出流。它分配一个内存缓冲区，供写入整个 json。可使用 <code>GetString()</code> 来获取该缓冲区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rapidjson/stringbuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rapidjson/writer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">StringBuffer buffer;</span><br><span class="line"><span class="function">Writer&lt;StringBuffer&gt; <span class="title">writer</span><span class="params">(buffer)</span></span>;</span><br><span class="line">d.Accept(writer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* output = buffer.GetString();</span><br></pre></td></tr></table></figure><ul><li><code>Writer&lt;StringBuffer&gt; writer(buffer);</code> 表示：告诉 writer 把最终 json 字符串写到 buffer 中去；</li><li><code>d.Accept(writer);</code> 表示：Document 把要写的内容告诉 writer；</li><li>可使用 <code>GetString()</code> 来获取该缓冲区。</li></ul><p><strong>文件流输入：</strong></p><p>用 <strong>FileReadStream</strong></p><p><strong>FileReadStream</strong> 通过 <strong>FILE</strong> 指针读取文件。使用者需要提供一个缓冲区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rapidjson/filereadstream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> rapidjson;</span><br><span class="line"> </span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;big.json&quot;</span>, <span class="string">&quot;rb&quot;</span>); <span class="comment">// 非 Windows 平台使用 &quot;r&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> readBuffer[<span class="number">65536</span>];</span><br><span class="line"><span class="function">FileReadStream <span class="title">is</span><span class="params">(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer))</span></span>; <span class="comment">// 通过 readBuffer 从文件 fp 中读取 sizeof(readBuffer) 个字节到 is 中</span></span><br><span class="line"> </span><br><span class="line">Document d;</span><br><span class="line">d.ParseStream(is);</span><br><span class="line"> </span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><p><strong>文件流输出：</strong></p><p>用 <strong>FileWriteStream</strong></p><p><strong>FileWriteStream</strong> 是一个含缓冲功能的输出流。它的用法与 <strong>FileReadStream</strong> 非常相似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rapidjson/filewritestream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rapidjson/writer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> rapidjson;</span><br><span class="line"> </span><br><span class="line">Document d;</span><br><span class="line">d.Parse(json);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;output.json&quot;</span>, <span class="string">&quot;wb&quot;</span>); <span class="comment">// 非 Windows 平台使用 &quot;w&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> writeBuffer[<span class="number">65536</span>];</span><br><span class="line"><span class="function">FileWriteStream <span class="title">os</span><span class="params">(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer))</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Writer&lt;FileWriteStream&gt; <span class="title">writer</span><span class="params">(os)</span></span>;</span><br><span class="line">d.Accept(writer);</span><br><span class="line"> </span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><blockquote><p>可以看到输入流都是，<code>Document::ParseStream(istream)</code>，输出流都是 <code>Document::Accept(Document::Writer)</code>。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://rapidjson.org/zh-cn/md_doc_stream_8zh-cn.html">流</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;rapidjson-dump-load-json-data-to-from-file&quot;&gt;&lt;a href=&quot;#rapidjson-dump-load-json-data-to-from-file&quot; class=&quot;headerlink&quot; title=&quot;rapidjso</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT 6.824 Lab1 MapReduce</title>
    <link href="https://codroc.github.io/2022/06/10/6.824Lab1MapReduce/"/>
    <id>https://codroc.github.io/2022/06/10/6.824Lab1MapReduce/</id>
    <published>2022-06-10T11:57:16.000Z</published>
    <updated>2022-06-10T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MIT-6-824-Lab1-MapReduce"><a href="#MIT-6-824-Lab1-MapReduce" class="headerlink" title="MIT 6.824 Lab1 MapReduce"></a>MIT 6.824 Lab1 MapReduce</h2><blockquote><p>MapReduce is a programming model and an associated implementation for processing and generating large data sets.</p></blockquote><p>论文《MapReduce: Simplified Data Processing on Large Clusters》开篇第一句话就将明白了 <strong>MapReduce  <strong>的性质：</strong>用于处理或生成大数据的相关实现或编程模型</strong></p><p>如果想看论文翻译请移步 <a href="https://codroc.github.io/2022/06/06/MapReduce/">MapReduce 中文翻译</a>.</p><h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><p>整个计算过程，输入是一系列的 key/value 对，输出也是一系列的 key/value 对。这个计算过程叫做 map 与 reduce，其实就是 <strong>拆分与合并</strong>，其实很像 <strong>分而治之</strong> 的思想。</p><p><strong>例如：把一辆汽车拆成各种零件，再把这些零件组装成一个变形金刚。</strong></p><p>用户只要指定 <em>map</em> 函数和 <em>reduce</em> 函数就可以了，把剩下的交给 <strong>MapReduce 库</strong>去做就可以了。map 和 reduce 函数应该设计成这样：</p><ul><li><em>map</em> 函数接收输入的 key/value pairs，把它们变成 <em>intermediate</em> key/value pairs，MapReduce 库把所有 <em>intermediate</em> key = X （相同 key）的 pairs 集中起来传给 <em>reduce</em> 函数。</li><li><em>reduce</em> 函数接受 <em>intermeidate</em> key = X （相同 key）的 pairs，然后通过某一种规则把他们 merge 起来，生成较少的输出；一般 reduce 函数针对某一个 key 仅仅产生 0 个或 1 个输出。它可以处理那些很大的文件，例如在内存中放不下的文件，它可以以迭代的方式读取并去做 reduce。</li></ul><p>例如，word count 的 map 函数和 reduce 函数，用 go 就是下面这样实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The map function is called once for each file of input. The first</span></span><br><span class="line"><span class="comment">// argument is the name of the input file, and the second is the</span></span><br><span class="line"><span class="comment">// file&#x27;s complete contents. You should ignore the input file name,</span></span><br><span class="line"><span class="comment">// and look only at the contents argument. The return value is a slice</span></span><br><span class="line"><span class="comment">// of key/value pairs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">mr</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line">    <span class="comment">// function to detect word separators.</span></span><br><span class="line">    ff := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> !unicode.IsLetter(r) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// split contents into an array of words.</span></span><br><span class="line">    words := strings.FieldsFunc(contents, ff)</span><br><span class="line"></span><br><span class="line">    kva := []mr.KeyValue&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> words &#123;</span><br><span class="line">        kv := mr.KeyValue&#123;w, <span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line">        kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kva</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The reduce function is called once for each key generated by the</span></span><br><span class="line"><span class="comment">// map tasks, with a list of all the values created for that key by</span></span><br><span class="line"><span class="comment">// any map task.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reduce</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// return the number of occurrences of this word.</span></span><br><span class="line">    <span class="keyword">return</span> strconv.Itoa(<span class="built_in">len</span>(values))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析以下这个 map 和 reduce 具体是做什么的：map 函数接受一个 key/value pair，其中 key 是 filename（文件名），value 是 contents（文件内容），输出是 {word, 1} 的数组；reduce 函数接受某一个 key 的所有 value，输出是一个 value。</p><p><strong>那么 MapReduce 库是怎么让多个 machine 之间协同合作来一起完成 map 任务和 reduce 任务，最终完成所有任务的呢？这就要看一下 MapReduce 库的工作流程了。</strong></p><p><img src="https://s2.loli.net/2022/06/10/bqKmukjXd8YveT3.png" alt="MapReduce0.PNG"></p><p>可以看到它是一个 master 多个 worker 的模式，master 不对任务进行处理，只对 worker 进行协调，worker 去执行具体的 map task 和 reduce task。worker 会以请求任务的方式向 master 要任务去做。这种模式有以下优劣：</p><ul><li><p>把整个库分成两个部分，master 和 worker，这使得整个工作流程清晰易懂。</p></li><li><p>一个 master 而非多个 master，使得编程变得很容易，因为不需要考虑 master 之间的通信，一致性等问题；有好处就会有坏处，只有一个 master 会导致系统可用性，可靠性变差，如果 master 节点 down 了，那么整个服务就不可用了，也就是<strong>不具备容错能力</strong>；</p></li><li><p>多个 worker 使得 MapReduce 库的性能得到大大提高，处理 TB 级别的大量无依赖的数据时，将大大减少处理时间；同时将具有很好的扩展性。</p></li></ul><p>可不可以用一句话来概括 MapReduce 得思想？</p><hr><h3 id="用-Go-具体实现-MapReduce-库"><a href="#用-Go-具体实现-MapReduce-库" class="headerlink" title="用 Go 具体实现 MapReduce 库"></a>用 Go 具体实现 MapReduce 库</h3><ul><li><p>一台 machine 上分配一个 Coordinator 出来，用于协调 worker 之间的工作，并回应 worker 的任务请求。</p></li><li><p>多台 machine 上分配多个 worker 出来，向 Coordinator 索求任务（可以是 map task 也可以是 reduce task，Coordinator 给什么就做什么）。</p></li><li><p>考虑 worker 处理太慢或者突然 down 掉的情况，Coordinator 需要重新分配任务。</p></li><li><p>不考虑 Coordinator down 掉的情况。Coordinator 只会在所有任务都完成后退出，此时 Worker 与 Coordinator 的 RPC 通信会超时并返回错误，这时候就可以知道所有任务都结束了（或者 Worker 的网络状况出问题了），此时 Worker 只需要 exit 就行。</p></li></ul><p>Coordinator 和 Worker 分别需要哪些数据结构？</p><p><strong>Coordinator：</strong></p><ul><li>需要知道最终有多少个 reduce task</li><li>需要给 Worker 分配 id</li><li>需要知道当前是 map 任务还是 reduce 任务</li><li>需要知道是否所有任务都已经做完</li><li>因为某些 Worker 可能 down 掉，因此要记录哪些 Worker 正在做哪些 task，以及 Worker 的状态</li><li>用超时定时器判断 Worker 是否已经 down 了</li><li>需要记录 map task 结束后生成的所有中间结果</li></ul><p>因此最终的数据结构是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WorkerStatus <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Free    WorkerStatus = <span class="literal">iota</span></span><br><span class="line">    Busy</span><br><span class="line">    Timeout</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Your definitions here.</span></span><br><span class="line">    mu sync.Mutex</span><br><span class="line"></span><br><span class="line">    MapTaskFinished <span class="keyword">bool</span></span><br><span class="line">    MapTaskRemain <span class="keyword">int</span> <span class="comment">// 还剩多少 map task 任务可以分配</span></span><br><span class="line">    ReduceTaskFinished <span class="keyword">bool</span></span><br><span class="line">    ReduceTaskRemain <span class="keyword">int</span> <span class="comment">// 还剩多少 reduce task 任务可以分配</span></span><br><span class="line"></span><br><span class="line">    Workers <span class="keyword">int</span></span><br><span class="line">    WS <span class="keyword">map</span>[<span class="keyword">int</span>] WorkerStatus <span class="comment">// WorkerStatus 表示工人目前的状态，0-表示空闲，1-表示正在做任务，2-表示 coordinator 已经联系不到工人了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// map task</span></span><br><span class="line">    WorkerToMapTask <span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">string</span><span class="comment">// worker i 正在做 文件 filename 的 map task</span></span><br><span class="line">    IntermediateFiles []<span class="keyword">string</span></span><br><span class="line">    RecordFiles <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">bool</span> <span class="comment">// 用于记录哪些中间文件已经出现过了</span></span><br><span class="line">    MapTask <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">int</span> <span class="comment">// map task 需要完成的文件还有哪些, 2 表示已经完成, 1 表示还未完成, 0 表示还未分配</span></span><br><span class="line">    MapTaskBaseFilename <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce task</span></span><br><span class="line">    NReduce <span class="keyword">int</span></span><br><span class="line">    WorkerToReduceTask <span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">int</span><span class="comment">// worker i 正在做 第 j 个 reduce task</span></span><br><span class="line">    ReduceTask <span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">int</span> <span class="comment">// reduce task 需要完成的任务还有哪些, 2 表示已经完成, 1 表示还未完成, 0 表示还未分配</span></span><br><span class="line">    ReduceTaskBaseFilename <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// crash</span></span><br><span class="line">    Timer <span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Worker：</strong></p><p>其实 Worker 的很多数据都是 Coordinator 给的，因此不需要特意为他设计。</p><p>它的处理流程的主要结构是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !IsDone() &#123; <span class="comment">// 只要 Coordinator 没结束</span></span><br><span class="line">    AskTask(); <span class="comment">// 向 Coordinator 请求任务</span></span><br><span class="line">    <span class="keyword">if</span> is_map_task() &#123; <span class="comment">// 如果是 map task</span></span><br><span class="line">        <span class="keyword">if</span> has_task_to_do() &#123;</span><br><span class="line">            do_map_task()</span><br><span class="line">            reply := ReportTask() <span class="comment">// 做完任务后向 Coordinator 汇报结果</span></span><br><span class="line">            <span class="keyword">if</span> is_good_job(reply) &#123;</span><br><span class="line">                <span class="comment">// 如果 Coordinator 认可我的工作</span></span><br><span class="line">                <span class="comment">// 因为可能出现，Coordinator 以为我 down 了，把原来我的工作分配给其他人，那么我做的就是无用功了。。。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 暂时没有任务可做，这种情况会在所有 map task 都被分配出去了，但是还没有都完成的情况下出现</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是 reduce task</span></span><br><span class="line">        <span class="keyword">if</span> has_task_to_do() &#123;</span><br><span class="line">            do_reduce_task()</span><br><span class="line">            reply := ReportTask() <span class="comment">// 做完任务后向 Coordinator 汇报结果</span></span><br><span class="line">            <span class="keyword">if</span> is_good_job(reply) &#123;</span><br><span class="line">                <span class="comment">// 如果 Coordinator 认可我的工作</span></span><br><span class="line">                <span class="comment">// 因为可能出现，Coordinator 以为我 down 了，把原来我的工作分配给其他人，那么我做的就是无用功了。。。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 暂时没有任务可做，这种情况会在所有 reduce task 都被分配出去了，但是还没有都完成的情况下出现</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据其主要流程就知道要设计三种 RPC 与 Coordinator 通信：</p><ul><li><p>IsDone：coordinator 是否已经完成了所有任务</p></li><li><p>AskTask：请 coordinator 给我一个任务</p></li><li><p>ReportTask：向 coordinator 汇报我完成的任务</p></li></ul><hr><p>最终代码如下：</p><p><code>mr/rpc.go:</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RPC definitions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// remember to capitalize all names.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// example to show how to declare the arguments</span></span><br><span class="line"><span class="comment">// and reply for an RPC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your RPC definitions here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AskTask: 向 coordinator 请求任务</span></span><br><span class="line"><span class="keyword">type</span> AskTaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    WorkerId <span class="keyword">int</span> <span class="comment">// 当前 worker 的 id，刚开始没分配时为 nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AskTaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    IsMapTask <span class="keyword">bool</span></span><br><span class="line">    IsReduceTask <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// map task</span></span><br><span class="line">    Filename <span class="keyword">string</span> <span class="comment">// 需要做 map 的文件名字</span></span><br><span class="line">    MapTaskBaseFilename <span class="keyword">string</span> <span class="comment">// 把 intermediate key 放到 MapTaskBaseFilename-WokerId-X 文件中去</span></span><br><span class="line">    WorkerId <span class="keyword">int</span> <span class="comment">// coordinator 分配给当前 worker 的 id，只要它还活着，除了他自己以外就没人会占用这个 id</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce task</span></span><br><span class="line">    NReduce <span class="keyword">int</span> <span class="comment">// 总共需要多少个 reduce</span></span><br><span class="line">    ReduceTaskBaseFilename <span class="keyword">string</span> <span class="comment">// reduce 任务的 base filename</span></span><br><span class="line">    XReduce <span class="keyword">int</span> <span class="comment">// woker 要处理第 X 个 reduce 任务，并把输出放到 ReduceTaskBaseFilename-X 中去</span></span><br><span class="line">    AllFiles []<span class="keyword">string</span> <span class="comment">// 所有的中间文件名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AskStatus: 询问 coordinator 当前的状态</span></span><br><span class="line"><span class="keyword">type</span> AskStatusArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AskStatusReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    IsDone <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReportTask: worker 完成了一个任务，向 coordinator 汇报该任务完成情况</span></span><br><span class="line"><span class="keyword">type</span> ReportTaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    WorkerId <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// map task</span></span><br><span class="line">    MapTaskFilename <span class="keyword">string</span></span><br><span class="line">    IntermediateFile []<span class="keyword">string</span> <span class="comment">// map 任务产生的中间文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce task</span></span><br><span class="line">    XReduce <span class="keyword">int</span> <span class="comment">// worker 做的是第 XReduce 个 reduce task</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReportTaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    GoodJob <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cook up a unique-ish UNIX-domain socket name</span></span><br><span class="line"><span class="comment">// in /var/tmp, for the coordinator.</span></span><br><span class="line"><span class="comment">// Can&#x27;t use the current directory since</span></span><br><span class="line"><span class="comment">// Athena AFS doesn&#x27;t support UNIX-domain sockets.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coordinatorSock</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;/var/tmp/824-mr-&quot;</span></span><br><span class="line">    s += strconv.Itoa(os.Getuid())</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mr/coordinator.go:</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WorkerStatus <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Free    WorkerStatus = <span class="literal">iota</span></span><br><span class="line">    Busy</span><br><span class="line">    Timeout</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Your definitions here.</span></span><br><span class="line">    mu sync.Mutex</span><br><span class="line"></span><br><span class="line">    MapTaskFinished <span class="keyword">bool</span></span><br><span class="line">    MapTaskRemain <span class="keyword">int</span> <span class="comment">// 还剩多少 map task 任务可以分配</span></span><br><span class="line">    ReduceTaskFinished <span class="keyword">bool</span></span><br><span class="line">    ReduceTaskRemain <span class="keyword">int</span> <span class="comment">// 还剩多少 reduce task 任务可以分配</span></span><br><span class="line"></span><br><span class="line">    Workers <span class="keyword">int</span></span><br><span class="line">    WS <span class="keyword">map</span>[<span class="keyword">int</span>] WorkerStatus <span class="comment">// WorkerStatus 表示工人目前的状态，0-表示空闲，1-表示正在做任务，2-表示 coordinator 已经联系不到工人了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// map task</span></span><br><span class="line">    WorkerToMapTask <span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">string</span><span class="comment">// worker i 正在做 文件 filename 的 map task</span></span><br><span class="line">    IntermediateFiles []<span class="keyword">string</span></span><br><span class="line">    RecordFiles <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">bool</span> <span class="comment">// 用于记录哪些中间文件已经出现过了</span></span><br><span class="line">    MapTask <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">int</span> <span class="comment">// map task 需要完成的文件还有哪些, 2 表示已经完成, 1 表示还未完成, 0 表示还未分配</span></span><br><span class="line">    MapTaskBaseFilename <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce task</span></span><br><span class="line">    NReduce <span class="keyword">int</span></span><br><span class="line">    WorkerToReduceTask <span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">int</span><span class="comment">// worker i 正在做 第 j 个 reduce task</span></span><br><span class="line">    ReduceTask <span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">int</span> <span class="comment">// reduce task 需要完成的任务还有哪些, 2 表示已经完成, 1 表示还未完成, 0 表示还未分配</span></span><br><span class="line">    ReduceTaskBaseFilename <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// crash</span></span><br><span class="line">    Timer <span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your code here -- RPC handlers for the worker to call.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// an example RPC handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// the RPC argument and reply types are defined in rpc.go.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">Example</span><span class="params">(args *ExampleArgs, reply *ExampleReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    reply.Y = args.X + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">IsDone</span><span class="params">(args *AskStatusArgs, reply *AskStatusReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 由于 Done 是线程安全的，因此 IsDone 也是线程安全的</span></span><br><span class="line">    reply.IsDone = c.Done()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">AskTask</span><span class="params">(args *AskTaskArgs, reply *AskTaskReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.WorkerId == <span class="number">-1</span> &#123;</span><br><span class="line">        args.WorkerId = c.Workers</span><br><span class="line">        c.Workers++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">// 分配任务</span></span><br><span class="line">    worker_id := args.WorkerId</span><br><span class="line">    reply.WorkerId = worker_id</span><br><span class="line">    reply.NReduce = c.NReduce</span><br><span class="line">    reply.XReduce = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !c.MapTaskFinished &#123;</span><br><span class="line">        reply.IsMapTask = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> filename, val := <span class="keyword">range</span> c.MapTask &#123;</span><br><span class="line">            <span class="keyword">if</span> val == <span class="number">0</span> &#123;</span><br><span class="line">                reply.Filename = filename</span><br><span class="line">                reply.MapTaskBaseFilename = c.MapTaskBaseFilename</span><br><span class="line">                c.MapTask[filename] = <span class="number">1</span></span><br><span class="line">                c.WorkerToMapTask[worker_id] = filename</span><br><span class="line">                c.WS[worker_id] = Busy</span><br><span class="line">                c.Timer[worker_id] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !c.ReduceTaskFinished &#123;</span><br><span class="line">        reply.IsReduceTask = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> xreduce, val := <span class="keyword">range</span> c.ReduceTask &#123;</span><br><span class="line">            <span class="keyword">if</span> val == <span class="number">0</span> &#123;</span><br><span class="line">                reply.XReduce = xreduce</span><br><span class="line">                reply.ReduceTaskBaseFilename = c.ReduceTaskBaseFilename</span><br><span class="line">                reply.AllFiles = c.IntermediateFiles</span><br><span class="line">                c.ReduceTask[xreduce] = <span class="number">1</span></span><br><span class="line">                c.WorkerToReduceTask[worker_id] = xreduce</span><br><span class="line">                c.WS[worker_id] = Busy</span><br><span class="line">                c.Timer[worker_id] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">is_timeout</span><span class="params">(worker_id <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.WS[worker_id] == Timeout</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">ReportTask</span><span class="params">(args *ReportTaskArgs, reply *ReportTaskReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    worker_id := args.WorkerId</span><br><span class="line">    <span class="comment">// 如果超时了则不理他</span></span><br><span class="line">    <span class="keyword">if</span>  c.is_timeout(worker_id) &#123;</span><br><span class="line">        reply.GoodJob = <span class="literal">false</span></span><br><span class="line">        c.WS[worker_id] = Free</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !c.MapTaskFinished &#123;</span><br><span class="line">        <span class="keyword">if</span> c.WorkerToMapTask[worker_id] == args.MapTaskFilename &amp;&amp; c.WS[worker_id] == Busy &#123;</span><br><span class="line">            reply.GoodJob = <span class="literal">true</span></span><br><span class="line">            c.WS[worker_id] = Free</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _, intermediate_file := <span class="keyword">range</span> args.IntermediateFile &#123;</span><br><span class="line">                <span class="comment">// 如果中间文件没有出现过，那么就把他加入 IntermediateFiles 中，并把他记录下了，用于去重</span></span><br><span class="line">                _, ok := c.RecordFiles[intermediate_file]</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    c.IntermediateFiles = <span class="built_in">append</span>(c.IntermediateFiles, intermediate_file)</span><br><span class="line">                    c.RecordFiles[intermediate_file] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            c.MapTask[args.MapTaskFilename] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            c.MapTaskRemain--</span><br><span class="line">            <span class="keyword">if</span> c.MapTaskRemain == <span class="number">0</span> &#123;</span><br><span class="line">                c.MapTaskFinished = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !c.ReduceTaskFinished&#123;</span><br><span class="line">        <span class="keyword">if</span> c.WorkerToReduceTask[worker_id] == args.XReduce &amp;&amp; c.WS[worker_id] == Busy &#123;</span><br><span class="line">            reply.GoodJob = <span class="literal">true</span></span><br><span class="line">            c.WS[worker_id] = Free</span><br><span class="line"></span><br><span class="line">            c.ReduceTask[args.XReduce] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            c.ReduceTaskRemain--</span><br><span class="line">            <span class="keyword">if</span> c.ReduceTaskRemain == <span class="number">0</span> &#123;</span><br><span class="line">                c.ReduceTaskFinished = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 所有任务都已经完成了</span></span><br><span class="line">        reply.GoodJob = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// worker 向我汇报了，但他汇报的任务和我发布的不同或者他在 free 或 timeout 状态</span></span><br><span class="line">    <span class="comment">// 但他既然向我汇报了，那么他一定是 Free 的</span></span><br><span class="line">    c.WS[worker_id] = Free</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// start a thread that listens for RPCs from worker.go</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rpc.Register(c)</span><br><span class="line">    rpc.HandleHTTP()</span><br><span class="line">    <span class="comment">//l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)</span></span><br><span class="line">    sockname := coordinatorSock()</span><br><span class="line">    os.Remove(sockname)</span><br><span class="line">    l, e := net.Listen(<span class="string">&quot;unix&quot;</span>, sockname)</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> http.Serve(l, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrcoordinator.go calls Done() periodically to find out</span></span><br><span class="line"><span class="comment">// if the entire job has finished.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">Done</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ret := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> c.MapTaskFinished &amp;&amp; c.ReduceTaskFinished &#123;</span><br><span class="line">        ret = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> worker_id, _ := <span class="keyword">range</span> c.Timer &#123;</span><br><span class="line">        c.Timer[worker_id]++</span><br><span class="line">        <span class="keyword">if</span> c.Timer[worker_id] &gt;= <span class="number">10</span> &amp;&amp; c.WS[worker_id] == Busy &#123;</span><br><span class="line">            c.WS[worker_id] = Timeout</span><br><span class="line">            <span class="keyword">if</span> !c.MapTaskFinished &#123;</span><br><span class="line">                map_task := c.WorkerToMapTask[worker_id]</span><br><span class="line">                c.WorkerToMapTask[worker_id] = <span class="string">&quot;&quot;</span></span><br><span class="line">                c.MapTask[map_task] = <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> !c.ReduceTaskFinished &#123;</span><br><span class="line">                reduce_task := c.WorkerToReduceTask[worker_id]</span><br><span class="line">                c.WorkerToReduceTask[worker_id] = <span class="number">-1</span></span><br><span class="line">                c.ReduceTask[reduce_task] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// create a Coordinator.</span></span><br><span class="line"><span class="comment">// main/mrcoordinator.go calls this function.</span></span><br><span class="line"><span class="comment">// nReduce is the number of reduce tasks to use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeCoordinator</span><span class="params">(files []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>)</span> *<span class="title">Coordinator</span></span> &#123;</span><br><span class="line">    c := Coordinator&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    c.MapTaskRemain = <span class="built_in">len</span>(files)</span><br><span class="line">    c.ReduceTaskRemain = nReduce</span><br><span class="line">    c.NReduce = nReduce</span><br><span class="line"></span><br><span class="line">    c.MapTask = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    c.ReduceTask = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    c.WS = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>] WorkerStatus)</span><br><span class="line">    c.WorkerToMapTask = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">string</span>)</span><br><span class="line">    c.IntermediateFiles = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    c.RecordFiles = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">bool</span>)</span><br><span class="line">    c.WorkerToReduceTask = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">int</span>)</span><br><span class="line">    c.Timer = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    c.MapTaskBaseFilename = <span class="string">&quot;mr&quot;</span></span><br><span class="line">    c.ReduceTaskBaseFilename = <span class="string">&quot;mr-out&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">        c.MapTask[file] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="number">0</span>; idx &lt; nReduce; idx++ &#123;</span><br><span class="line">        c.ReduceTask[idx] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.server()</span><br><span class="line">    <span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mr/worker.go:</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;log&quot;</span></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;hash/fnv&quot;</span></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// Map functions return a slice of KeyValue.</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="keyword">type</span> KeyValue <span class="keyword">struct</span> &#123;</span><br><span class="line">     Key   <span class="keyword">string</span></span><br><span class="line">     Value <span class="keyword">string</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// for sorting by key.</span></span><br><span class="line"> <span class="keyword">type</span> ByKey []KeyValue</span><br><span class="line"></span><br><span class="line"> <span class="comment">// for sorting by key.</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].Key &lt; a[j].Key &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// use ihash(key) % NReduce to choose the reduce</span></span><br><span class="line"> <span class="comment">// task number for each KeyValue emitted by Map.</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">ihash</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     h := fnv.New32a()</span><br><span class="line">     h.Write([]<span class="keyword">byte</span>(key))</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">int</span>(h.Sum32() &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">is_map_task</span><span class="params">(task AskTaskReply)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">     <span class="keyword">return</span> task.IsMapTask</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> <span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line">     reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Your worker implementation here.</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// uncomment to send the Example RPC to the coordinator.</span></span><br><span class="line">     <span class="comment">// CallExample()</span></span><br><span class="line">     <span class="comment">// 如果 mr 任务还没结束</span></span><br><span class="line">     <span class="keyword">var</span> nreduce <span class="keyword">int</span></span><br><span class="line">     worker_id := <span class="number">-1</span></span><br><span class="line">     total_map := <span class="number">0</span></span><br><span class="line">     total_reduce := <span class="number">0</span></span><br><span class="line">     <span class="keyword">for</span> !IsDone() &#123;</span><br><span class="line">         <span class="comment">// 向 coordinator 要任务</span></span><br><span class="line">         task := AskTask(worker_id)</span><br><span class="line">         worker_id = task.WorkerId</span><br><span class="line">         nreduce = task.NReduce</span><br><span class="line">         buckets := <span class="built_in">make</span>([][]KeyValue, nreduce) <span class="comment">// nreduce 个 kva</span></span><br><span class="line">         <span class="keyword">if</span> is_map_task(task) &#123;</span><br><span class="line">             filename := task.Filename</span><br><span class="line">             <span class="keyword">if</span> filename != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                 file, err := os.Open(filename)</span><br><span class="line">                 <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                     log.Fatalf(<span class="string">&quot;Can not open file %v ai&quot;</span>, filename)</span><br><span class="line">                 &#125;</span><br><span class="line">                 content, err := ioutil.ReadAll(file)</span><br><span class="line">                 file.Close()</span><br><span class="line">                 <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                     log.Fatalf(<span class="string">&quot;Can not read file %v&quot;</span>, filename)</span><br><span class="line">                 &#125;</span><br><span class="line">                 kva := mapf(filename, <span class="keyword">string</span>(content))</span><br><span class="line">                 <span class="keyword">for</span> _, item := <span class="keyword">range</span> kva &#123;</span><br><span class="line">                     bucket_number := ihash(item.Key) % nreduce</span><br><span class="line">                     buckets[bucket_number] = <span class="built_in">append</span>(buckets[bucket_number], item);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">// 对 buckets 中的 item 排序</span></span><br><span class="line">                 <span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">                     sort.Sort(ByKey(bucket))</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 intermediate_files := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">                 basename := task.MapTaskBaseFilename + <span class="string">&quot;-&quot;</span> + strconv.Itoa(worker_id)</span><br><span class="line">                 <span class="keyword">for</span> index, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">                     <span class="comment">// TODO</span></span><br><span class="line">                     <span class="comment">// 创建一个临时文件，把 bucket 中的内容写入临时文件中，并在完成任务后通过 ReportTask 向 coordinator 汇报该任务，</span></span><br><span class="line">                     <span class="comment">// 当收到 coordinator 的确认后再把临时文件转正</span></span><br><span class="line">                     oname := basename + <span class="string">&quot;-&quot;</span> + strconv.Itoa(total_map) + <span class="string">&quot;-&quot;</span> + strconv.Itoa(index)</span><br><span class="line">                     intermediate_files = <span class="built_in">append</span>(intermediate_files, oname)</span><br><span class="line">                     ofile, _ := os.OpenFile(oname, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">                     enc := json.NewEncoder(ofile)</span><br><span class="line">                     <span class="keyword">for</span> _, item := <span class="keyword">range</span> bucket &#123;</span><br><span class="line">                         err := enc.Encode(&amp;item)</span><br><span class="line">                         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                             log.Fatalf(<span class="string">&quot;json encoding error!\n&quot;</span>)</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     ofile.Close()</span><br><span class="line">                 &#125;</span><br><span class="line">                 reply := ReportTask(worker_id, task.Filename, intermediate_files, task.XReduce)</span><br><span class="line">                 <span class="keyword">if</span> reply.GoodJob &#123;</span><br><span class="line">                     total_map++</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 暂时没任务，其他 worker 正在做 map task</span></span><br><span class="line">                 time.Sleep(time.Second)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// reduce task</span></span><br><span class="line">             <span class="keyword">if</span> task.XReduce != <span class="number">-1</span> &#123;</span><br><span class="line">                 intermediate := []KeyValue&#123;&#125;</span><br><span class="line">                 <span class="keyword">for</span> _, file := <span class="keyword">range</span> task.AllFiles &#123;</span><br><span class="line">                     ss := strings.Split(file, <span class="string">&quot;-&quot;</span>)</span><br><span class="line">                     sxreduce := ss[<span class="built_in">len</span>(ss) - <span class="number">1</span>]</span><br><span class="line">                     xreduce, _ := strconv.Atoi(sxreduce)</span><br><span class="line">                     <span class="keyword">if</span> xreduce == task.XReduce &#123;</span><br><span class="line">                         f, _ := os.Open(file)</span><br><span class="line">                         dec := json.NewDecoder(f)</span><br><span class="line">                         <span class="keyword">for</span> &#123;</span><br><span class="line">                             <span class="keyword">var</span> kv KeyValue</span><br><span class="line">                             <span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                                 <span class="keyword">break</span></span><br><span class="line">                             &#125;</span><br><span class="line">                             intermediate = <span class="built_in">append</span>(intermediate, kv)</span><br><span class="line">                         &#125;</span><br><span class="line">                         f.Close()</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 sort.Sort(ByKey(intermediate))</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 输出到 ReduceTaskBaseFilename-X 去</span></span><br><span class="line">                 oname := task.ReduceTaskBaseFilename + <span class="string">&quot;-&quot;</span> + strconv.Itoa(task.XReduce)</span><br><span class="line">                 ofile, err := os.OpenFile(<span class="string">&quot;tmp&quot;</span> + oname + <span class="string">&quot;.tmp&quot;</span>, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">                 <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                     log.Fatalf(<span class="string">&quot;Can not open %v\n&quot;</span>, oname)</span><br><span class="line">                 &#125;</span><br><span class="line">                 i := <span class="number">0</span></span><br><span class="line">                 <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(intermediate) &#123;</span><br><span class="line">                     j := i + <span class="number">1</span></span><br><span class="line">                     values := []<span class="keyword">string</span>&#123;intermediate[i].Value&#125;</span><br><span class="line">                     <span class="keyword">for</span> j &lt; <span class="built_in">len</span>(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key &#123;</span><br><span class="line">                         values = <span class="built_in">append</span>(values, intermediate[j].Value)</span><br><span class="line">                         j++</span><br><span class="line">                     &#125;</span><br><span class="line">                     output := reducef(intermediate[i].Key, values)</span><br><span class="line">                     fmt.Fprintf(ofile, <span class="string">&quot;%v %v\n&quot;</span>, intermediate[i].Key, output)</span><br><span class="line">                     i = j</span><br><span class="line">                 &#125;</span><br><span class="line">                 ofile.Close()</span><br><span class="line">                 reply := ReportTask(worker_id, task.Filename, <span class="literal">nil</span>, task.XReduce)</span><br><span class="line">                 <span class="keyword">if</span> reply.GoodJob &#123;</span><br><span class="line">                     total_reduce++</span><br><span class="line">                     tmpfile, _ := os.OpenFile(<span class="string">&quot;tmp&quot;</span> + oname + <span class="string">&quot;.tmp&quot;</span>, os.O_RDONLY|os.O_CREATE|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">                     realfile, _ := os.OpenFile(oname, os.O_WRONLY|os.O_CREATE|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">                     content, _ := ioutil.ReadAll(tmpfile)</span><br><span class="line">                     realfile.Write(content)</span><br><span class="line">                     realfile.Close()</span><br><span class="line">                     tmpfile.Close()</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 暂时没有 reduce task 可做，其他 worker 正在做</span></span><br><span class="line">                 time.Sleep(time.Second)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// example function to show how to make an RPC call to the coordinator.</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// the RPC argument and reply types are defined in rpc.go.</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">CallExample</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// declare an argument structure.</span></span><br><span class="line">     args := ExampleArgs&#123;&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// fill in the argument(s).</span></span><br><span class="line">     args.X = <span class="number">99</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// declare a reply structure.</span></span><br><span class="line">     reply := ExampleReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// send the RPC request, wait for the reply.</span></span><br><span class="line">     call(<span class="string">&quot;Coordinator.Example&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line"></span><br><span class="line">     <span class="comment">// reply.Y should be 100.</span></span><br><span class="line">     fmt.Printf(<span class="string">&quot;reply.Y %v\n&quot;</span>, reply.Y)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// coordinator 是否已经完成了所有任务</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">IsDone</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">     args := AskStatusArgs&#123;&#125;</span><br><span class="line">     reply := AskStatusReply&#123;&#125;</span><br><span class="line">     connect := call(<span class="string">&quot;Coordinator.IsDone&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">     <span class="keyword">if</span> !connect &#123;</span><br><span class="line">         <span class="comment">// coordinator 已经退出了，因为所有任务都已经完成了</span></span><br><span class="line">         <span class="comment">// fmt.Printf(&quot;Coordinator is down!\n&quot;)</span></span><br><span class="line">         os.Exit(<span class="number">0</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> reply.IsDone</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 请 coordinator 给我一个任务</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">AskTask</span><span class="params">(worker_id <span class="keyword">int</span>)</span> <span class="title">AskTaskReply</span></span> &#123;</span><br><span class="line">     args := AskTaskArgs&#123;&#125;</span><br><span class="line">     args.WorkerId = worker_id</span><br><span class="line">     reply := AskTaskReply&#123;&#125;</span><br><span class="line">     <span class="comment">// why? 解除下面这条注释，就会出现问题。。。。迷惑</span></span><br><span class="line">     <span class="comment">// reply.XReduce = -1 // 表示没有 reduce task 可做</span></span><br><span class="line">     connect := call(<span class="string">&quot;Coordinator.AskTask&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">     <span class="keyword">if</span> !connect &#123;</span><br><span class="line">         <span class="comment">// coordinator 已经退出了，因为所有任务都已经完成了</span></span><br><span class="line">         os.Exit(<span class="number">0</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> reply</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 向 coordinator 汇报我完成的任务</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">ReportTask</span><span class="params">(worker_id <span class="keyword">int</span>, filename <span class="keyword">string</span>, intermediate_files []<span class="keyword">string</span>, xreduce <span class="keyword">int</span>)</span> <span class="title">ReportTaskReply</span></span> &#123;</span><br><span class="line">     args := ReportTaskArgs&#123;&#125;</span><br><span class="line">     args.WorkerId = worker_id</span><br><span class="line">     args.MapTaskFilename = filename</span><br><span class="line">     args.IntermediateFile = intermediate_files</span><br><span class="line">     args.XReduce = xreduce</span><br><span class="line"></span><br><span class="line">     reply := ReportTaskReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">     connect := call(<span class="string">&quot;Coordinator.ReportTask&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">     <span class="keyword">if</span> !connect &#123;</span><br><span class="line">         <span class="comment">// coordinator 已经退出了，因为所有任务都已经完成了</span></span><br><span class="line">         os.Exit(<span class="number">0</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> reply</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// send an RPC request to the coordinator, wait for the response.</span></span><br><span class="line"> <span class="comment">// usually returns true.</span></span><br><span class="line"> <span class="comment">// returns false if something goes wrong.</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(rpcname <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">     <span class="comment">// c, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1&quot;+&quot;:1234&quot;)</span></span><br><span class="line">     sockname := coordinatorSock()</span><br><span class="line">     c, err := rpc.DialHTTP(<span class="string">&quot;unix&quot;</span>, sockname)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">     err = c.Call(rpcname, args, reply)</span><br><span class="line">     <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     fmt.Println(err)</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MIT-6-824-Lab1-MapReduce&quot;&gt;&lt;a href=&quot;#MIT-6-824-Lab1-MapReduce&quot; class=&quot;headerlink&quot; title=&quot;MIT 6.824 Lab1 MapReduce&quot;&gt;&lt;/a&gt;MIT 6.824 Lab1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GFS 中文翻译</title>
    <link href="https://codroc.github.io/2022/06/06/GFS/"/>
    <id>https://codroc.github.io/2022/06/06/GFS/</id>
    <published>2022-06-06T11:57:16.000Z</published>
    <updated>2022-06-06T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>GFS 中文翻译</strong></p><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>我们已经设计和实现了Google File System，一个适用于大规模分布式数据处理相关应用的，可扩展的分布式文件系统。它运行在廉价且普通的硬件设备上，并提供了容错的设计，并且为大量的客户端提供极高的聚合处理性能。尽管我们的设计目标和上一个版本的分布式文件系统有很多相同的地方，我们的设计是依据我们应用的工作量以及技术环境来设计的，包括现在和预期的，都有一部分和早先的文件系统的约定有所不同。这就要求我们重新审视传统的设计选择，以及探索一些在根本上不同的设计要点。这个文件系统成功的满足了我们的存储需求。这个文件系统作为那些需要大数据集服务的数据生成处理的基础存储平台而广泛部署在谷歌内部。最大的集群通过上千个计算机的数千个硬盘，提供了数百TB的存储，并且这些数据被数百个客户端并行同时操作。在这个论文里，我们展示了用于支持分布式应用的扩展文件系统接口设计，讨论了许多我们设计的方面，并且列出了我们的micro-benchmarks以及真实应用性能指标。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1.INTRODUCTION"></a>1.INTRODUCTION</h2><p>为了满足google快速增长的数据处理需求，我们设计实现了google文件系统(GFS)。GFS和上一个分布式文件系统有着很多相同的设计目标，比如性能，扩展性，可靠性，以及可用性。然而，它的设计是由我们的具体应用的负载类型以及当前甚至未来技术环境的观察驱动的，所以与早期文件系统的设计假设具有明显的区别。这就要求我们重新审视传统的设计选择，探索出一些在根本上不同的设计观点。 首先，组件失败成为一种常态而不是一种错误(或者说异常)。整个文件系统是由成百上千台廉价的普通机器组成的存储机器，可以被大量的客户端访问。组件的数量和质量在本质上决定了在某一时间有一些是不可用的，并且某些机器无法从当前失败的状态中恢复。我们观察到，应用程序的bug，操作系统bug，人为的错误，硬盘的失败，内存，连接器，网络，电力供应都可以引起这样的问题。因此经常性的监控，错误检测，容错和自动恢复必须集成到系统中。 第二，与传统的标准相比，文件是巨大的。在这里，好几个G的文件是很普通的。每个文件通常包含很多的应用程序处理的对象比如网页文档。当我们日常处理的快速增长的数据集合总是达到好几个TB的大小(包含数十亿的数据),即使文件系统能够支持,我们也不希望去管理数十亿个KB级别的文件。这样设计中的一些假设和参数，比如IO操作和块大小就必须重新定义。 第三，大部分文件都是只会在文件尾新增加数据，而少见修改已有数据的。对一个文件的随机写操作在实际上几乎是不存在的。一旦写完，文件就是只读的，并且一般都是顺序读取的。大量的数据都具有这样的特点。有些数据可能组成很大的数据仓库，并且数据分析程序从头扫描到尾。有些可能是运行应用而不断的产生的数据流。有些是归档的数据。有些是一个机器为另一个机器产生的中间结果，另一个机器及时或者随后处理这些中间结果。假设在大文件上数据访问具有这样的模式，那么当缓存数据在客户端失效后，append操作就成为性能优化和原子性的关键。 第四，应用程序和文件系统api的协同设计，增加了整个系统的灵活性。比如我们通过放松了GFS的一致性模型大大简化了文件系统，同时也没有给应用程序带来繁重的负担。我们也提供了一个原子性的append操作，这样多个客户端就可以对同一个文件并行的进行append操作而不需要彼此间进行额外的同步操作。这些都会在后面进行详细的讨论。</p><h2 id="2-DESIGN-OVERVIEW"><a href="#2-DESIGN-OVERVIEW" class="headerlink" title="2.DESIGN OVERVIEW"></a>2.DESIGN OVERVIEW</h2><h3 id="2-1-Assumptions"><a href="#2-1-Assumptions" class="headerlink" title="2.1 Assumptions"></a>2.1 Assumptions</h3><p>在设计一个满足我们需求的文件系统时，我们以一些充满了挑战和机遇的假设作为指南，之前我们曾间接的提到过一些关键的点，现在我们把这些假设再详细的列出来。</p><ul><li>系统是建立在大量廉价的普通计算机上，这些计算机经常故障。必须对这些计算机持续进行检测，并且在运行的系统上进行：检查，容错，以及从快速故障恢复。</li><li>系统存储了大量的超大文件。我们期望有数百万个文件，每个100mb或者更大。上GB的文件大小应该是很普通的情况而且能被有效的管理。小文件也应该被支持，但我们不需要为它们进行优化。</li><li>工作负载主要由两种类型的读取组成：大的流式读取和小的随机读取。在大的流式读取中，单个操作通常要读取数百k，甚至1m或者更大的数据。对于同一个客户端来说，往往会发起连续的读取操作顺序读取一个文件。小的随机读取通常在某个任意的偏移位置读取几kb的数据。小规模的随机读取通常在文件的不同位置，读取几k数据。对于性能有过特别考虑的应用通常会作批处理并且对他们读取的内容进行排序，这样可以使得他们的读取始终是单向顺序读取，而不需要往回读取数据。</li><li>通常基于GFS的操作都有很多超大的，例如顺序写入(大的流式读取)的文件操作。通常写入操作的数据量和读取的数据量是相当。一旦完成写入，文件就很少会被再次修改。支持文件中任意位置的小规模写入操作，但是不需要为此作特别的优化。</li><li>系统对多客户端并行添加同一个文件必须非常有效以及明确语义细节的进行支持。我们的文件经常使用生产者/消费者队列模式，或者作为多路合并模式进行操作。好几百个运行在不同机器上的生产者，将会并行增加一个文件。其本质就是最小的原子操作的定义。读取操作可能接着生产者操作之后进行，消费者会同时读取这个文件。</li><li>高性能的稳定带宽的网络要比低延时更加重要。我们大多数的目标应用程序都非常重视高速批量处理数据，而很少有人对单个读写操作有严格的响应时间要求。</li></ul><h3 id="2-2-Interface"><a href="#2-2-Interface" class="headerlink" title="2.2 Interface"></a>2.2 Interface</h3><p>GFS虽然他没有实现一些标准的API比如POSIX,但它提供了常见的文件系统的接口。文件是通过pathname来通过目录进行分层管理的。我们支持的一些常见操作：create,delete,open,close,read，write等文件操作。 另外，GFS有snapshot，record append等操作。Snapshort(快照)以低成本创建一个文件或者一个目录树的副本。Record append允许很多个客户端同时对一个文件增加数据，同时保证每一个客户端的添加操作的原子操作性。这个对于多路合并操作和多个客户端同时操作的生产者/消费者队列的实现非常有用，它不用额外的加锁处理。我们发现这种文件对于构造大型分布式应用来说，是不可或缺的。snapshot和record append在后边的3.4 和3.3节有单独讲述。</p><h3 id="2-3-Architecture"><a href="#2-3-Architecture" class="headerlink" title="2.3 Architecture"></a>2.3 Architecture</h3><p><strong>GFS集群由一个单个的master和多个chunkserver（块服务器）组成</strong>，GFS集群会有很多客户端client访问（图1）。每一个节点都是一个普通的Linux计算机，运行的是一个用户级别（user-level）的服务器进程。只要机器资源允许，并且允许不稳定的应用代码导致的低可靠性，我们就在同一台机器上运行chunkserver和client。 在GFS下，每一个文件都拆成固定大小的chunk(块)。<strong>每一个块都由master根据块创建的时间产生一个全局唯一的64位的chunk handle标志</strong>。Chunkservers在本地磁盘上用Linux文件系统保存这些chunk，并且根据chunk handle和字节区间，通过Linux文件系统读/写这些chunk的数据。出于可靠性的考虑，每一个块都会在不同的chunkserver上保存备份。默认情况下，我们保存3个备份，不过用户对于不同的文件namespace区域，可以指定不同的复制级别。 master负责管理所有的文件系统的元数据(metadata,元数据是指描述数据属性的信息，包括存储位置，历史数据等等)，包括namespace，访问控制信息，文件到chunk的映射关系，当前chunk的位置等等信息。master也同样控制系统级别的活动，比如chunk的分配管理，孤点chunk的垃圾回收机制，chunkserver之间的chunk镜像管理。master和这些chunkserver之间会有周期性的的心跳检测，并且在检测的过程中向其发出指令并收集其状态。 连接到各个应用系统的GFS客户端代码包含了文件系统的API，并且会和master和chunkserver进行通讯处理，代表应用程序进行读/写数据的操作。客户端和master进行元数据的操作，但是所有的数据相关的通讯是直接和chunkserver进行的。我们并没有提供POSIX API,因此不需要连接到Linux的vnode层。 客户端或者chunkserver都不会缓存文件数据。客户端缓存机制没有什么好处，这是因为大部分的应用都是流式访问超大文件或者操作的数据集太大而不能被缓存。不设计缓存系统使得客户端以及整个系统都大大简化了（不用设计解决缓存的一致性的问题，也就是缓存同步机制）(不过客户端缓存元数据)。chunkserver不需要缓存文件数据，因为chunks已经跟本地文件一样的被保存了，所以Linux的buffer cache已经把常用的数据缓存到了内存里。</p><p><img src="https://s2.loli.net/2022/06/06/KpelqfMPQ2RoAIH.png" alt="GFS0.PNG"></p><h3 id="2-4-Single-Master"><a href="#2-4-Single-Master" class="headerlink" title="2.4 Single Master"></a>2.4 Single Master</h3><p>引入一个<strong>单个master的设计可以大大简化我们的设计</strong>，并且也让master能够基于全局的角度来针对复杂的chunk的存放和复制做出决策。不过，我们必须尽量减少master的读和写操作，以避免它成为瓶颈。客户端永远不会通过master来做文件的数据读写。客户端只是问master它应当访问那一个chunkserver来访问数据。<strong>客户端在一定时间内缓存这个信息，</strong>并且在后续的操作中都直接和chunkserver进行操作。 这里我们简单介绍一下图1中的读取操作。首先，客户端把应用要读取的文件名和偏移量，根据固定的chunk大小，转换成为文件的chunk index。然后向master发送这个包含了文件名和chunkindex的请求。master返回相关的chunk handle以及对应的位置。客户端cache这些信息，把文件名和chunkindex作为cache的关键索引字。 于是这个客户端就像对应的位置的chunkserver发起请求，通常这个chunkserver会是离这个客户端最近的那个。请求给定了chunk handle以及一个在这个chunk内需要读取得字节区间。在这个chunk内，再次操作数据将不用再通过客户端-master的交互，除非这个客户端本身的cache信息过期了，或者这个文件重新打开了。实际上，客户端通常都会在请求中附加向master询问多个chunk的信息，master于是接着会立刻给这个客户端回应这些chunk的信息。这个附加信息是通过几个几乎没有任何代价的client-master的交互完成的。</p><h3 id="2-5-Chunk-Size"><a href="#2-5-Chunk-Size" class="headerlink" title="2.5 Chunk Size"></a>2.5 Chunk Size</h3><p>chunk 的大小是一个设计的关键参数。<strong>我们选择这个大小为 64M</strong>，远远大于典型的文件系统的block大小。每一个chunk的实例（复制品，快照）都是作为在chunk server上的Linux文件格式存放的，并且只有当需要的情况下才会增长。滞后分配空间(Lazy space allocation)的机制可以通过文件内部分段来避免空间浪费，可能对于这样大的chunk size来说，（内部分段fragment）这可能是一个最大的缺陷了。 chunk 的大小选的稍大，有许多重要的好处。<strong>首先</strong>，它减少了客户端和master的交互，因为在同一个chunk内的读写操作需要客户端初始询问一次master关于chunk位置信息就可以了。这个减少访问量对于我们的系统来说是很显著的，因为我们的应用大部分是顺序读写超大文件的。即使是对小范围的随机读，客户端可以很容易cache一个好几个TB数据文件的所有的位置信息。<strong>其次</strong>，由于是使用一个大的chunk，客户端可以在一个chunk上完成更多的操作，它可以通过维持一个到chunk server的TCP长连接来减少网络管理量(overhead,负载?)。<strong>第三</strong>，它减少了元数据在master上的大小。这个使得我们可以把元数据保存在内存，这样带来一些其他的好处，详细的讨论请见2.6.1节。 在另一方面，即时采用了lazy space allocation的大chunk size也有它的不好的地方。小文件可能仅由一些chunk组成，也许只有一个chunk。如果很多的client都需要访问这个文件，这样那些存储了这些chunk的chunkserver就会变成热点。实际中，热点还没有成为一个主要考虑的问题因为我们的应用绝大部分都是在顺序读取多个大型chunk文件(large multi-chunck files)。 然而，当GFS第一次使用在一个批处理队列系统时，热点确实出现了：把仅占用一个 chunk 的可执行文件写到 GFS，然后同时在数百台机器上开始执行它。只有两三个chunkservers存储这个可执行文件，而这些chunkserver被数百个并发请求瞬间变成超载。我们通过更高的备份级别存储这样的可执行文件(多存几份?)以及错开队列系统的应用程序启动时间解决了这个问题。一个潜在的长远的解决方案是在这种情况下，允许客户端从其他客户端读取数据（P2P下载？）。</p><h3 id="2-6-Metadata"><a href="#2-6-Metadata" class="headerlink" title="2.6 Metadata"></a>2.6 Metadata</h3><p>master 节点保存这样三个主要类型的元数据：①file和chunk namespace，②从files到chunks的映射关系③每一个chunk及其副本的位置。<strong>所有的元数据都是保存在master的内存里。</strong>前两个类型（namep spaces和文件到chunk的映射）通过保存在本地磁盘实现持久化，对这两个类型的元数据的更新会产生相应的操作日志，并且日志也会在远端机器上保存副本。使用log允许我们简单可靠地更新master的状态，不用担心当master crash的时候的不一致性。<strong>master并不持久化保存chunk位置信息。相反，他在启动地时候以及chunkserver加入集群的时候，向每一个chunkserver询问他的chunk信息。</strong></p><h3 id="2-6-1-In-Memory-Data-Structures"><a href="#2-6-1-In-Memory-Data-Structures" class="headerlink" title="2.6.1 In-Memory Data Structures"></a>2.6.1 In-Memory Data Structures</h3><p>因为元数据都是在内存保存的，master 的操作很快。另外 master 很容易,有效地定时地在后台扫描所有的内部状态。这个周期性的扫描是用来实现 chunk 垃圾回收，chunkserver出现失败时进行的重复制，以及为了平衡负载和磁盘空间在chunkserver间的chunk 迁移。4.3，4.4 将进一步讨论这些活动。 这种内存保存数据的方式有一个潜在的问题，就是说整个系统的 chunk 数量以及对应的系统容量是受到master机器的内存限制的。这个在实际生产中并不是一个很严重的限制。master为每 64M chunk 分配的空间不到 64 个字节的元数据。大部分的 chunks 是满的，因为大部分文件都是很大的，包含很多个 chunk，只有文件的最后部分可能是未满的。类似的，每个文件名字空间数据通常需要少于 64 byte 因为文件名称存储时会使用前缀压缩算法进行压缩。 如果有需要支持到更大的文件系统，因为我们是采用内存保存元数据的方式，所以我们可以很简单，可靠，高效，灵活的通过增加master 机器的内存就可以了。</p><h3 id="2-6-2-Chunk-Locations"><a href="#2-6-2-Chunk-Locations" class="headerlink" title="2.6.2 Chunk Locations"></a>2.6.2 Chunk Locations</h3><p>master 并不持久化保存 chunkserver 上保存的 chunk 的记录。它只是在启动的时候简单的从 chunkserver 取得这些信息。master可以在启动之后一直保持自己的这些信息是最新的，因为它控制所有的 chunk 的位置，并且使用普通心跳检测监视 chunkserver 的状态。 我们最开始尝试想把 chunk 位置信息持久化保存在 master 上，但是我们后来发现如果在启动时候，以及定期性从chunkserver上读取chunk位置信息会使得设计简化很多。因为这样可以消除master和chunkserver之间进行chunk信息的同步问题，<strong>当chunkserver加入和离开集群，更改名字，失效，重新启动等等时候，如果master上要求保存chunk信息，那么就会存在信息同步的问题。</strong>在一个数百台机器的组成的集群中，这样的发生chunkserver的变动实在是太平常了。 此外，不在master上保存chunk位置信息的一个重要原因是因为<strong>只有chunkserver对于chunk到底在不在自己机器上有着最后的话语权。</strong>另外，在master上保存这个信息也是没有必要的，因为有很多原因可以导致chunserver可能忽然就丢失了这个chunk（比如磁盘坏掉了等等），或者chunkserver忽然改了名字，那么master上保存这个资料啥用处也没有。</p><h3 id="2-6-3-Operation-Log"><a href="#2-6-3-Operation-Log" class="headerlink" title="2.6.3 Operation Log"></a>2.6.3 Operation Log</h3><p>操作日志保存了关键元数据变化的历史记录。<strong>它是 GFS 的核心</strong>。不仅仅因为这是唯一持久化的元数据记录，也是因为操作日志作为逻辑时间基线，定义了并行操作的顺序。chunks 以及 Files，连同他们的版本（参见4.5节），都是用他们创建时刻的逻辑时间基线来作为唯一的标志。 由于操作日志是极其关键的，我们必须可靠保存它，在元数据改变并且持久化之前，对于客户端来说都是不可见的（也就是说保证原子性）。否则，就算是chunkserver完好的情况下，我们也可能会丢失整个文件系统，或者最近的客户端操作。因此，我们把这个文件保存在多个远程主机上，并且只有当刷新这个相关的操作日志到本地和远程磁盘之后，才会给客户端操作应答。master可以在刷新之前将多个操作日志批量处理，以减少刷新和复制这个日志导致的系统吞吐量。 master通过反演操作日志来回复自身文件系统状态。为了减少启动时间，我们必须保证操作日志的文件尽可能的小。master在日志增长超过某一个大小的时候，执行 checkpoint 动作，卸出自己的状态，这样可以使下次启动的时候从本地硬盘读出这个最新的 checkpoint，然后反演有限记录数。checkpoint是一个类似 B- 树的格式，可以直接映射到内存，而不需要额外的分析。这更进一步加快了恢复的速度，提高了可用性。 因为建立一个checkpoint可能会花一点时间，于是我们这样设定master的内部状态，就是说新建立的checkpoint可以不阻塞新的状态变化。master切换到一个新的log文件，并且在一个独立的线程中创建新的checkpoint。新的checkpoint包含了在切换到新log文件之前的状态变化。当这个集群有数百万文件的时候，创建新的checkpoint会花上几分钟的时间。当checkpoint建立完毕，会写到本地和远程的磁盘。 对于master的恢复，只需要最新的checkpoint以及后续的log文件。旧的checkpoint及其log文件可以删掉了，虽然我们还是保存几个checkpoint以及log，用来防止比较大的故障产生。在checkpoint的时候得故障并不会导致正确性受到影响，因为恢复的代码会检查并且跳过不完整的checkpoint。</p><h3 id="2-7-Consistency-Model"><a href="#2-7-Consistency-Model" class="headerlink" title="2.7 Consistency Model"></a>2.7 Consistency Model</h3><p><strong>GFS 是一个松散的一致性检查的模型</strong>，通过简单高效的实现，来支持我们的高度分布式计算的应用。我们在这里讨论的 GFS 的可靠性以及对应用的可靠性。我们也强调了 GFS 如何达到这些可靠性，实现细节在本论文的其他部分实现。</p><h3 id="2-7-1-Guarantees-by-GFS"><a href="#2-7-1-Guarantees-by-GFS" class="headerlink" title="2.7.1 Guarantees by GFS"></a>2.7.1 Guarantees by GFS</h3><p>文件名字空间的改变（比如，文件的创建）是原子操作。他们是由 master 专门处理的。名字空间的锁定保证了操作的原子性以及正确性（4.1节）；<strong>master 的操作日志定义了这些操作的全局顺序</strong>(2.6.3)。 当数据变更后，文件区域(文件区就是在文件中的一小块内容)的状态取决于变更的类型，变更是否成功以及是否是并发进行的。表1是对结果的一个概述。</p><p><img src="https://s2.loli.net/2022/06/06/2oqGktIrcKexzMV.png" alt="GFS1.PNG"></p><p>如果所有的客户端都看到的是相同的数据的时候，并且与这些客户端从哪个数据的副本读取无关的时候，那我们就称这个file region具有一致性的。<strong>当数据变更前后具有一致性，同时客户端将会看到完整的变更，我们就称该文件区已定义。</strong>当一个更改操作成功完成，没有并发写冲突，那么受影响的region就是已定义的了（肯定是一致性）：所有客户端都可以看到这个变化是什么。并发成功操作会使region的状态进入未定义，但还是一致性的：所有客户端都看到了相同的数据，但它可能无法看到所有的变化(无法区分到底发生了什么变化,如果变更是针对相同的数据写这样有的变更就会被新的变更所覆盖，这样用户就无法看到最先的变更了，同时发生在跨chunk的操作会被拆分成两个操作，这样这个操作的一部分可能会被其他操作覆盖，而另一部分则保留下来，如3.1节末尾所述)。通常它看到的是多个变更组合后的结果。<strong>一个失败的变更会使区域进入非一致的状态(因此也是未定义的状态)：不同的客户端在不同的访问中可能看到不同的数据。</strong>我们下面描述下我们的应用程序如何区分定义良好的区域和未定义的区域。应用程序不需要进一步区分未定义区域的各种不同的类型。 数据变更可能是_write_或者_record append_。写操作会使数据在应用程序指定的偏移位置写入。record append操作会使数据原子性的append，如果是并发性的话则至少会被append一次，但是偏移位置是由 GFS 决定的(然而，通常的理解可能是在客户端想写入的那个文件的尾部)。偏移位置会被返回给客户端，同时标记包含这条记录的那个定义良好的文件区域的起始位置。另外GFS可能会在它们之间插入一些 padding 或者记录的副本。它们会占据那些被认为是不一致的区域，通常它们比用户数据小的多。 在一系列成功的变更之后，变更的文件区域被保证是已定义的，同时包含了最后一次变更的数据写入。GFS 通过两种方式来实现这种结果:(a).将这些变更以相同的操作顺序应用在该 chunk 的所有的副本上(3.1小节);(b).使用 chunk 的版本号来检测那些老旧的副本可能是由于它的 chunkserver 挂掉了而丢失了一些变更。陈旧的副本永远都不会参与变更或者返回给那些向 master 询问 chunk 位置的 client。它们会优先参与垃圾回收。 因为客户端会缓存 chunk 的位置，在信息更新之前它们可能会读到陈旧的副本。时间窗口由缓存值的超时时间以及文件的下一次打开而限制，文件的打开会清除缓存中该文件相关的 chunk 信息。此外，由于我们的大部分操作都是append，因此一个陈旧副本通常会返回一个过早结束的chunk而不是过时的数据。当读取者重试并与 master 联系时，它会立即得到当前的 chunk 位置。 成功的变更很久之后，组件失败仍有可能破坏或者污染数据。GFS 通过周期性的在 master 和所有 chunkserver 间握手找到那些失败的 chunkserver，同时通过校验和(5.2节)来检测数据的污染。一旦发现问题，会尽快的利用正确的副本恢复(4.3节)。只有一个块的所有副本在 GFS 做出反应之前，全部丢失，这个块才会不可逆转的丢失，而通常 GFS 的反应是在几分钟内的。即使在这种情况下，块不可用，而不是被污染：应用程序会收到清晰的错误信息而不是被污染的数据。</p><h3 id="2-7-2-Implications-for-Application"><a href="#2-7-2-Implications-for-Application" class="headerlink" title="2.7.2 Implications for Application"></a>2.7.2 Implications for Application</h3><p>GFS 应用程序可以通过使用简单的技术来适应这种松散的一致性模型，这些技术已经为其他目的所需要：依赖于append 操作而不是覆盖，检查点，写时自我验证，自己标识记录。 实际中，我们所有的应用程序都是通过append 而不是覆盖来改变文件。在一个普通的应用中，程序员生成一个文件都是从头到尾直接生成的。<strong>当写完所有数据后它自动的将文件重命名为一个永久性的名称</strong>，或者通过周期性的检查点检查已经有多少数据被成功写入了。检查点可能会设置应用级的 checksum。读取者仅验证和处理最后一个检查点之前的文件区域，这些区域处于已定义的状态。无论什么样的并发和一致性要求，这个方法都工作的很好。Append 操作比随机写对于应用程序的失败处理起来总是要更加有效和富有弹性。Checkpoint 使得写操作者增量的进行写操作并且防止读操作者处理已经成功写入，但是对于应用程序角度看来并未提交的数据。 另一种常见的应用中，很多写操作同时向一个文件append是为了归并文件或者是作为一个生产者消费者队列。记录的 append 的 append-at-least-once 语义预服务每个写者的输出。Reader 对偶然的空白填充(padding)和重复数据的处理如下：writer 为每条记录准备一些额外信息,比如 checksums，这样它的合法性就可以验证。Reader 可以识别和丢弃额外的 padding，并使用 checksum 记录片段。如果不能容忍重复的数据(比如它们可能触发非幂等操作)，可以通过在记录中使用唯一标识符来过滤它们，很多时候都需要这些标识符命名相应的应用程序实体，比如网页文档。这些用于 record 输入输出的功能函数(除了重复删除)是以库的形式被我们的应用程序共享的，同时应用于 google 其他的文件接口实现。所以，相同系列的记录，加上一些罕见的重复，总是直接被分发给记录的 Reader。</p><h2 id="3-System-interactions"><a href="#3-System-interactions" class="headerlink" title="3.System interactions"></a>3.System interactions</h2><p>我们设计的一个原则是尽量在所有操作中减少与 master 的交互。基于该条件下我们现在阐述 client，master 以及 chunkserver 如何通过交互来实现数据变更，记录 append 以及快照。</p><h3 id="3-1-Leases-and-Mutation-Order"><a href="#3-1-Leases-and-Mutation-Order" class="headerlink" title="3.1 Leases and Mutation Order"></a>3.1 Leases and Mutation Order</h3><p>租约和变更顺序?令牌和变化顺序? 一个变更是指一个改变 chunk 的内容或者 metadata 的操作，比如写操作或者 append 操作。每个变更都需要在所有 chunk 的副本上执行。我们使用租约来保持多个副本间<strong>变更顺序的一致性。</strong>Master授权给其中的一个副本一个该 chunk 的租约，我们把它叫做主副本(<em>primary</em>)。这个 primary 对所有对 chunk 更改进行序列化。然后所有的副本根据这个顺序执行变更。因此，全局的变更顺序首先是由master选择的租约授权顺序来确定的(可能有多个chunk需要进行修改)，而同一个租约内的变更顺序则是由那个主副本来定义的。 租约机制是为了最小化 master 的管理开销而设计的。<strong>一个租约有一个初始化为60s的超时时间设置。</strong>然而只要这个 chunk 正在变更，那个主副本就可以向 master 请求延长租约。这些请求和授权通常是与 master 和 chunkserver 间的心跳信息一起发送的。有时候 master 可能想在租约过期前撤销它(比如，master可能想使对一个正在重命名的文件的变更无效)。即使 master 无法与主副本进行通信，它也可以在旧的租约过期后安全的将租约授权给另一个新的副本。 如图2，我们将用如下的数字标识的步骤来表示一个写操作的控制流程。</p><p><img src="https://s2.loli.net/2022/06/06/l4VGaILz81vjSF6.png" alt="GFS2.PNG"></p><p>1.client 向 master 询问哪个 chunkserver 获取了当前 chunk 的租约以及其他副本所在的位置。如果没有人得到租约，master将租约授权给它选择的一个副本。 2.master 返回该主副本的标识符以及其他副本的位置。Client为未来的变更缓存这个数据。只有当主副本没有响应或者租约到期时它才需要与master联系。 3.client 将数据推送给所有的副本，client可以以任意的顺序进行推送。每个chunkserver会将数据存放在内部的 LRU buffer cache里，直到数据被使用或者过期。通过将<strong>控制流与数据流分离</strong>，我们可以通过将昂贵的数据流基于网络拓扑进行调度来提高性能，而不用考虑哪个chunkserver是主副本。3.2节更深入地讨论了这点。 4.一旦所有的副本应答接收到了数据，client发送一个写请求给主副本，这个请求标识了先前推送给所有副本的数据。主副本会给它收到的所有变更(可能来自多个client)安排一个连续的序列号来进行必需的串行化。它将这些变更根据序列号应用在本地副本上。 5.主副本将写请求发送给所有的次副本，每个次副本以与主副本相同的串行化顺序应用这些变更。 6.所有的次副本完成操作后向主副本返回应答 7.主副本向client返回应答。任何副本碰到的错误都会返回给client。出现错误时，该写操作可能已经在主副本以及一部分次副本上执行成功。(如果主副本失败，那么它不会安排一个序列号并且发送给其他人)。客户端请求将会被认为是失败的，被修改的区域将会处在非一致状态下。我们的客户端代码会通过重试变更来处理这样的错误。<strong>它会首先在3-7步骤间进行一些尝试后在重新从头重试这个写操作。</strong> 如果应用程序的一个写操作很大或者跨越了chunk的边界，GFS client代码会将它转化为多个写操作。它们都会遵循上面的控制流程，但是可能会被来自其他client的操作插入或者覆盖。因此共享的文件区域可能会包含来自不同client的片段，虽然这些副本是一致的(因为所有的操作都按照相同的顺序在所有副本上执行成功了),但是文件区域会处在一种一致但是未定义的状态，正如2.7节描述的那样。</p><h3 id="3-2-Data-Flow"><a href="#3-2-Data-Flow" class="headerlink" title="3.2 Data Flow"></a>3.2 Data Flow</h3><p><strong>为了更有效的使用网络我们将数据流和控制流解耦。</strong>控制流从 client 到达主副本，然后到达其他的所有次副本，而数据则是线性地通过一个精心选择的 chunkserver 链，某种程度上像是管道流水线那样推送过去的。我们的目标是充分利用每个机器的网络带宽，避免网络瓶颈和高延时链路，并且最小化数据推送的延时(最小化同步数据的时间)。 为了充分利用每个机器的网络带宽，数据通过 chunkserver 链线性的推送过去,而不是以其他的拓扑结构进行推送(例如树形)。因此每个机器的带宽都是用于尽可能快地传送数据，而不是在多个接收者之间进行分配。 为了尽可能的避免网络瓶颈和高延时链路(比如 inter-switch 连接通常既是瓶颈延时也高)，每个机器向网络中还没有收到该数据的最近的那个机器推送数据。假设 client 将数据推送给 S1- S4，它会首先将数据推送给最近的chunkserver假设是S1，S1推送给最近的，假设S2，S2推送给S3，S4中离他最近的那个。我们网络拓扑足够简单，以至于距离可以通过IP地址估计出来。 最后为了最小化延时，我们通过将TCP数据传输进行流水化。一旦一个chunkserver收到数据，它就开始立即往下发送数据。流水线对我们来说尤其有用，因为我们使用了一个全双工链路的交换网络。立即发送数据并不会降低数据接受速率。如果没有网络拥塞，向R个副本传输B字节的数据理想的时间耗费是B/T+RL,T代表网络吞吐率，L是机器间的网络延时。我们的网络连接是100Mbps(T),L远远低于1ms，因此1MB的数据理想情况下需要80ms就可以完成。</p><h3 id="3-3-Atomic-Record-Appends"><a href="#3-3-Atomic-Record-Appends" class="headerlink" title="3.3 Atomic Record Appends"></a>3.3 Atomic Record Appends</h3><p>GFS 提供一个原子性的 append 操作叫做 <em>record append</em> (注意这与传统的 append 操作也是不同的)。在传统的写操作中，用户指定数据需要写的偏移位置。对于相同区域的并行写操作是不可串行的：该区域的末尾可能包含来自多个 client 的数据片段。但在一个 record append 操作中，client 唯一需要说明的只有数据。GFS 会将它至少原子性地 append 到文件中一次，append 的位置是由 GFS 选定的，同时会将这个位置返回给 client。这很类似于unix 文件打开模式中的 O_APPEND，当多个写者并发操作时不会产生竞争条件。 Record append 在我们的分布式应用中被大量的使用。在我们的应用中很多在不同机器的 client 并发地向同一个文件 append。<strong>如果使用传统的写操作，client 将需要进行复杂而又昂贵的同步化操作，比如通过一个分布式锁管理器。</strong>在我们的工作负载中，这样的文件通常作为一个多生产者/单消费者队列或者用来保存来自多个不同 client 的归并结果。 Record append 是一种类型的变更操作，除了一点在主副本上的额外的逻辑外依然遵循 3.1 节的控制流。Client 将所有的数据推送给所有副本后，它向主副本发送请求。主副本检查将该记录 append 到该 chunk 后是否会导致该 chunk 超过它的最大值(64MB)。如果超过了，它就将该 chunk 填充到最大值，告诉所有的次副本做同样的工作，然后告诉客户端该操作应该在下一个 chunk 上重试。(<strong>append 的 Record 大小需要控制在最大 chunk 大小的四分之一以内</strong>，这样可以保证最坏情况下的碎片可以保持在一个可以接受的水平上 )。如果 record 没有超过最大尺寸，就按照普通情况处理，主副本将数据 append 到它的副本上，告诉次副本将数据写在相同的偏移位置上，最后向 client 返回成功应答。 如果 record append 在任何一个副本上失败，client 就会重试这个操作。这样，相同 chunk 的多个副本就可能包含不同的数据，这些数据可能包含了相同记录的整个或者部分的重复值。GFS 并不保证所有的副本在byte 级别上的一致性，它只保证数据作为一个原子单元最少写入一次。这个属性是由如下的简单的观察中得出，当操作报告成功时，数据必须写在所有副本的相同chunk的相同偏移量写入。此外，所有的副本都必须至少和纪录结束点等长，并且因此即使另外一个副本成了主副本(primary)，所有后续的纪录都会被分配在一个较高的偏移量或者在另外一个chunk中。在我们的一致性保证里，record append 操作成功后写下的数据区域是已定义的(肯定是一致的)，然而介于其间的数据则是不一致的(因此也是未定义的)。我们的应用程序可以处理这样的不一致区域，正如我们在 2.7.2 里讨论的那样。</p><h3 id="3-4-Snapshot"><a href="#3-4-Snapshot" class="headerlink" title="3.4 Snapshot"></a>3.4 Snapshot</h3><p>快照操作在尽量不影响正在执行的变更操作的情况下，<strong>几乎即时</strong>产生一个文件或者目录树（“源”）。用户经常用它来创建大数据集的分支拷贝（经常还有拷贝的拷贝，递归拷贝），或者在提交变动前做一个当前状态的checkpoint，这样可以使得接下来的commit或者回滚容易一点。 像 AFS，我们使用标准的copy-on-writer技术来实现快照。当master收到一个快照请求时，它首先撤销将要进行快照的那些文件对应的chunk的所有已发出的租约。这就使得对于这些chunk的后续写操作需要与master交互来得到租约持有者。这就首先给master一个机会创建该chunk的新的拷贝。 当这些租约被撤销或者过期后，master将这些操作以日志形式写入磁盘。然后复制该文件或者目录树的元数据，然后将这些日志记录应用到内存中的复制后的状态上，<strong>新创建的快照文件与源文件一样指向相同的chunk。</strong> 当 client 在快照生效后第一次对一个chunk C进行写入时，它会发送请求给master找到当前租约拥有者。Master注意到对于chunk C的引用计数大于1。它延迟回复客户端的请求，选择一个新的chunk handle C 。然后让每个拥有 C 的那些 chunkserver 创建一个新的叫做 C 的chunk。通过在相同的chunkserver上根据原始的chunk创建新chunk，<strong>就保证了数据拷贝是本地，而不是通过网络</strong>(我们的硬盘比100Mbps网络快大概三倍)。这样，对于任何chunk的请求处理都没有什么不同：master为新chunk C 的副本中的一个授权租约，然后返回给 client，这样它就可以正常的写这个 chunk 了，client 不需要知道该 chunk 实际上是从一个现有的 chunk 创建出来的。</p><h2 id="4-Master-Operation"><a href="#4-Master-Operation" class="headerlink" title="4.Master Operation"></a>4.Master Operation</h2><p>Master 执行所有的 namespace 操作。此外，它还管理整个系统的 chunk 备份：决定如何放置，创建新的 chunk 和相应的副本，协调整个系统的活动保证 chunk 都是完整备份的，在 chunkserver 间进行负载平衡，回收没有使用的存储空间。我们现在讨论这些主题。</p><h3 id="4-1-Namespace-Management-and-Locking"><a href="#4-1-Namespace-Management-and-Locking" class="headerlink" title="4.1 Namespace Management and Locking"></a>4.1 Namespace Management and Locking</h3><p>很多master操作都需要花费很长时间：比如，一个快照操作要撤销该快照所包含的chunk的所有租约。我们并不想耽误其他运行中的master操作，因此我们允许多个操作处于活动状态并通过在namespace区域使用锁来保证正确的串行化。 不像传统的文件系统，GFS的目录并没有一种数据结构用来列出该目录下所有文件，而且也不支持文件或者目录别名(像unix的硬链接或者软连接那样)。GFS在逻辑上通过一个路径全称到元数据映射的查找表来表示它的名字空间。通过采用前缀压缩，这个表可以有效地在内存中表示。namespace树中的每个节点(要么是文件的绝对路径名称要么是目录的)具有一个相关联的读写锁。 每个master操作在它运行前，需要获得一个锁的集合。比如,如果它想操作/d1/d2…/dn/leaf，那么它需要获得/d1,/d1/d2……/d1/d2…/dn这些目录的读锁，然后才能得到路径/d1/d2…/dn/leaf的读锁或者写锁。注意Leaf可能是个文件或者目录，这取决于具体的操作。 我们现在解释一下，当为/home/user创建快照/save/user时，锁机制如何防止文件/home/user/foo被创建。快照操作需要获得在/home和/save上的读锁，以及/home/user和/save/user上的写锁。文件创建需要获得在/home和/home/user上的读锁，以及在/home/user/foo上的写锁。这两个操作将会被正确的串行化，因为它们试图获取在/home/user上的相冲突的锁。文件创建并不需要父目录的写锁，因为实际上这里并没有”目录”或者说是类似于inode的数据结构，需要防止被修改。读锁已经足够用来防止父目录被删除。 这种锁模式的一个好处就是它允许对相同目录的并发变更操作。比如多个文件的创建可以在相同目录下并发创建：每个获得该目录的一个读锁，以及文件的一个写锁。目录名称上的读锁足够可以防止目录被删除，重命名或者快照。文件名称上的写锁将会保证重复创建相同名称的文件的操作只会被执行一次。 因为namespace有很多节点，所以读写锁对象只有在需要时才会被分配，(懒加载)一旦不再使用用就删除。为了避免死锁，锁是按照一个一致的全序关系进行获取的：首先根据所处的namespace树的级别，相同级别的则根据字典序。</p><h3 id="4-2-Replica-Placement"><a href="#4-2-Replica-Placement" class="headerlink" title="4.2 Replica Placement"></a>4.2 Replica Placement</h3><p>副本位置。GFS集群是高度分布在多个层次上的。它拥有数百个散步在多个机柜中的chunkserver。这些chunkserver又可以被来自不同或者相同机柜上的client访问。处在不同机柜的机器间的通信可能需要穿过一个或者更多的网络交换机。此外，进出一个机柜的带宽可能会小于机柜内所有机器的带宽总和。多级的分布式带来了数据分布式时的扩展性，可靠性和可用性方面的挑战。 Chunk的备份放置策略服务于两个目的：最大化数据可靠性和可用性，最小化网络带宽的使用。为了达到这两个目的，仅仅将备份放在不同的机器是不够的，这只能应对机器或者硬盘失败，以及最大化利用每台机器的带宽。我们必须在机柜间存放备份。这样能够保证当一个机柜整个损坏或者离线(比如网络交换机故障或者电路出问题)时，该chunk的存放在其他机柜的某些副本仍然是可用的。这也意味着对于一个chunk的流量，尤其是读取操作可以充分利用多个机柜的带宽。另一方面，写操作需要在多个机柜间进行，这是我们权衡之后认为可以接受的。</p><h3 id="4-3-Creation-Re-replication-Rebalancing"><a href="#4-3-Creation-Re-replication-Rebalancing" class="headerlink" title="4.3 Creation,Re-replication,Rebalancing"></a>4.3 Creation,Re-replication,Rebalancing</h3><p>Chunk副本的创建主要有三个原因：chunk的创建，重备份，重平衡。 当master创建一个chunk时，它会选择放置初始化空白副本的位置。它会考虑几个因素：1.尽量把新的chunk放在那些低于平均磁盘空间使用值的那些chunkserver上。随着时间的推移，这会使得chunkserver的磁盘使用趋于相同；2.尽量限制每个chunkserver上的最近的文件创建数，虽然创建操作是很简单的，但是它后面往往跟着繁重的写操作，因为chunk的创建通常是因为写者的需要而创建它。在我们的一次append多次读的工作负载类型中，一旦写入完成，它们就会变成只读的。3.正如前面讨论的，我们希望在机柜间存放chunk的副本。 当chunk的可用备份数低于用户设定的目标值时，Master会进行重复制。有多个可能的原因导致它的发生：chunkserver不可用，chunkserver报告它的某个备份已被污染，一块硬盘由于错误而不可用或者用户设定的目标值变大了。需要重复制的chunk根据几个因素确定优先级。一个因素是它与备份数的目标值差了多少，比如我们给那些丢失了2个副本的chunk比丢失了1个的更高的优先级。另外，比起最近被删除的文件的chunk，我们更想备份那些仍然存在的文件的chunk(参考4.4节)。最后，为了最小化失败对于运行中的应用程序的影响，我们提高那些阻塞了用户进度的chunk的优先级。 Master选择最高优先级的chunk，通过给某个chunkserver发送指令告诉它直接从一个现有合法部分中拷贝数据来进行克隆。新备份的放置与创建具有类似的目标：平均磁盘使用，限制在单个chunkserver上进行的clone操作数，使副本存放在不同机柜间。为了防止clone的流量淹没client的流量，master限制整个集群已经每个chunkserver上处在活动状态的clone操作数。另外每个chunkserver还会限制它用在clone操作上的带宽，通过控制它对源chunkserver的读请求。 最后，master会周期性的对副本进行重平衡。它检查当前的副本分布，然后为了更好的磁盘空间使用和负载均衡，将副本进行移动。而且在这个过程中，master是逐步填充一个新的chunkserver，而不是立即将新的chunk以及大量沉重的写流量使他忙的不可开交。对于一个新副本的放置，类似于前面的那些讨论。另外，master必须选择删除哪个现有的副本。通常来说，它更喜欢那些存放在低于平均磁盘空闲率的chunkserver上的chunk，这样可以使磁盘使用趋于相等。</p><h3 id="4-4-Garbage-Collection"><a href="#4-4-Garbage-Collection" class="headerlink" title="4.4 Garbage Collection"></a>4.4 Garbage Collection</h3><p>文件删除后，GFS并不立即释放可用的物理存储。它会将这项工作推迟到文件和chunk级别的垃圾回收时做。我们发现，这种方法使得系统更简单更可靠。</p><h3 id="4-4-1-Mechanism"><a href="#4-4-1-Mechanism" class="headerlink" title="4.4.1 Mechanism"></a>4.4.1 Mechanism</h3><p>当文件被应用程序删除时，master会将这个删除操作立刻写入日志(就像其他变更操作)。但是文件不会被立即删除(回收)，而是被重命名为一个包含删除时间戳的隐藏名称。在master对文件系统进行常规扫描时，它会删除那些存在时间超过3天(这个时间是可以配置的)的隐藏文件。在此之前，文件依然可以用那个新的特殊名称进行读取，或者重命名回原来的名称来取消删除。当隐藏文件从名字空间删除后，它的元数据会被擦除。这样就有效地切断了它与所有chunk的关联。 在chunk的类似的常规扫描中，master找到那些孤儿块(无法从任何文件到达)，擦除这些块的元数据。在chunkserver与master周期性心跳信息中，chunkserver报告它所拥有的chunk的那个子集，然后master返回那些不在master的元数据中出现的chunk的标识。Chunkserver就可以自由的删除这些chunk的那些副本了。</p><h3 id="4-4-2-Discussion"><a href="#4-4-2-Discussion" class="headerlink" title="4.4.2 Discussion"></a>4.4.2 Discussion</h3><p>虽然分布式的垃圾回收是一个艰巨的问题，在程序设计的时候需要复杂的解决，但是在我们的系统中却是比较简单的。我们可以轻易辨别出对一个chunk的全部引用：它们都唯一保存在master的file-to-chunk映射中。我们也可以容易辨别所有的chunk副本：它们是在各个chunkserver上的指定目录下的linux文件。所有不被master知道的副本就是”垃圾”。 采用垃圾回收方法收回存储空间与直接删除相比，提供了几个优势：首先在经常出现组件失败的大规模分布式系统中，它是简单而且可靠的。Chunk创建可能在某些chunkserver上成功，在另外一些失败，这样就留下一些master所不知道的副本。副本删除消息可能丢失，master必须记得在出现失败时进行重发。垃圾回收提供了一种统一，可信赖的清除无用副本的方式。其次，它将存储空间回收与master常规的后台活动结合在一起，比如名字空间扫描，与chunkserver的握手。因此它们是绑在一块执行的，这样开销会被平摊。而且只有当master相对空闲时才会执行。Master就可以为那些具有时间敏感性的客户端请求提供更好的响应。第三，空间回收的延迟为意外的不可逆转的删除提供了一道保护网。 根据我们的经验，主要的缺点是：滞后删除会导致阻碍我们尝试调整磁盘使用情况的效果。那些频繁创建和删除中间文件的应用程序不能够立即重用磁盘空间。我们通过当已删除的文件被再次删除时加速它的存储回收来解决这个问题。我们也允许用户在不同的namespace内使用不同的重备份和回收策略。比如用户可以指定某个目录树下的文件的chunk使用无副本存储，任何已删除的文件立刻并且不可撤销的从文件系统状态中删除。</p><h3 id="4-5-Stale-Replica-Detection"><a href="#4-5-Stale-Replica-Detection" class="headerlink" title="4.5 Stale Replica Detection"></a>4.5 Stale Replica Detection</h3><p>如果chunkserver失败或者在它停机期间丢失了某些更新，chunk副本就可能变为过期的。对于每个chunk，master维护一个版本号来区分最新和过期的副本。 无论何时只要master为一个chunk授权一个新的租约，那么它的版本号就会增加，然后通知副本进行更新。在一致的状态下，Master和所有副本都会记录这个新的版本号。这发生在任何client被通知以前，因此也就是client开始向chunk中写数据之前。如果另一个副本当前不可用，它的chunk版本号就不会被更新。当chunkserver重启或者报告它的chunk和对应的版本号的时候，master会检测该chunkserver是否包含过期副本。如果master发现有些版本号大于它的记录，master就认为它在授权租约时失败了，所以采用更高的版本号的那个进行更新。 Master通过周期性的垃圾回收删除过期副本。在删除之前,它需要确认在它给所有客户端的chunk信息请求的应答中都没有包含这个过期的副本。作为另外一种保护措施，当master通知客户端那个chunkserver包含某chunk的租约或者当它在clone操作中让chunkserver从另一个chunkserver中读取chunk时，会将chunk的版本号包含在内。当client和chunkserver执行操作时，总是会验证版本号，这样就使得它们总是访问最新的数据。</p><h2 id="5-Fault-Tolerance-And-Diagnosis"><a href="#5-Fault-Tolerance-And-Diagnosis" class="headerlink" title="5.Fault Tolerance And Diagnosis"></a>5.Fault Tolerance And Diagnosis</h2><p>容错和诊断。在设计系统时，一个最大的挑战就是频繁的组件失败。组件的数量和质量使得这些问题变成一种常态而不再是异常。我们不能完全信任机器也不能完全信任磁盘。组件失败会导致系统不可用，甚至是损坏数据。我们讨论下如何面对这些挑战，以及当它们不可避免的发生时，在系统中建立起哪些工具来诊断问题。</p><h3 id="5-1-High-Availability"><a href="#5-1-High-Availability" class="headerlink" title="5.1 High Availability"></a>5.1 High Availability</h3><p>在GFS的数百台服务器中，在任何时间总是有一些是不可用的。我们通过两个简单有效的策略来保持整个系统的高可用性：快速恢复和备份。</p><h3 id="5-1-1-Fast-Recovery"><a href="#5-1-1-Fast-Recovery" class="headerlink" title="5.1.1 Fast Recovery"></a>5.1.1 Fast Recovery</h3><p><strong>快速恢复机制。</strong>经过设计后Master和chunkserver无论何时并以任意的方式被终止,我们都可以在在几秒内恢复它们的状态并启动。事实上，我们并没有区分正常和异常的终止。服务器通常都是通过杀死进程来关闭。客户端和其他服务器的请求超时后会经历一个小的停顿，然后重连那个重启后的服务器，进行重试。6.2.2报告了观测到的启动时间。</p><h3 id="5-1-2-Chunk-Replication"><a href="#5-1-2-Chunk-Replication" class="headerlink" title="5.1.2 Chunk Replication"></a>5.1.2 Chunk Replication</h3><p><strong>chunk备份</strong>。正如之前讨论的，每个chunk备份在不同机柜上的多个chunkserver上。用户可以在不同名字空间内设置不同的备份级别，默认是3.当chunkserver离线或者通过检验和检测到某个chunk损坏后(5.2节)，master会克隆现有的副本使得副本的数保持充足。尽管副本已经很好的满足了我们的需求，我们还探寻一些其他的具有同等或者更少code的跨机器的冗余方案，来满足我们日益增长的只读存储需求。我们期望在我们的非常松散耦合的系统中实现这些更复杂的冗余模式是具有挑战性但是可管理的。因为我们的负载主要是append和读操作而不是小的随机写操作。</p><h3 id="5-1-3-Master-Replication"><a href="#5-1-3-Master-Replication" class="headerlink" title="5.1.3 Master Replication"></a>5.1.3 Master Replication</h3><p>为了可靠性，master的状态需要进行备份。它的操作日志和检查点备份在多台机器上。对于状态的变更只有当它的操作日志被写入到本地磁盘和所有的远程备份后，才认为它完成。为了简单起见，master除了负责进行各种后台活动比如：垃圾回收外，还要负责处理所有的变更。当它失败后，几乎可以立即重启。如果它所在的机器或者硬盘坏了，独立于GFS的监控设施会利用备份的操作日志在别处重启一个新的master进程。Client仅仅使用master的一个典型名称(比如gfs-test)来访问它，这是一个DNS名称，如果master被重新部署到一个新的机器上，可以改变它。 此外，当主master down掉之后，还有多个影子master可以提供对文件系统的只读访问。它们是影子，而不是镜像，这意味着它们可能比主master要滞后一些，通常可能是几秒。对于那些很少发生变更的文件或者不在意轻微过时的应用程序来说，它们增强了读操作的可用性。实际上，因为文件内容是从chunkserver中读取的，应用程序并不会看到过期的文件内容。文件元数据可能在短期内是过期的，比如目 录内容或者访问控制信息。</p><h3 id="5-2-Data-Integrity"><a href="#5-2-Data-Integrity" class="headerlink" title="5.2 Data Integrity"></a>5.2 Data Integrity</h3><p><strong>数据完整性。</strong>每个chunkserver通过校验和来检测存储数据中的损坏。GFS集群通常具有分布在几百台机器上的数千块硬盘，这样它就会经常出现导致数据损坏或丢失的硬盘失败。我们可以从chunk的其他副本中恢复被损坏的数据，但是如果通过在chunkserver间比较数据来检测数据损坏是不现实的。另外，有分歧的备份仍然可能是合法的：根据GFS的变更语义，尤其是前面提到的原子性的record append操作，并不保证所有副本是完全一致的。因此每个chunkserver必须通过维护一个检验和来独立的验证它自己的拷贝的完整性。 一个chunk被划分为64kb大小的块。每个块有一个相应的32bit的校验和。与其他的元数据一样，校验和与用户数据分离的，它被存放在内存中，同时通过日志进行持久化存储。 对于读操作，chunkserver在向请求者(可能是一个client或者其他的chunkserver)返回数据前，需要检验与读取边界重叠的那些数据库的校验和。因此chunkserver不会将损坏数据传播到其他机器上去。如果一个块的校验和与记录中的不一致，chunkserver会向请求者返回一个错误，同时向master报告这个不匹配。之后，请求者会向其他副本读取数据，而master则会用其他副本来clone这个chunk。当这个合法的新副本创建成功后，master向报告不匹配的那个chunkserver发送指令删除它的副本。 校验和对于读性能的影响很小，因为：我们大部分的读操作至少跨越多个块，我们只需要读取相对少的额外数据来进行验证。GFS client代码通过尽量在校验边界上对齐读操作大大降低了开销。另外在chunkserver上校验和的查找和比较不需要任何的IO操作，校验和的计算也可以与IO操作重叠进行。 校验和计算对于append文件末尾的写操作进行了特别的优化。因为它们在工作负载中占据了统治地位。我们仅仅增量性的更新最后一个校验块的校验值，同时为那些append尾部的全新的校验块计算它的校验值。即使最后一个部分的校验块已经损坏，而我们现在无法检测出它，那么新计算出来的校验和将不会与存储数据匹配，那么当这个块下次被读取时，就可以检测到这个损坏。(也就是说这里并没有验证最后一个块的校验值，而只是更新它的值，也就是说这里省去了验证的过程，举个例子假设最后一个校验块出现了错误，由于我们的校验值计算时是增量性的，也就是说下次计算不会重新计算已存在的这部分数据的校验和，这样该损坏就继续保留在校验和里，关键是因为这里采用了增量型的校验和计算方式)。 与之相对的，如果一个写操作者覆盖了一个现有chunk的边界，我们必须首先读取和验证操作边界上的第一个和最后一个块，然后执行写操作，最后计算和记录新的校验和。如果在覆盖它们之前不验证第一个和最后一个块，新的校验和就可能隐藏掉那些未被覆盖的区域的数据损坏。(因为这里没有采用增量计算方式，因为它是覆盖不是append所以现有的检验和就是整个块的没法从中取出部分数据的校验和，必须重新计算)。 在空闲期间，chunkserver可以扫描验证处在非活动状态的trunk的内容。这允许我们检测到那些很少被读取的数据的损失。一旦损坏被发现，master就可以创建一个新的未损坏副本并且删除损坏的副本。这就避免了一个不活跃的坏块骗过master，让之以为块有足够的好的副本。</p><h3 id="5-3-Diagnostic-Tools"><a href="#5-3-Diagnostic-Tools" class="headerlink" title="5.3 Diagnostic Tools"></a>5.3 Diagnostic Tools</h3><p><strong>诊断工具</strong>。全面而详细的诊断性的日志以很小的成本提供了问题分解，调试，性能分析上不可估量的帮助。没有日志，就很难理解那些机器间偶然出现的不可重复的交互。GFS生成一个诊断日志用来记录很多重要事件(比如chunkserver的启动停止)以及所有RPC请求和应答。这些诊断日志可以自由的删除而不影响系统的正常运行。然而，只要磁盘空间允许，我们会尽量保存这些日志。 除了正在读写的文件数据,RPC日志包含了精确(exact,所有???)的请求和响应信息。通过匹配请求和响应，整理不同机器上的RPC日志，我们可以重新构建出整个交互历史来诊断一个问题。这些日志也可以用来进行负载测试和性能分析。 因为日志是顺序异步写的，因此写日志对于性能的影响是很小的，得到的好处却是大大的。最近的事件也会保存在内存中，可以用于持续的在线监控。</p><h2 id="6-Measurements"><a href="#6-Measurements" class="headerlink" title="6.Measurements"></a>6.Measurements</h2><p>在这一节，我们用一些小规模的测试来展示GFS架构和实现固有的一些瓶颈，有一些数字来源于google的实际集群。</p><h3 id="6-1-Mirco-benchmarks"><a href="#6-1-Mirco-benchmarks" class="headerlink" title="6.1 Mirco-benchmarks"></a>6.1 Mirco-benchmarks</h3><p>我们在一个master，两个master备份，16个chunkserver，16个client组成的GFS集群上进行了性能测量。这个配置是为了方便测试，实际中的集群通常会有数百个chunkserver，数百个client。 所有机器的配置是，双核PIII 1.4GHz处理器，2GB内存，两个80G，5400rpm硬盘，以及100Mbps全双工以太网连接到HP2524交换机。所有19个GFS服务器连接在一个交换机，所有16个客户端连接在另一个上。两个交换机用1Gbps的线路连接。</p><h3 id="6-1-1-Reads"><a href="#6-1-1-Reads" class="headerlink" title="6.1.1 Reads"></a>6.1.1 Reads</h3><p>N个客户端从文件系统中并发读。每个客户端在一个320GB的文件集合里随机4MB进行读取。然后重复256次，这样每个客户端实际上读取了1GB数据。Chunkserver总共只有32GB内存，因此我们估计在linux的buffer cache里最多有10%的命中率。我们的结果应该很接近一个几乎无缓存的结果。 图3(a)展示了对于N个客户端的总的读取速率以及它的理论上的极限。当2个交换机通过一个1Gbps的链路连接时，它的极限峰值是125MB/s，客户端通过100Mbps连接，那么换成单个客户端的极限就是12.5MB/s。当只有一个客户端在读取时，观察到的读取速率是10MB/s，达到了单个客户端极限的80%。当16个读取者时，总的读取速率的94 MB/s，大概达到了链路极限(125MB/s)的75%，换成单个客户端就是6 MB/s。效率从80%降到了75%，是因为伴随着读取者的增加，多个读者从同一个chunkserver并发读数据的概率也随之变大。</p><p><img src="https://s2.loli.net/2022/06/06/lAnxpw1kJWTG8fS.png" alt="GFS3.PNG"></p><h3 id="6-1-2-Writes"><a href="#6-1-2-Writes" class="headerlink" title="6.1.2 Writes"></a>6.1.2 Writes</h3><p>N个客户端并行向N个不同的文件写数据。每个客户端以1MB的单个写操作总共向一个新文件写入1GB数据。总的写速率以及它的理论上的极限如图3(b)所示。极限值变成了67 MB/s,是因为我们需要将每个字节写入到16个chunkserver中的3个，每个具有12.5MB/s的输入连接。 单个客户端的写入速率是6.3 MB/s,大概是极限值的一半。主要原因是我们的网络协议栈。它不能充分利用我们用于chunk副本数据推送的流水线模式。将数据从一个副本传递到另一个副本的延迟降低了整体的写速率。 对于16个客户端，总体的写入速率达到了35 MB/s，平均每个客户端2.2 MB/s,大概是理论极限的一半。与写操作类似，伴随着写操作的增加，多个写操作从同一个chunkserver并发写数据的概率也随之变大。另外对于16个写操作比16个读者更容易产生碰撞，因为每个写操作将关联到3个不同的副本。 写操作比我们期望的要慢。在实际中，这还未变成一个主要问题，因为尽管它可能增加单个客户端的延时，但是当系统面对大量客户端时，其总的写入带宽并没有显著的影响。</p><h3 id="6-1-3-Record-Appends"><a href="#6-1-3-Record-Appends" class="headerlink" title="6.1.3 Record Appends"></a>6.1.3 Record Appends</h3><p>图3(c)展示了record append的性能。N个客户端向单个文件并行的append。性能取决于保存了该文件最后那个chunk的那些chunkserver，与客户端的数目无关。当只有一个客户端时，能达到6.0MB/s，当有16个客户端时就降到了4.8 MB/s。主要是由于拥塞以及不同的客户端的网络传输速率不同造成的。 我们的应用程序倾向于并行创建多个这样的文件。换句话说，N个客户端向M个共享文件并行append，在这里N和M通常是几十甚至几百大小。因此在我们的实验中出现的chunkserver的网络拥塞问题在实际中并不是一个显著的问题，因为当一个文件的chunkserver比较繁忙的时候，它可以去写另一个。</p><h3 id="6-2-Real-World-Clusters"><a href="#6-2-Real-World-Clusters" class="headerlink" title="6.2 Real World Clusters"></a>6.2 Real World Clusters</h3><p>我们选择在google内部使用的两个集群进行测试作为相似的那些集群的一个代表。集群A主要用于100多个工程的日常研发。它会从数TB的数据中读取数MB的数据，对这些数据进行转化或者分析，然后将结果再写回集群。集群B主要用于产品数据处理。它上面的任务持续时间更长，持续地在生成和处理数TB的数据集合，只是偶尔可能需要人为的参与。在这两种情况下，任务都是由分布在多个机器上的很多进程组成，它们并行的读写很多文件。</p><h3 id="6-2-1-Storage"><a href="#6-2-1-Storage" class="headerlink" title="6.2.1 Storage"></a>6.2.1 Storage</h3><p>正如表中前5个字段所展示的，两个集群都有数百个chunkserver，支持TB级的硬盘空间，空间已经被充分使用但还没全满。已用的空间包含chunk的所有副本。通常文件存在三个副本，因此这两个集群实际分别存储了18TB和52TB的数据。 这两个集群的文件数目很接近，尽管B集群有大量的死文件(那些已经被删除或者被新版本文件所替换但空间还没有被释放的文件)。而且它具有更多的trunk，因为它上面的文件通常更大。</p><p><img src="https://s2.loli.net/2022/06/06/n9thwjE5cGNMykq.png" alt="GFS4.PNG"></p><h3 id="6-2-2-Metadata"><a href="#6-2-2-Metadata" class="headerlink" title="6.2.2 Metadata"></a>6.2.2 Metadata</h3><p>所有的Chunkserver总共存储了数十G的元数据，大部分是用户数据的64kb块的校验和。Chunkserver上唯一的其他的元数据就是4.5节讨论的chunk的版本号。 保存在master上的元数据要更小一些，只有数十MB，平均下来每个文件只有100来个字节。这也刚好符合我们的master的内存不会成为实际中系统容量限制的假设。每个文件的元数据主要是以前缀压缩格式存储的文件名称。还有一些其他的元数据比如文件所有者，权限，文件到chunk的映射以及chunk的当前版本。另外对于每个chunk我们还存储了当前的副本位置以及用于实现写时复制的引用计数。 每个独立的server(chunkserver和master)只有50-100MB的元数据。因此，恢复是很快的：在server可以应答查询前只需要花几秒钟的时间就可以把它们从硬盘上读出来。然而，master的启动可能要慢一些，通常还需要30-60秒从所有的chunkserver获得chunk的位置信息。</p><h3 id="6-2-3-Read-and-Write-Rates"><a href="#6-2-3-Read-and-Write-Rates" class="headerlink" title="6.2.3 Read and Write Rates"></a>6.2.3 Read and Write Rates</h3><p>表3展示了不同时期的读写速率。进行这些测量时，两个集群都已经运行了大约一周(为了更新到最新版本的GFS，这两个集群被重启过)。 从启动开始看，平均写速率小于30MB/s。当我们进行这些测量时，集群B正在以100MB/s的速率进行密集的写操作，同时产生了300MB/s的网络负载，因为写操作将会传给3个副本。</p><p><img src="https://s2.loli.net/2022/06/06/1Ub28ilwzyvDKBH.png" alt="GFS5.PNG"></p><p><img src="https://s2.loli.net/2022/06/06/lAnxpw1kJWTG8fS.png" alt="GFS3.PNG"></p><p>读速率要远高于写速率。正如我们料想的那样，整个工作负载组成中，读要多于写。这两个集群都处在繁重的读活动中。尤其是，A已经在过去的一个星期中维持了580MB/s的读速率。它的网络配置可以支持750MB/s，因此它已经充分利用了资源。B集群可支持1300 MB/s的峰值读速率，但是应用只使用了380 MB/s。</p><h3 id="6-2-4-Master-Load"><a href="#6-2-4-Master-Load" class="headerlink" title="6.2.4 Master Load"></a>6.2.4 Master Load</h3><p>表3也表明发送给master的操作速率大概是每秒200-500个操作。Master可以轻易的处理这个级别的速率，因此对于这些工作负载来说，它不会成为瓶颈。 在早期版本的GFS中，master偶尔会成为某些工作负载的瓶颈。为了查找文件，花费大量的时间在巨大的目录(包含上千万的文件)中进行线性扫描。因此，我们改变了master的数据结构，使之可以在名字空间内进行有效的二分搜索。现在它可以简单的支持每秒上千次的文件访问。如果必要的话，我们可以通过在namespace数据结构前面放置名称查找缓存来进一步加快速度(If necessary, we could speed it up further by placing name lookup caches in front of the namespace data structures.)。</p><h3 id="6-2-5-Recovery-Time"><a href="#6-2-5-Recovery-Time" class="headerlink" title="6.2.5 Recovery Time"></a>6.2.5 Recovery Time</h3><p>一台Chunkserver失败后，它上面的那些chunk的副本数就会降低，必须进行clone以维持正常的副本数。恢复这些chunk的时间取决于资源的数量。在一个实验中，我们关闭集群B中的一个chunkserver。该chunkserver大概有15000个chunk，总共600GB的数据。为减少对于应用程序的影响以及为调度决策提供余地，我们的默认参数设置将集群的并发clone操作限制在91个(占chunkserver个数的40%),同时每个clone操作最多可以消耗6.25MB/s(50Mbps)。所有的chunk在23.2分钟内被恢复，备份速率是440MB/s。 在另一个实验中，我们关掉了两个chunkserver，每个具有16000个chunk，660GB的数据。这次失败使得266个chunk降低到了一个副本，但是两分钟内，它们就恢复到了至少2个副本，这样就让集群能够容忍另一个chunkserver发生失败，而不产生数据丢失。</p><h3 id="6-3-Workload-Breakdown"><a href="#6-3-Workload-Breakdown" class="headerlink" title="6.3 Workload Breakdown"></a>6.3 Workload Breakdown</h3><p><strong>工具负载解析</strong>。在这一节，我们将继续在两个新的集群上对工作负载进行细致的对比分析。集群X是用于研究开发的，集群Y是用于产品数据处理。</p><h3 id="6-3-1-Methodology-and-Caveats"><a href="#6-3-1-Methodology-and-Caveats" class="headerlink" title="6.3.1 Methodology and Caveats"></a>6.3.1 Methodology and Caveats</h3><p>这些结果只包含了客户端产生的请求，因此它们反映了应用程序的对整个文件系统的工作负载。并不包含为了执行客户端的请求进行的server间的请求，或者是内部的后台活动，比如写推送或者是重平衡。 对于IO操作的统计是从GFS的server的PRC请求日志中重新构建出来的。比如为了增加并行性，GFS客户端代码可能将一个读操作拆分为多个RPC请求，我们通过它们推断出原始请求。因为我们的访问模式高度的程式化，希望每个错误都可以出现在日志中。应用程序显式的记录可以提供更精确的数据，但是重新编译以及重启正在运行中的客户端在逻辑上是不可能这样做的。而且由于机器数很多，收集这些数据也会变得很笨重。 需要注意的是，不能将我们的工作负载过于泛化(generalize)。因为GFS和其应用程序是由google完全控制的，这些应用程序都是倾向于针对GFS进行专门调整，同时GFS也是专门为这些应用而设计的。这种相互的影响可能也存在于一般的文件系统及其应用程序中，但是在我们的案例中这种影响可能更加明显。</p><h3 id="6-3-2-Chunkserver-Workload"><a href="#6-3-2-Chunkserver-Workload" class="headerlink" title="6.3.2 Chunkserver Workload"></a>6.3.2 Chunkserver Workload</h3><p>表4按大小显示了操作的分布。读操作的大小表现出双峰分布，小型读操作(小于64kb)来自于那些在大量文件中查找小片数据的随机读客户端，大型读操作(超过512kb)来自于穿越整个文件的线性读操作。</p><p><img src="https://s2.loli.net/2022/06/06/LVK7RkFCmxiBut3.png" alt="GFS6.PNG"></p><p>集群Y中大量的读操作没有返回数据。我们应用程序，尤其是在产品系统中，经常使用文件作为生产者消费者队列。生产者并行的往文件中append数据，而消费者则从文件尾部读数据。有时候，如果消费者超过了生产者，就没有数据返回。集群X很少出现这种情况，因为它主要是用来进行短期数据分析，而不是长期的分布式应用。 写操作的大小也表现出双峰分布。大型的写操作(超过256KB)通常来自于写操作者的缓冲。那些缓冲更少数据的写操作者，检查点或者经常性的同步或者简单的数据生成组成了小型的写操作(低于64KB)。 对于记录的append，Y集群比X集群可以看到更大的大record append比率。因为使用Y集群的产品系统，针对GFS进行了更多的优化。 表5展示了不同大小的数据传输总量。对于各种操作来说，大型的操作(超过256KB)构成了大部分的数据传输。但是小型(低于64KB)的读操作虽然传输了比较少的数据但是在数据读中也占据了相当的一部分，主要是由于随机seek造成的。</p><p><img src="https://s2.loli.net/2022/06/06/M6ix1GB8FrlbPCN.png" alt="GFS7.PNG"></p><h3 id="6-3-3-Appends-versus-Writes"><a href="#6-3-3-Appends-versus-Writes" class="headerlink" title="6.3.3 Appends versus Writes"></a>6.3.3 Appends versus Writes</h3><p>记录append操作被大量的应用尤其是在我们的产品系统中。对于集群X来说，按字节传输来算，write与append的比例是108：1，根据操作数来算它们的比例是8：1。对于集群Y，比例变成了3.7：1和2.5：1。对于这两个集群来说，它们的append操作都要比write操作大一些｛操作数的比要远大于字节数的比，说明单个的append操作的字节数要大于write。对于集群X来说，在测量期间的记录append操作要低一些，这可能是由其中具有特殊缓冲大小设置的应用程序造成的。 正如期望的，我们的数据变更操作处于支配地位的是追加而不是重写(write也可能是追加)。我们测量了在主副本上的数据重写数量。对于集群X来说，以字节大小计算的话重写大概占了整个数据变更的0.0001%，以操作个数计算，大概小于0.0003%。对于Y集群来说，这两个数字都是0.05%，尽管这也不算大，但是还是要高于我们的期望。结果显示，大部分的重写是由于错误或者超时导致的客户端重写而产生的。它们并不是工作负载的一部分，而是属于重试机制。</p><h3 id="6-3-4-Master-Workload"><a href="#6-3-4-Master-Workload" class="headerlink" title="6.3.4 Master Workload"></a>6.3.4 Master Workload</h3><p>表6展示了对于master各种请求类型的剖析。大部分请求是为了得到chunk位置以及数据变更需要的租约持有信息。</p><p><img src="https://s2.loli.net/2022/06/06/udnqBh3bHeGojQU.png" alt="GFS8.PNG"></p><p>可以看到集群X和Y在delete请求上的限制区别，因为集群Y上存储的产品信息会周期性地生成被新版本数据所替换。这些不同被隐藏在open请求中，因为老版的数据在被写的时候的打开操作中被隐式的删除(类似与Unix的”w”打开模式)。 查找匹配文件是一个类似于ls的模式匹配请求。不像其他的请求，它可能需要处理很大部分的名字空间，因此可能是很昂贵的。在集群Y上可以更频繁地看到它，因为自动化的数据处理任务为了了解整个应用程序的状态可能需要检查文件系统中的某些部分。与此相比，集群X需要更多显式的用户控制而且已经提前知道所需要的文件的名称。</p><h2 id="7-Experiences"><a href="#7-Experiences" class="headerlink" title="7.Experiences"></a>7.Experiences</h2><p>在构建和部署GFS的过程中，我们总结出了很多经验，观点和技术。 起初，GFS只是考虑作为我们产品系统的后端文件系统。随着时间的推移，开始在研究和开发中使用。一开始它基本不支持像权限,磁盘配额(quota)这些东西，但是现在它们都已经有了。产品系统是很容易控制的，但是用户却不是。因此需要更多的设施来避免用户间的干扰。 我们最大的问题是硬盘和linux相关性。我们的很多硬盘声称支持各种IDE协议版本的linux驱动，但是实际上它们只能在最近的一些版本上才能可靠的工作。因此如果协议版本如果相差不大，硬盘大多数情况下都可以工作，但是有时候这种不一致会使得驱动和内核在硬盘状态上产生分歧。由于内核的问题，这将会导致数据被默默的污染。这个问题使得我们使用校验和来检测数据污染，如果出现这种情况，我们就需要修改内核来处理这种协议不一致的情况。 之前，由于linux2.2内核的fsync()的花费，我们也碰到过一些问题。它的花费是与文件大小而不是被修改部分的大小相关的。这对于我们大的操作日志会是一个问题，尤其是在我们实现检查点之前。我们通过改用同步写来绕过了这个问题，最后迁移到Linux2.4来解决了它。 另一个由于linux产生的问题是与读写锁相关的。在一个地址空间里的线程在从硬盘中读页数据(读锁)或者在mmap调用中修改地址空间(写锁)的时候，必须持有一个读写锁。在系统负载很高，产生资源瓶颈或者出现硬件失败时，我们碰到了瞬态的超时。最后，我们发现当磁盘读写线程处理前面映射的数据时，这个锁阻塞了网络线程将新的数据映射到内存。由于我们的工作瓶颈主要是在网络带宽而不是内存带宽，因此我们通过使用pread()加上额外的开销替代mmap()绕过了这个问题。 尽管出现了一些问题，linux代码的可用性帮助了我们探索和理解系统的行为。在适当的时机，我们也会改进内核并与开源社区共享这些变化。</p><h2 id="8-Related-work"><a href="#8-Related-work" class="headerlink" title="8.Related work"></a>8.Related work</h2><p>像其他的大型分布式文件系统比如AFS，GFS提供了一个本地的独立名字空间，使得数据可以为了容错或者负载平衡而透明的移动。但与AFS不同的是，为了提升整体的性能和容错能力，GFS将文件数据在多个存储服务器上存储，这点更类似于xFS或者Swift。 硬盘是相对便宜的，而且与复杂的RAID策略相比，副本策略更简单。由于GFS完全采用副本策略进行冗余因此它会比xFS或者Swift消耗更多的原始存储。 与AFS,xFS,Frangipani,Intermezzo这些系统相比，GFS在文件系统接口下并不提供任何缓存。我们的目标工作负载类型对于通常的单应用程序运行模式来说，基本上是不可重用的，因为这种模式通常需要读取大量数据集合或者在里面进行随机的seek，而每次只读少量的数据。 一些分布式文件系统比如xFS,Frangipani,Minnesota’s GFS和GPFS删除了中央服务节点，依赖于分布式的算法进行一致性和管理。我们选择中央化测量是为了简化设计增加可靠性，获取灵活性。尤其是，一个中央化的master更容易实现复杂的chunk放置和备份策略，因为master具有大部分的相关信息以及控制了它们的改变。我们通过让master状态很小以及在其他机器上进行备份来解决容错。当前通过影子master机制提供可扩展性和可用性。对于master状态的更新，通过append到write-ahead 日志里进行持久化。因此我们可以通过类似于Harp里的主copy模式来提供一个比我们当前模式具有更强一致性的高可用性。 我们未来将解决类似于Lustre的一个问题：大量客户端的整体性能。然而我们通过专注于我们自己的需求而不是构建一个POSIX兼容文件系统来简化了这个问题。另外，GFS加速不可靠组件的数量是很大的，因此容错是我们设计的中心。 GFS很类似于NASD架构。但是NASD是基于网络连接的硬盘驱动器，GFS则使用普通机器作为chunkserver。与NASD不同，chunkserver在需要时分配固定大小的chunk，而没有使用变长对象。此外，GFS还实现了诸如重平衡，副本，产品环境需要的快速恢复。 不像Minnesota’s GFS和NASD，我们并没有寻求改变存储设备的模型。我们更专注于解决使用现有商品化组件组成的复杂分布式系统的日常的数据处理需求。 通过在生产者消费者队列中使用原子record append操作解决了与分布式操作系统River的类似问题。River使用基于内存的跨机器分布式队列以及小心的数据流控制来解决这个问题，而GFS只使用了一个可以被很多生产者append数据的文件。River模型支持mton的分布式队列，但是缺乏容错，GFS目前只支持m to 1。多个消费者可以读取相同文件，但是它们必须协调好对输入负载进行划分(各自处理不相交的一部分)。</p><h2 id="9-Conclusions"><a href="#9-Conclusions" class="headerlink" title="9.Conclusions"></a>9.Conclusions</h2><p>GFS包含了那些在商品化硬件上支持大规模数据处理的必要特征。尽管某些设计决定与我们特殊的应用类型相关，但是可以应用在具有类似需求和特征的数据处理任务中。 针对我们当前的应用负载类型，我们重新审视传统的文件系统的一些假设。我们的审视，使得我们的设计中产生了一些与之根本不同的观点。我们将组件失败看做常态而不是异常，为经常进行的在大文件上的append进行优化，然后是读(通常是顺序的)，为了改进整个系统我们扩展并且放松了标准文件系统接口。 我们的系统通过监控，备份关键数据，快速和自动恢复来提供容错。Chunk备份使得我们可以容忍chunkserver的失败。这些经常性的失败，驱动了一个优雅的在线修复机制的产生，它周期性地透明的进行修复尽快的恢复那些丢失的副本。另外，我们通过使用校验和来检测数据损坏，当系统中硬盘数目很大的时候，这种损坏变得很正常。 我们的设计实现了对于很多执行大量任务的并发读者和写者的高吞吐率。通过从数据传输中分离文件系统控制，我们来实现这个目标，让master来处理文件系统控制，数据传输则直接在chunkserver和客户端之间进行。通过增大chunk的大小以及chunk的租约机制，降低了master在普通操作中的参与。这使中央的master不会成为瓶颈。我们相信在当前网络协议栈上的改进将会提供客户端写出速率的限制。 GFS成功地满足了我们的存储需求，同时除了作为产品数据处理平台外，还作为研发的存储平台而被广泛使用。它是一个使我们可以持续创新以及面对整个web的海量数据挑战的重要工具 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;GFS 中文翻译&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h2&gt;&lt;p&gt;我们已经设计和实现了Goo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MapReduce</title>
    <link href="https://codroc.github.io/2022/06/06/MapReduce/"/>
    <id>https://codroc.github.io/2022/06/06/MapReduce/</id>
    <published>2022-06-06T11:57:16.000Z</published>
    <updated>2022-06-06T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>MapReduce 中文翻译</strong></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>MapReduce是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先指定(创建?)一个Map函数处理一个基于key/value 对的数据集合，输出基于key/value 对的中间数据集合；然后再使用一个reduce函数用来合并上一步中间数据集合具有相同key值的中间value值。现实世界中有很多满足上述模型的例子，本论文将详细描述该模型。</p><p>以上诉mapreduce风格编写的的程序能够在大量的普通配置的计算机上实现并行化处理。这个系统在运行时只关心：如何分割输入数据，在由大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间必要的通信。采用MapReduce架构可以使那些没有并行计算和分布式处理系统开发经验的程序员有效利用分布式系统的丰富资源。</p><p>我们的MapReduce实现运行在规模可以灵活调整的由普通机器组成的集群上：一个典型的MapReduce计算往往由几千台机器组成、处理以TB计算的数据。程序员发现这个系统非常好用：已经实现了数以百计的MapReduce程序，在Google的集群上，每天都有1000多个MapReduce程序在执行。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>在过去的5年里，包括本文作者在内的Google的很多程序员，为了处理海量的原始数据，已经实现了数以百计的、专用的计算方法。这些计算方法用来处理大量的原始数据，比如，文档抓取（类似网络爬虫的程序）、Web请求日志等等；也为了计算处理各种类型的衍生数据，比如倒排索引、Web文档的图结构的各种表示形式、每台主机上网络爬虫抓取的页面数量的汇总、每天被请求的最多的查询的集合等等。大多数这样的数据处理运算在概念上很容易理解。然而由于输入的数据量巨大，因此要想在可接受的时间内完成运算，只有将这些计算分布在成百上千的主机上。如何处理并行计算、如何分发数据、如何处理错误？所有这些问题综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。</p><p>为了解决上述复杂的问题，我们设计一个新的抽象模型，使用这个抽象模型，我们只要表述我们想要执行的简单运算即可，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，这些问题都被封装在了一个库里面。设计这个抽象模型的灵感来自Lisp和许多其他函数式语言的<em>Map</em>和<em>Reduce</em>的原语。我们意识到我们大多数的运算都包含这样的操作：在输入数据的每个逻辑记录上应用Map操作得出一个中间key/value pair集合，然后在所有具有相同key值的value值上应用reduce操作，从而恰当的合并中间的数据。使用MapReduce模型，再结合用户实现的Map和Reduce函数，我们就可以非常容易的实现大规模并行化计算；通过MapReduce模型自带的“再次执行”（re-execution）功能，也提供了初级的容灾实现方案。</p><p>这个工作(实现一个MapReduce框架模型)的主要贡献是通过简单又强大的接口来实现自动并行化和大规模的分布式计算，通过使用MapReduce模型接口实现在以普通PC机为基础的大规模集群服务器上进行高性能计算。</p><p>section2描述了mapreduce的基础编程模型和一些使用案例。section3描述了一个经过裁剪的、适合我们的基于集群的计算环境的MapReduce实现。section4描述我们认为在MapReduce编程模型中一些实用的技巧。section5测量我们实现的MapReduce对于各种不同的任务的性能。section6揭示了在Google内部如何使用MapReduce作为基础重写我们的索引系统产品，包括其它一些使用MapReduce的经验。section7讨论相关的和未来的工作。</p><h2 id="2-Programming-Model"><a href="#2-Programming-Model" class="headerlink" title="2 Programming Model"></a>2 Programming Model</h2><p>MapReduce编程模型的原理是：利用一个输入key/value pair集合来产生一个输出的key/value pair集合。MapReduce库的用户用两个函数表达这个计算：<strong>Map和Reduce</strong>。</p><p>用户自定义的<em>Map</em>函数接受一个key/value pair的输入值，然后产生一个中间key/value pair值的集合。MapReduce库把所有具有相同中间key值<em>I</em>的中间value值集合在一起后传递给<em>reduce</em>函数。</p><p>用户自定义的Reduce函数接受一个中间key的值<em>I</em>和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小的value值的集合。通常来说，每次Reduce函数调用只产生0或1个输出value值。通常我们通过一个迭代器把中间value值提供给Reduce函数，这样我们就可以处理无法全部放入内存中的大量的value值的集合(迭代器可看为一个容器,所以数据放入一个容器中，reduce函数就从这个容器中取数据即可)。</p><h2 id="2-1-Example"><a href="#2-1-Example" class="headerlink" title="2.1 Example"></a>2.1 Example</h2><p>思考一个问题：计算一个大的文档集合中每个单词出现的次数，程序可能会写出类似下面的伪代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line"> // key: document name</span><br><span class="line"> // value: document contents </span><br><span class="line">for each word w in value:</span><br><span class="line">  EmitIntermediate(w, “1″); </span><br><span class="line">reduce(String key, Iterator values): </span><br><span class="line">// key: a word </span><br><span class="line">// values: a list of counts </span><br><span class="line">int result = 0; </span><br><span class="line">for each v in values: </span><br><span class="line">  result += ParseInt(v); </span><br><span class="line">Emit(AsString(result));map函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是1)。reduce函数把Map函数产生的每一个特定的词的计数累加起来。</span><br></pre></td></tr></table></figure><p>另外，用户编写代码，使用输入和输出文件的名字、可选的调节参数来完成一个符合MapReduce模型规范的对象，然后调用MapReduce函数，并把这个规范对象传递给它。用户的代码和MapReduce库链接在一起(用C++实现)。附录A包含了这个实例的全部程序代码。</p><h2 id="2-2-Type"><a href="#2-2-Type" class="headerlink" title="2.2 Type"></a>2.2 Type</h2><p>尽管在前面例子的伪代码中使用了以字符串表示的输入输出值，但是在概念上，用户定义的Map和Reduce函数都有相关联的类型：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map     (k1,v1)       -&gt;list(k2,v2) </span><br><span class="line">reduce  (k2,list(v2)) -&gt;list(v2)</span><br></pre></td></tr></table></figure><p>比如，输入的key和value值与输出的key和value值在类型推导的域不同。此外，中间key和value值与输出key和value值在类型上推导的域相同。(原文中这个domain的含义不是很清楚，我参考Hadoop、KFS等实现，map和reduce都使用了泛型，因此，我把domain翻译成类型推导的域)。</p><p>我们的C++中使用字符串类型作为用户自定义函数的输入输出，用户在自己的代码中对字符串进行适当的类型转换。</p><h2 id="2-3-More-Examples"><a href="#2-3-More-Examples" class="headerlink" title="2.3 More Examples"></a>2.3 More Examples</h2><p>这里还有一些有趣的简单例子，可以很容易的使用MapReduce模型来表示：</p><p><strong>分布式的Grep</strong>：Map函数输出匹配某个模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。</p><p><strong>计算URL访问频率</strong>：Map函数处理日志中web页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。</p><p><strong>倒转网络链接图</strong>：Map函数在源页面（source）中搜索所有的链接目标（target）并输出为(target,source)。Reduce函数把给定链接目标（target）的链接组合成一个列表，输出(target,list(source))。</p><p><strong>每个主机的检索词向量</strong>：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。Map函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的URL。Reduce函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主机名,检索词向量)。</p><p><strong>倒排索引</strong>：Map函数分析每个文档输出一个(词,文档号)的列表，Reduce函数的输入是一个给定词的所有（词，文档号），排序所有的文档号，输出(词,list（文档号）)。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。</p><p><strong>分布式排序</strong>：Map函数从每个记录提取key，输出(key,record)。Reduce函数不改变任何的值。这个运算依赖分区机制(在4.1描述)和排序属性(在4.2描述)。</p><h2 id="3-Implementation"><a href="#3-Implementation" class="headerlink" title="3 Implementation"></a>3 Implementation</h2><p>MapReduce模型可以有多种不同的实现方式。如何正确选择取决于具体的环境。例如，一种实现方式适用于小型的共享内存方式的机器，另外一种实现方式则适用于大型NUMA架构的多处理器的主机，而有的实现方式更适合大型的网络连接集群。</p><p>本章节描述一个适用于Google内部广泛使用的运算环境的实现：用以太网交换机连接、由普通PC机组成的大型集群。在我们的环境里包括：</p><ol><li>x86架构、运行Linux操作系统、双处理器、2-4GB内存的机器。</li><li>普通的网络硬件设备，每个机器的带宽为百兆或者千兆，但是远小于网络的平均带宽的一半。</li><li>集群中包含成百上千的机器，因此，机器故障是常态。</li><li>存储为廉价的内置IDE硬盘。一个内部分布式文件系统用来管理存储在这些磁盘上的数据。文件系统通过数据复制来在不可靠的硬件上保证数据的可靠性和有效性。</li><li>用户提交工作（job）给调度系统。每个工作（job）都包含一系列的任务（task），调度系统将这些任务调度到集群中多台可用的机器上。</li></ol><h2 id="3-1-Execution-Overview"><a href="#3-1-Execution-Overview" class="headerlink" title="3.1 Execution Overview"></a>3.1 Execution Overview</h2><p>通过将Map调用的输入数据自动分割为M个数据片段的集合，Map调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使用分区函数将Map调用产生的中间key值分成R个不同分区（例如，hash(key) mod R），Reduce调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。</p><p><img src="https://s2.loli.net/2022/06/06/rLXqMlZ5TawdYKm.png" alt="MapReduce0.PNG"></p><p>图1展示了我们的MapReduce实现中操作的全部流程。当用户调用MapReduce函数时，将发生下面的一系列动作（下面的序号和图1中的序号一一对应）：</p><p>1.用户程序首先调用的MapReduce库将输入文件分成M个数据片度，每个数据片段的大小一般从 16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量的程序副本。</p><p>2.这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是worker程序，由master分配任务。有M个Map任务和R个Reduce任务将被分配，master将一个Map任务或Reduce任务分配给一个空闲的worker。</p><p>3.被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key/value pair，然后把key/value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key/value pair，并缓存在内存中。</p><p>4.缓存中的key/value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key/value pair在本地磁盘上的存储位置将被回传给master，由master负责把这些存储位置再传送给Reduce worker。</p><p>5.当Reduce worker程序接收到master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</p><p>6.Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。</p><p>7.当所有的Map和Reduce任务都完成之后，master唤醒用户程序。在这个时候，在用户程序里的对MapReduce调用才返回。</p><p>在成功完成任务之后，MapReduce的输出存放在R个输出文件中（对应每个Reduce任务产生一个输出文件，文件名由用户指定）。一般情况下，用户不需要将这R个输出文件合并成一个文件–他们经常把这些文件作为另外一个MapReduce的输入，或者在另外一个可以处理多个分割文件的分布式应用中使用。</p><h2 id="3-2-Master-Data-Structures"><a href="#3-2-Master-Data-Structures" class="headerlink" title="3.2 Master Data Structures"></a>3.2 Master Data Structures</h2><p>Master持有一些数据结构，它存储每一个Map和Reduce任务的状态（空闲、工作中或完成)，以及Worker机器(非空闲任务的机器)的标识。</p><p>Master就像一个数据管道，中间文件存储区域的位置信息通过这个管道从Map传递到Reduce。因此，对于每个已经完成的Map任务，master存储了Map任务产生的R个中间文件存储区域的大小和位置。当Map任务完成时，Master接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的Reduce任务。</p><h2 id="3-3-Fault-Tolerance"><a href="#3-3-Fault-Tolerance" class="headerlink" title="3.3 Fault Tolerance"></a>3.3 Fault Tolerance</h2><p>因为MapReduce库的设计初衷是使用由成百上千的机器组成的集群来处理超大规模的数据，所以，这个库必须要能很好的处理机器故障。</p><h3 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h3><p>master周期性的ping每个worker。如果在一个约定的时间范围内没有收到worker返回的信息，master将把这个worker标记为失效。所有由这个失效的worker完成的Map任务被重设为初始的空闲状态，之后这些任务就可以被安排给其他的worker。同样的，worker失效时正在运行的Map或Reduce任务也将被重新置为空闲状态，等待重新调度。</p><p>当worker故障时，由于已经完成的Map任务的输出存储在这台机器上，Map任务的输出已不可访问了，因此必须重新执行。而已经完成的Reduce任务的输出存储在全局文件系统上，因此不需要再次执行。</p><p>当一个Map任务首先被worker A执行，之后由于worker A失效了又被调度到worker B执行，这个“重新执行”的动作会被通知给所有执行Reduce任务的worker。任何还没有从worker A读取数据的Reduce任务将从worker B读取数据。</p><p>MapReduce可以处理大规模worker失效的情况。比如，在一个MapReduce操作执行期间，在正在运行的集群上进行网络维护引起80台机器在几分钟内不可访问了，MapReduce master只需要简单的再次执行那些不可访问的worker完成的工作，之后继续执行未完成的任务，直到最终完成这个MapReduce操作。</p><h3 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h3><p>一个简单的解决办法是让master周期性的将上面描述的数据结构（指3.2节）写入磁盘，即检查点（checkpoint）。如果这个master任务失效了，可以从最后一个检查点（checkpoint）开始启动另一个master进程。然而，由于只有一个master进程，master失效后再恢复是比较麻烦的，因此我们现在的实现是如果master失效，就中止MapReduce运算。客户可以检查到这个状态，并且可以根据需要重新执行MapReduce操作。</p><h3 id="Semantics-in-the-Presence-of-Failures"><a href="#Semantics-in-the-Presence-of-Failures" class="headerlink" title="Semantics in the Presence of Failures"></a>Semantics in the Presence of Failures</h3><p>出现故障时的语义?故障时处理的机制?</p><p>当用户提供的Map和Reduce操作是输入确定性函数（即相同的输入产生相同的输出）时，我们的分布式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。</p><p>我们依赖对Map和Reduce任务的输出是原子提交的来完成这个特性。每个工作中的任务把它的输出写到私有的临时文件中。每个Reduce任务生成一个这样的文件，而每个Map任务则生成R个这样的文件（一个Reduce任务对应一个文件）。当一个Map任务完成的时，worker发送一个包含R个临时文件名的完成消息给master。如果master从一个已经完成的Map任务再次接收到到一个完成消息，master将忽略这个消息；否则，master将这R个文件的名字记录在数据结构里。</p><p>当Reduce任务完成时，Reduce worker进程以原子的方式把临时文件重命名为最终的输出文件。如果同一个Reduce任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名操作执行。我们依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个Reduce任务产生的数据。</p><p>使用MapReduce模型的程序员可以很容易的理解他们程序的行为，因为我们绝大多数的Map和Reduce操作是确定性的，而且存在这样的一个事实：我们的失效处理机制等价于一个顺序的执行的操作。当Map或/和Reduce操作是不确定性的时候，我们提供虽然较弱但是依然合理的处理机制。当使用非确定操作的时候，一个Reduce任务R1的输出等价于一个非确定性程序顺序执行产生时的输出。但是，另一个Reduce任务R2的输出也许符合一个不同的非确定顺序程序执行产生的R2的输出。</p><p>考虑Map任务M和Reduce任务R1、R2的情况。我们设定e(Ri)是Ri已经提交的执行过程（有且仅有一个这样的执行过程）。当e(R1)读取了由M一次执行产生的输出，而e(R2)读取了由M的另一次执行产生的输出，导致了较弱的失效处理。</p><h2 id="3-4-Locality-存储位置"><a href="#3-4-Locality-存储位置" class="headerlink" title="3.4 Locality(存储位置)"></a>3.4 Locality(存储位置)</h2><p>在我们的计算运行环境中，网络带宽是一个相当匮乏的资源。我们通过尽量把输入数据(由GFS管理)存储在集群中机器的本地磁盘上来节省网络带宽。GFS把每个文件按64MB一个Block分隔，每个Block保存在多台机器上，环境中就存放了多份拷贝(一般是3个拷贝)。MapReduce的master在调度Map任务时会考虑输入文件的位置信息，尽量将一个Map任务调度在包含相关输入数据拷贝的机器上执行；如果上述努力失败了，master将尝试在保存有输入数据拷贝的机器附近的机器上执行Map任务(例如，分配到一个和包含输入数据的机器在一个switch里的worker机器上执行)。当在一个足够大的cluster集群上运行大型MapReduce操作的时候，大部分的输入数据都能从本地机器读取，因此消耗非常少的网络带宽。</p><h2 id="3-5-Task-Granularity"><a href="#3-5-Task-Granularity" class="headerlink" title="3.5 Task Granularity"></a>3.5 Task Granularity</h2><p>任务粒度，如前所述，我们把Map拆分成了M个片段、把Reduce拆分成R个片段执行。理想情况下，M和R应当比集群中worker的机器数量要多得多。在每台worker机器都执行大量的不同任务能够提高集群的动态的负载均衡能力，并且能够加快故障恢复的速度：失效机器上执行的大量Map任务都可以分布到所有其他的worker机器上去执行。</p><p>但是实际上，在我们的具体实现中对M和R的取值都有一定的客观限制，因为master必须执行O(M+R)次调度，并且在内存中保存O(M<em>R)个状态（对影响内存使用的因素还是比较小的：O(M</em>R)块状态，大概每对Map任务/Reduce任务1个字节就可以了）。</p><p>更进一步，R值通常是由用户指定的，因为每个Reduce任务最终都会生成一个独立的输出文件。实际使用时我们也倾向于选择合适的M值，以使得每一个独立任务都是处理大约16M到64M的输入数据（这样，上面描写的输入数据本地存储优化策略才最有效），另外，我们把R值设置为我们想使用的worker机器数量的小的倍数。我们通常会用这样的比例来执行MapReduce：M=200000，R=5000，使用2000台worker机器。</p><h2 id="3-6-Backup-Tasks"><a href="#3-6-Backup-Tasks" class="headerlink" title="3.6 Backup Tasks"></a>3.6 Backup Tasks</h2><p>任务备份，影响一个MapReduce的总执行时间最通常的因素是“落伍者”：在运算过程中，如果有一台机器花了很长的时间才完成最后几个Map或Reduce任务，导致MapReduce操作总的执行时间超过预期。出现“落伍者”的原因非常多。比如：如果一个机器的硬盘出了问题，在读取的时候要经常的进行读取纠错操作，导致读取数据的速度从30M/s降低到1M/s。如果cluster的调度系统在这台机器上又调度了其他的任务，由于CPU、内存、本地硬盘和网络带宽等竞争因素的存在，导致执行MapReduce代码的执行效率更加缓慢。我们最近遇到的一个问题是由于机器的初始化代码有bug，导致关闭了的处理器的缓存：在这些机器上执行任务的性能和正常情况相差上百倍。</p><p>我们有一个通用的机制来减少“落伍者”出现的情况。当一个MapReduce操作接近完成的时候，master调度备用（backup）任务进程来执行剩下的、处于处理中状态（in-progress）的任务。无论是最初的执行进程、还是备用（backup）任务进程完成了任务，我们都把这个任务标记成为已经完成。我们调优了这个机制，通常只会占用比正常操作多几个百分点的计算资源。我们发现采用这样的机制对于减少超大MapReduce操作的总处理时间效果显著。例如，在5.3节描述的排序任务，在关闭掉备用任务的情况下要多花44%的时间完成排序任务。</p><h2 id="4-Refinements"><a href="#4-Refinements" class="headerlink" title="4 Refinements"></a>4 Refinements</h2><p>虽然简单的Map和Reduce函数提供的基本功能已经能够满足大部分的计算需要，我们还是发掘出了一些有价值的扩展功能。本节将描述这些扩展功能。</p><h2 id="4-1-Partitioning-Function"><a href="#4-1-Partitioning-Function" class="headerlink" title="4.1 Partitioning Function"></a>4.1 Partitioning Function</h2><p>MapReduce的使用者通常会指定Reduce任务和Reduce任务输出文件的数量（R）。我们在中间key上使用分区函数来对数据进行分区，之后再输入到后续任务执行进程。一个默认的分区函数是使用hash方法(比如，hash(key) mod R)进行分区。hash方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对key值进行的分区将非常有用。比如，输出的key值是URLs，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce库的用户需要提供专门的分区函数。例如，使用“hash(Hostname(urlkey)) mod R”作为分区函数就可以把所有来自同一个主机的URLs保存在同一个输出文件中。</p><h2 id="4-2-Ordering-Guarantees"><a href="#4-2-Ordering-Guarantees" class="headerlink" title="4.2 Ordering Guarantees"></a>4.2 Ordering Guarantees</h2><p>我们确保在给定的分区中，中间key/value pair数据的处理顺序是按照key值增量顺序处理的。这样的顺序保证对每个分成生成一个有序的输出文件，这对于需要对输出文件按key值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。</p><h2 id="4-3-Combiner-Function"><a href="#4-3-Combiner-Function" class="headerlink" title="4.3 Combiner Function"></a>4.3 Combiner Function</h2><p>在某些情况下，Map函数产生的中间key值的重复数据会占很大的比重，并且，用户自定义的Reduce函数满足结合律和交换律。在2.1节的词数统计程序是个很好的例子。由于词频率倾向于一个zipf分布(齐夫分布)，每个Map任务将产生成千上万个这样的记录&lt;the,1&gt;.所有的这些记录将通过网络被发送到一个单独的Reduce任务，然后由这个Reduce任务把所有这些记录累加起来产生一个数字。我们允许用户指定一个可选的combiner函数，combiner函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。</p><p>Combiner函数在每台执行Map任务的机器上都会被执行一次。一般情况下，Combiner和Reduce函数是一样的。Combiner函数和Reduce函数之间唯一的区别是MapReduce库怎样控制函数的输出。Reduce函数的输出被保存在最终的输出文件里，而Combiner函数的输出被写到中间文件里，然后被发送给Reduce任务。</p><p>部分的合并中间结果可以显著的提高一些MapReduce操作的速度。附录A包含一个使用combiner函数的例子。</p><h2 id="4-4-Input-and-Output-Types"><a href="#4-4-Input-and-Output-Types" class="headerlink" title="4.4 Input and Output Types"></a>4.4 Input and Output Types</h2><p>MapReduce库支持几种不同的格式的输入数据。比如，文本模式的输入数据的每一行被视为是一个key/value pair。key是文件的偏移量，value是那一行的内容。另外一种常见的格式是以key进行排序来存储的key/value pair的序列。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单独的Map任务来进行后续处理(例如，文本模式的范围分割必须确保仅仅在每行的边界进行范围分割)。虽然大多数MapReduce的使用者仅仅使用很少的预定义输入类型就满足要求了，但是使用者依然可以通过提供一个简单的<em>Reader</em>接口实现就能够支持一个新的输入类型。</p><p><em>Reader</em>并非一定要从文件中读取数据，比如，我们可以很容易的实现一个从数据库里读记录的Reader，或者从内存中的数据结构读取数据的Reader。</p><p>类似的，我们提供了一些预定义的输出数据的类型，通过这些预定义类型能够产生不同格式的数据。用户采用类似添加新的输入数据类型的方式增加新的输出类型。</p><h2 id="4-5-Side-effects"><a href="#4-5-Side-effects" class="headerlink" title="4.5 Side-effects"></a>4.5 Side-effects</h2><p>在某些情况下，MapReduce的使用者发现，如果在Map和/或Reduce操作过程中增加辅助的输出文件会比较省事。我们依靠程序writer把这种“副作用”变成原子的和幂等的（幂等的指一个总是产生相同结果的数学运算）。通常应用程序首先把输出结果写到一个临时文件中，在输出全部数据之后，在使用系统级的原子操作rename重新命名这个临时文件。</p><p>如果一个任务产生了多个输出文件，我们没有提供类似两阶段提交的原子操作支持这种情况。因此，对于会产生多个输出文件、并且对于跨文件有一致性要求的任务，都必须是确定性的任务。但是在实际应用过程中，这个限制还没有给我们带来过麻烦。</p><h2 id="4-6-Skipping-Bad-Records"><a href="#4-6-Skipping-Bad-Records" class="headerlink" title="4.6 Skipping Bad Records"></a>4.6 Skipping Bad Records</h2><p>有时候，用户程序中的bug导致Map或者Reduce函数在处理某些记录的时候crash掉，MapReduce操作无法顺利完成。惯常的做法是修复bug后再次执行MapReduce操作，但是，有时候找出这些bug并修复它们不是一件容易的事情；这些bug也许是在第三方库里边，而我们手头没有这些库的源代码。而且在很多时候，忽略一些有问题的记录也是可以接受的，比如在一个巨大的数据集上进行统计分析的时候。我们提供了一种执行模式，在这种模式下，为了保证保证整个处理能继续进行，MapReduce会检测哪些记录导致确定性的crash，并且跳过这些记录不处理。</p><p>每个worker进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus error）。在执行Map或者Reduce操作之前，MapReduce库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，消息处理函数将用“最后一口气”通过UDP包向master发送处理的最后一条记录的序号。当master看到在处理某条特定记录不止失败一次时，master就标志着条记录需要被跳过，并且在下次重新执行相关的Map或者Reduce任务的时候跳过这条记录。</p><h2 id="4-7-Local-Execution"><a href="#4-7-Local-Execution" class="headerlink" title="4.7 Local Execution"></a>4.7 Local Execution</h2><p>调试Map和Reduce函数的bug是非常困难的，因为实际执行操作时不但是分布在系统中执行的，而且通常是在好几千台计算机上执行，具体的执行位置是由master进行动态调度的，这又大大增加了调试的难度。为了简化调试、profile和小规模测试，我们开发了一套MapReduce库的本地实现版本，通过使用本地版本的MapReduce库，MapReduce操作在本地计算机上顺序的执行。用户可以控制MapReduce操作的执行，可以把操作限制到特定的Map任务上。用户通过设定特别的标志来在本地执行他们的程序，之后就可以很容易的使用本地调试和测试工具（比如gdb）。</p><h2 id="4-8-Stauts-Information"><a href="#4-8-Stauts-Information" class="headerlink" title="4.8 Stauts Information"></a>4.8 Stauts Information</h2><p>master使用嵌入式的HTTP服务器（如Jetty）显示一组状态信息页面，用户可以监控各种执行状态。状态信息页面显示了包括计算执行的进度，比如已经完成了多少任务、有多少任务正在处理、输入的字节数、中间数据的字节数、输出的字节数、处理百分比等等。页面还包含了指向每个任务的stderr和stdout文件的链接。用户根据这些数据预测计算需要执行大约多长时间、是否需要增加额外的计算资源。这些页面也可以用来分析什么时候计算执行的比预期的要慢。</p><p>另外，处于最顶层的状态页面显示了哪些worker失效了，以及他们失效的时候正在运行的Map和Reduce任务。这些信息对于调试用户代码中的bug很有帮助。</p><h2 id="4-9-Counters"><a href="#4-9-Counters" class="headerlink" title="4.9 Counters"></a>4.9 Counters</h2><p>MapReduce库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇German文档等等。</p><p>为了使用这个特性，用户在程序中创建一个命名的计数器对象，在Map和Reduce函数中相应的增加计数器的值。例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Counter* uppercase; </span><br><span class="line">uppercase = GetCounter(“uppercase”); </span><br><span class="line">map(String name, String contents): </span><br><span class="line">  for each word w in contents: </span><br><span class="line">     if (IsCapitalized(w)):</span><br><span class="line">        uppercase-&gt;Increment(); </span><br><span class="line">     EmitIntermediate(w, “1″);</span><br></pre></td></tr></table></figure><p>这些计数器的值周期性的从各个单独的worker机器上传递给master（附加在ping的应答包中传递）。master把执行成功的Map和Reduce任务的计数器值进行累计，当MapReduce操作完成之后，返回给用户代码。计数器当前的值也会显示在master的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器的值的时候，master要检查重复运行的Map或者Reduce任务，避免重复累加（之前提到的备用任务和失效后重新执行任务这两种情况会导致相同的任务被多次执行）。</p><p>有些计数器的值是由MapReduce库自动维持的，比如已经处理的输入的key/value pair的数量、输出的key/value pair的数量等等。</p><p>用户发现计数器机制对于MapReduce操作的完整性检查非常有用。比如，在某些MapReduce操作中，用户需要确保输出的key value pair精确的等于输入的key value pair，或者处理的German文档数量在处理的整个文档数量中属于合理范围。</p><h2 id="5-Performance"><a href="#5-Performance" class="headerlink" title="5 Performance"></a>5 Performance</h2><p>本节我们用在一个大型集群上运行的两个计算来衡量MapReduce的性能。一个计算在大约1TB的数据中进行特定的模式匹配，另一个计算对大约1TB的数据进行排序。</p><p>这两个程序在大量的使用MapReduce的实际应用中是非常典型的 — 一类是对数据格式进行转换，从一种表现形式转换为另外一种表现形式；另一类是从海量数据中抽取少部分的用户感兴趣的数据。</p><h2 id="5-1-Cluster-Configuration"><a href="#5-1-Cluster-Configuration" class="headerlink" title="5.1 Cluster Configuration"></a>5.1 Cluster Configuration</h2><p>所有这些程序都运行在一个大约由1800台机器构成的集群上。每台机器配置2个2G主频、支持超线程的Intel Xeon处理器，4GB的物理内存，两个160GB的IDE硬盘和一个千兆以太网卡。这些机器部署在一个两层的树形交换网络中，在root节点大概有100-200GBPS的传输带宽。所有这些机器都采用相同的部署（对等部署），因此任意两点之间的网络来回时间小于1毫秒。</p><p>在4GB内存里，大概有1-1.5G用于运行在集群上的其他任务。测试程序在周末下午开始执行，这时主机的CPU、磁盘和网络基本上处于空闲状态。</p><h2 id="5-2-Grep"><a href="#5-2-Grep" class="headerlink" title="5.2 Grep"></a>5.2 Grep</h2><p>这个分布式的grep程序需要扫描大概10的10次方个由100个字节组成的记录，查找出现概率较小的3个字符的模式（这个模式在92337个记录中出现）。输入数据被拆分成大约64M的Block（M=15000），整个输出数据存放在一个文件中（R=1）。</p><p>figure2显示了这个运算随时间的处理过程。其中Y轴表示输入数据的处理速度。处理速度随着参与MapReduce计算的机器数量的增加而增加，当1764台worker参与计算的时，处理速度达到了30GB/s。当Map任务结束的时候，即在计算开始后80秒，输入的处理速度降到0。整个计算过程从开始到结束一共花了大概150秒。这包括了大约一分钟的初始启动阶段。初始启动阶段消耗的时间包括了是把这个程序传送到各个worker机器上的时间、等待GFS文件系统打开1000个输入文件集合的时间、获取相关的文件本地位置优化信息的时间。</p><p><img src="https://s2.loli.net/2022/06/06/RSOAWZH8ULpYfiB.png" alt="MapReduce1.PNG"></p><h2 id="5-3-Sort"><a href="#5-3-Sort" class="headerlink" title="5.3 Sort"></a>5.3 Sort</h2><p>排序程序处理10的10次方个100个字节组成的记录（大概1TB的数据）。这个程序模仿TeraSort benchmark[10]。</p><p>排序程序由不到50行代码组成。只有三行的Map函数从文本行中解析出10个字节的key值作为排序的key，并且把这个key和原始文本行作为中间的key/value pair值输出。我们使用了一个内置的恒等函数作为Reduce操作函数。这个函数把中间的key/value pair值不作任何改变输出。最终排序结果输出到两路复制的GFS文件系统（也就是说，程序输出2TB的数据）。</p><p>如前所述，输入数据被分成64MB的Block（M=15000）。我们把排序后的输出结果分区后存储到4000个文件（R=4000）。分区函数使用key的原始字节来把数据分区到R个片段中。</p><p>在这个benchmark测试中，我们使用的分区函数知道key的分区情况。通常对于排序程序来说，我们会增加一个预处理的MapReduce操作用于采样key值的分布情况，通过采样的数据来计算对最终排序处理的分区点。</p><p><img src="https://s2.loli.net/2022/06/06/Q9kjHszPTMl5gYI.png" alt="MapReduce2.PNG"></p><p>图三（a）显示了这个排序程序的正常执行过程。左上的图显示了输入数据读取的速度。数据读取速度峰值会达到13GB/s，并且所有Map任务完成之后，即大约200秒之后迅速滑落到0。值得注意的是，排序程序输入数据读取速度小于分布式grep程序。这是因为排序程序的Map任务花了大约一半的处理时间和I/O带宽把中间输出结果写到本地硬盘。相应的分布式grep程序的中间结果输出几乎可以忽略不计。</p><p>左边中间的图显示了中间数据从Map任务发送到Reduce任务的网络速度。这个过程从第一个Map任务完成之后就开始缓慢启动了。图示的第一个高峰是启动了第一批大概1700个Reduce任务（整个MapReduce分布到大概1700台机器上，每台机器1次最多执行1个Reduce任务）。排序程序运行大约300秒后，第一批启动的Reduce任务有些完成了，我们开始执行剩下的Reduce任务。所有的处理在大约600秒后结束。</p><p>左下图表示Reduce任务把排序后的数据写到最终的输出文件的速度。在第一个排序阶段结束和数据开始写入磁盘之间有一个小的延时，这是因为worker机器正在忙于排序中间数据。磁盘写入速度在2-4GB/s持续一段时间。输出数据写入磁盘大约持续850秒。计入初始启动部分的时间，整个运算消耗了891秒。这个速度和TeraSort benchmark[18]的最高纪录1057秒相差不多。</p><p>还有一些值得注意的现象：输入数据的读取速度比排序速度和输出数据写入磁盘速度要高不少，这是因为我们的输入数据本地化优化策略起了作用 — 绝大部分数据都是从本地硬盘读取的，从而节省了网络带宽。排序速度比输出数据写入到磁盘的速度快，这是因为输出数据写了两份（我们使用了2路的GFS文件系统，写入复制节点的原因是为了保证数据可靠性和可用性）。我们把输出数据写入到两个复制节点的原因是因为这是底层文件系统的保证数据可靠性和可用性的实现机制。如果底层文件系统使用类似容错编码[14](erasure coding)的方式而不是复制的方式保证数据的可靠性和可用性，那么在输出数据写入磁盘的时候，就可以降低网络带宽的使用。</p><h2 id="5-4-Effect-of-Backup-Task"><a href="#5-4-Effect-of-Backup-Task" class="headerlink" title="5.4 Effect of Backup Task"></a>5.4 Effect of Backup Task</h2><p>图三（b）显示了关闭了备用任务后排序程序执行情况。执行的过程和图3（a）很相似，除了输出数据写磁盘的动作在时间上拖了一个很长的尾巴，而且在这段时间里，几乎没有什么写入动作。在960秒后，只有5个Reduce任务没有完成。这些拖后腿的任务又执行了300秒才完成。整个计算消耗了1283秒，多了44%的执行时间。</p><h2 id="5-5-Machine-Failures"><a href="#5-5-Machine-Failures" class="headerlink" title="5.5 Machine Failures"></a>5.5 Machine Failures</h2><p>在图三（c）中演示的排序程序执行的过程中，我们在程序开始后几分钟有意的kill了1746个worker中的200个。集群底层的调度立刻在这些机器上重新开始新的worker处理进程（因为只是worker机器上的处理进程被kill了，机器本身还在工作）。</p><p>图三（c）显示出了一个“负”的输入数据读取速度，这是因为一些已经完成的Map任务丢失了（由于相应的执行Map任务的worker进程被kill了），需要重新执行这些任务。相关Map任务很快就被重新执行了。整个运算在933秒内完成，包括了初始启动时间（只比正常执行多消耗了5%的时间）。</p><h2 id="6-Experience"><a href="#6-Experience" class="headerlink" title="6 Experience"></a>6 Experience</h2><p>我们在2003年1月完成了第一个版本的MapReduce库，在2003年8月的版本有了显著的增强，这包括了输入数据本地优化、worker机器之间的动态负载均衡等等。从那以后，我们惊喜的发现，MapReduce库能广泛应用于我们日常工作中遇到的各类问题。它现在在Google内部各个领域得到广泛应用，包括：</p><p>1.大规模机器学习问题</p><p>2.Google News和Froogle产品的集群问题</p><p>3.从公众查询产品（比如Google的Zeitgeist）的报告中抽取数据。</p><p>4.从大量的新应用和新产品的网页中提取有用信息（比如，从大量的位置搜索网页中抽取地理位置信息）。</p><p>5.大规模的图形计算。</p><p><img src="https://s2.loli.net/2022/06/06/PYsAhDtLWGZaMkw.png" alt="MapReduce3.PNG"></p><p>图四显示了在我们的源代码管理系统中，随着时间推移，独立的MapReduce程序数量的显著增加。从2003年早些时候的0个增长到2004年9月份的差不多900个不同的程序。MapReduce的成功取决于采用MapReduce库能够在不到半个小时时间内写出一个简单的程序，这个简单的程序能够在上千台机器的组成的集群上做大规模并发处理，这极大的加快了开发和原形设计的周期。另外，采用MapReduce库，可以让完全没有分布式和/或并行系统开发经验的程序员很容易的利用大量的资源，开发出分布式和/或并行处理的应用。</p><p>在每个任务结束的时候，MapReduce库统计计算资源的使用状况。在表1，我们列出了2004年8月份MapReduce运行的任务所占用的相关资源。</p><h2 id="6-1-large-scaling-indexing"><a href="#6-1-large-scaling-indexing" class="headerlink" title="6.1 large-scaling indexing"></a>6.1 large-scaling indexing</h2><p>到目前为止，MapReduce最成功的应用就是重写了Google网络搜索服务所使用到的index系统。索引系统的输入数据是网络爬虫抓取回来的海量的文档，这些文档数据都保存在GFS文件系统里。这些文档原始内容（raw contents，我认为就是网页中的剔除html标记后的内容、pdf和word等有格式文档中提取的文本内容等）的大小超过了20TB。索引程序是通过一系列的MapReduce操作（大约5到10次）来建立索引。使用MapReduce（替换上一个特别设计的、分布式处理的索引程序）带来这些好处：</p><p>1.实现索引部分的代码简单、小巧、容易理解，因为对于容错、分布式以及并行计算的处理都是MapReduce库提供的。比如，使用MapReduce库，计算的代码行数从原来的3800行C++代码减少到大概700行代码。</p><p>2.MapReduce库的性能已经足够好了，因此我们可以把在概念上不相关的计算步骤分开处理，而不是混在一起以期减少数据传递的额外消耗。概念上不相关的计算步骤的隔离也使得我们可以很容易改变索引处理方式。比如，对之前的索引系统的一个小更改可能要耗费好几个月的时间，但是在使用MapReduce的新系统上，这样的更改只需要花几天时间就可以了。</p><p>3.索引系统的操作管理更容易了。因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝大部分问题都已经由MapReduce库解决了，不再需要操作人员的介入了。另外，我们可以通过在索引系统集群中增加机器的简单方法提高整体处理性能。</p><h2 id="7-Relate-work"><a href="#7-Relate-work" class="headerlink" title="7 Relate work"></a>7 Relate work</h2><p>很多系统都提供了严格的编程模式，并且通过对编程的严格限制来实现并行计算。例如，一个结合函数可以通过把N个元素的数组的前缀在N个处理器上使用并行前缀算法，在log N的时间内计算完[6，9，13]（???）。MapReduce可以看作是我们结合在真实环境下处理海量数据的经验，对这些经典模型进行简化和萃取的成果。更加值得骄傲的是，我们还实现了基于上千台处理器的集群的容错处理。相比而言，大部分并发处理系统都只在小规模的集群上实现，并且把容错处理交给了程序员。</p><p>Bulk Synchronous Programming[17]和一些MPI原语[11]提供了更高级别的并行处理抽象，可以更容易写出并行处理的程序。MapReduce和这些系统的关键不同之处在于，MapReduce利用限制性编程模式实现了用户程序的自动并发处理，并且提供了透明的容错处理。</p><p>我们数据本地优化策略的灵感来源于active disks[12,15]等技术，在active disks中，计算任务是尽量推送到数据存储的节点处理，这样就减少了网络和IO子系统的吞吐量。我们在挂载几个硬盘的普通机器上执行我们的运算，而不是在磁盘处理器上执行我们的工作，但是达到的目的一样的。</p><p>我们的备用任务机制和Charlotte System[3]提出的eager调度机制比较类似。Eager调度机制的一个缺点是如果一个任务反复失效，那么整个计算就不能完成。我们通过忽略引起故障的记录的方式在某种程度上解决了这个问题。</p><p>MapReduce的实现依赖于一个内部的集群管理系统，这个集群管理系统负责在一个超大的、共享机器的集群上分布和运行用户任务。虽然这个不是本论文的重点，但是有必要提一下，这个集群管理系统在理念上和其它系统，如Condor[16]是一样。</p><p>MapReduce库的排序机制和NOW-Sort[1]的操作上很类似。读取输入源的机器（map workers）把待排序的数据进行分区后，发送到R个Reduce worker中的一个进行处理。每个Reduce worker在本地对数据进行排序（尽可能在内存中排序）。当然，NOW-Sort没有给用户自定义的Map和Reduce函数的机会，因此不具备MapReduce库广泛的实用性。</p><p>River[2]提供了一个编程模型：处理进程通过分布式队列传送数据的方式进行互相通讯。和MapReduce类似，River系统尝试在不对等的硬件环境下，或者在系统颠簸的情况下也能提供近似平均的性能。River是通过精心调度硬盘和网络的通讯来平衡任务的完成时间。MapReduce库采用了其它的方法。通过对编程模型进行限制，MapReduce框架把问题分解成为大量的“小”任务。这些任务在可用的worker集群上动态的调度，这样快速的worker就可以执行更多的任务。通过对编程模型进行限制，我们可用在工作接近完成的时候调度备用任务，缩短在硬件配置不均衡的情况下缩小整个操作完成的时间（比如有的机器性能差、或者机器被某些操作阻塞了）。</p><p>BAD-FS[5]采用了和MapReduce完全不同的编程模式，它是面向广域网的。不过，这两个系统有两个基础功能很类似。（1）两个系统采用重新执行的方式来防止由于失效导致的数据丢失。（2）两个都使用数据本地化调度策略，减少网络通讯的数据量。</p><p>TACC[7]是一个用于简化构造高可用性网络服务的系统。和MapReduce一样，它也依靠重新执行机制来实现的容错处理。</p><h2 id="8-Conclusions"><a href="#8-Conclusions" class="headerlink" title="8 Conclusions"></a>8 Conclusions</h2><p>MapReduce编程模型在Google内部成功应用于多个领域。我们把这种成功归结为几个方面：首先，由于MapReduce封装了并行处理、容错处理、数据本地化优化、负载均衡等等技术难点的细节，这使得MapReduce库易于使用。即便对于完全没有并行或者分布式系统开发经验的程序员而言；其次，大量不同类型的问题都可以通过MapReduce简单的解决。比如，MapReduce用于生成Google的网络搜索服务所需要的数据、用来排序、用来数据挖掘、用于机器学习，以及很多其它的系统；第三，我们实现了一个在数千台计算机组成的大型集群上灵活部署运行的MapReduce。这个实现使得有效利用这些丰富的计算资源变得非常简单，因此也适合用来解决Google遇到的其他很多需要大量计算的问题。</p><p>我们也从MapReduce开发过程中学到了不少东西。首先，约束编程模式使得并行和分布式计算非常容易，也易于构造容错的计算环境；其次，网络带宽是稀有资源。大量的系统优化是针对减少网络传输量为目的的：本地优化策略使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节约了网络带宽；第三，备份服务器执行相同的任务可以减少性能缓慢的机器带来的负面影响（硬件配置的不平衡），同时解决了由于机器失效导致的数据丢失问题。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau,David E. Culler, Joseph M. Hellerstein, and David A. Patterson.High-performance sorting on networks of workstations.In Proceedings of the 1997 ACM SIGMOD InternationalConference on Management of Data, Tucson,Arizona, May 1997.<br>[2] Remzi H. Arpaci-Dusseau, Eric Anderson, NoahTreuhaft, David E. Culler, Joseph M. Hellerstein, David Patterson, and Kathy Yelick. Cluster I/O with River:Making the fast case common. In Proceedings of the Sixth Workshop on Input/Output in Parallel and Distributed Systems (IOPADS ’99), pages 10.22, Atlanta, Georgia, May 1999.<br>[3] Arash Baratloo, Mehmet Karaul, Zvi Kedem, and Peter Wyckoff. Charlotte: Metacomputing on the web. In Proceedings of the 9th International Conference on Parallel and Distributed Computing Systems, 1996. [4] Luiz A. Barroso, Jeffrey Dean, and Urs H¨olzle. Web search for a planet: The Google cluster architecture. IEEE Micro, 23(2):22.28, April 2003.<br>[5] John Bent, Douglas Thain, Andrea C.Arpaci-Dusseau, Remzi H. Arpaci-Dusseau, and Miron Livny. Explicit control in a batch-aware distributed file system. In Proceedings of the 1st USENIX Symposium on Networked Systems Design and Implementation NSDI, March 2004.<br>[6] Guy E. Blelloch. Scans as primitive parallel operations.IEEE Transactions on Computers, C-38(11), November 1989.<br>[7] Armando Fox, Steven D. Gribble, Yatin Chawathe, Eric A. Brewer, and Paul Gauthier. Cluster-based scalable network services. In Proceedings of the 16th ACM Symposium on Operating System Principles, pages 78. 91, Saint-Malo, France, 1997.<br>[8] Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung. The Google file system. In 19th Symposium on Operating Systems Principles, pages 29.43, Lake George, New York, 2003. To appear in OSDI 2004 12<br>[9] S. Gorlatch. Systematic efficient parallelization of scan and other list homomorphisms. In L. Bouge, P. Fraigniaud, A. Mignotte, and Y. Robert, editors, Euro-Par’96. Parallel Processing, Lecture Notes in Computer Science 1124, pages 401.408. Springer-Verlag, 1996.<br>[10] Jim Gray. Sort benchmark home page. <a href="http://research.microsoft.com/barc/SortBenchmark/">http://research.microsoft.com/barc/SortBenchmark/</a>.<br>[11] William Gropp, Ewing Lusk, and Anthony Skjellum. Using MPI: Portable Parallel Programming with the Message-Passing Interface. MIT Press, Cambridge, MA, 1999.<br>[12] L. Huston, R. Sukthankar, R.Wickremesinghe, M. Satyanarayanan, G. R. Ganger, E. Riedel, and A. Ailamaki. Diamond: A storage architecture for early discard in interactive search. In Proceedings of the 2004 USENIX File and Storage Technologies FAST Conference, April 2004.<br>[13] Richard E. Ladner and Michael J. Fischer. Parallel prefix computation. Journal of the ACM, 27(4):831.838, 1980.<br>[14] Michael O. Rabin. Efficient dispersal of information for security, load balancing and fault tolerance. Journal of the ACM, 36(2):335.348, 1989.<br>[15] Erik Riedel, Christos Faloutsos, Garth A. Gibson, and David Nagle. Active disks for large-scale data processing. IEEE Computer, pages 68.74, June 2001.<br>[16] Douglas Thain, Todd Tannenbaum, and Miron Livny. Distributed computing in practice: The Condor experience. Concurrency and Computation: Practice and Experience, 2004.<br>[17] L. G. Valiant. A bridging model for parallel computation. Communications of the ACM, 33(8):103.111, 1997.<br>[18] Jim Wyllie. Spsort: How to sort a terabyte quickly. <a href="http://alme1.almaden.ibm.com/cs/spsort.pdf">http://alme1.almaden.ibm.com/cs/spsort.pdf</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;MapReduce 中文翻译&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;MapRedu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LSM Tree</title>
    <link href="https://codroc.github.io/2022/05/31/LSMTree/"/>
    <id>https://codroc.github.io/2022/05/31/LSMTree/</id>
    <published>2022-05-31T11:57:16.000Z</published>
    <updated>2022-05-31T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注意：转载自 <a href="https://zhuanlan.zhihu.com/p/415799237">深入浅出分析 LSM 树（日志结构合并树）</a></strong></p><h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p>最近在调研NoSQL数据库，发现RocksDB、LevelDB、HBase以及Prometheus等，其底层的存储引擎都是基于LSM树，于是决定花时间彻底吃透LSM树这一数据结构。</p><p>不幸的是，在查阅资料学习的过程中，发现网上各种文章汗牛充栋、抄来抄去，不是文不对题就是不知所云。</p><p>一气之下决定自己写一篇出来消消气，便有了这篇文章。。。</p><p>PS：学了这么多数据结构，LSMTree应该是最年轻的一个，它在1996年被设计出来(属老鼠的)，年纪比我还小~</p><p>相比于B/B+树或者倒排索引，LSMTree采用了“疯狂到不顾一切”的干啥都磁盘顺序写的方案，赋予了它无与伦比的写吞吐量。</p><h2 id="一、LSM树数据结构定义"><a href="#一、LSM树数据结构定义" class="headerlink" title="一、LSM树数据结构定义"></a>一、LSM树数据结构定义</h2><p>查阅了一些资料，LSM树并没有一种固定死的实现方式，更多的是一种将：</p><p>“磁盘顺序写” + “多个树(状数据结构)” + “冷热（新老）数据分级” + “定期归并” + “非原地更新”这几种特性统一在一起的思想。</p><p>为了方便后续的讲解分析，我们尝试先对LSM树做一个定义。</p><p><strong>LSM树的定义：</strong></p><ol><li>LSM树是一个横跨内存和磁盘的，包含多颗”子树”的一个森林。</li><li>LSM树分为Level 0，Level 1，Level 2 … Level n 多颗子树，其中只有Level 0在内存中，其余Level 1-n在磁盘中。</li><li>内存中的Level 0子树一般采用排序树（红黑树/AVL树）、跳表或者TreeMap等这类有序的数据结构，方便后续顺序写磁盘。</li><li>磁盘中的Level 1-n子树，本质是数据排好序后顺序写到磁盘上的文件，只是叫做树而已。</li><li>每一层的子树都有一个阈值大小，达到阈值后会进行合并，合并结果写入下一层。</li><li>只有内存中数据允许原地更新，磁盘上数据的变更只允许追加写，不做原地更新。</li></ol><p>以上6条定义组成了LSM树，如图1所示。</p><p><img src="https://s1.ax1x.com/2022/05/31/X8jGf1.png" alt="LSMTree 的组成和定义"></p><ul><li>图1中分成了左侧绿色的内存部分和右侧蓝色的磁盘部分（定义1）。</li><li>图1左侧绿色的内存部分只包含Level 0树，右侧蓝色的磁盘部分则包含Level 1-n等多棵”树”（定义2）</li><li>图1左侧绿色的内存部分中Level 0是一颗二叉排序树（定义3）。注意这里的有序性，该性质决定了LSM树优异的读写性能。</li><li>图1右侧蓝色的磁盘部分所包含的Level 1到Level n多颗树，虽然叫做“树”，但本质是按数据key排好序后，顺序写在磁盘上的一个个文件（定义4） ，注意这里再次出现了有序性。</li><li>内存中的Level 0树在达到阈值后，会在内存中遍历排好序的Level 0树并顺序写入磁盘的Level 1。同样的，在磁盘中的Level n（n&gt;0）达到阈值时，则会将Level n层的多个文件进行归并，写入Level n+1层。（定义5）</li><li>除了内存中的Level 0层做原地更新外，对已写入磁盘上的数据，都采用Append形式的磁盘顺序写，即更新和删除操作并不去修改老数据，只是简单的追加新数据。图1中右侧蓝色的磁盘部分，Level 1和Level 2均包含key为2的数据，同时图1左侧绿色内存中的Level 0树也包含key为2的数据节点。（定义6）</li></ul><p>下面我们遵循LSM树的6条定义，通过动图对LSM树的<strong>增、删、改、查和归并</strong>进行详细分析。</p><h2 id="二、插入操作"><a href="#二、插入操作" class="headerlink" title="二、插入操作"></a>二、插入操作</h2><p>LSM树的插入较简单，数据无脑往内存中的Level 0排序树丢即可，并不关心该数据是否已经在内存或磁盘中存在。（已经存在该数据的话，则场景转换成更新操作，详见第四部分）</p><p>图2展示了，新数据直接插入Level 0树的过程。</p><p><img src="https://s2.loli.net/2022/05/31/3CuHXNaoIpxq4ZG.gif" alt="lsmtree1.gif"></p><p>如上图2所示，我们依次插入了key=9、1、6的数据，这三个数据均按照key的大小，插入内存里的Level 0排序树中。该操作复杂度为树高log(n)，n是Level 0树的数据量，可见代价很低，能实现极高的写吞吐量。</p><h2 id="三、删除操作"><a href="#三、删除操作" class="headerlink" title="三、删除操作"></a>三、删除操作</h2><p>LSM树的删除操作并不是直接删除数据，而是通过一种叫“墓碑标记”的特殊数据来标识数据的删除。</p><p>删除操作分为：待删除数据在内存中、待删除数据在磁盘中 和 该数据根本不存在 三种情况。</p><p><strong>3.1 待删除数据在内存中：</strong></p><p>如图3所示，展示了待删除数据在内存中的删除过程。我们不能简单地将Level 0树中的黄色节点2删除，而是应该采用墓碑标记将其覆盖（思考题：为什么不能直接删除而是要用墓碑标记覆盖呢）</p><p><img src="https://s2.loli.net/2022/05/31/lZV3X1HNL8bRpfT.gif" alt="lsmtree2.gif"></p><p><strong>3.2 待删除数据在磁盘中：</strong></p><p>如图4所示，展示了待删除数据在磁盘上时的删除过程。我们并不去修改磁盘上的数据（理都不理它），而是直接向内存中的Level 0树中插入墓碑标记即可。</p><p><img src="https://s2.loli.net/2022/05/31/SxWdBnfY6UREevJ.gif" alt="v2-6130424a556ba99a040bcd474371d347_b.webp"></p><p><strong>3.3 待删除数据根本不存在：</strong></p><p>这种情况等价于在内存的Level 0树中新增一条墓碑标记，场景转换为情况3.2的内存中插入墓碑标记操作。</p><p>综合看待上述三种情况，发现不论数据有没有、在哪里，删除操作都是等价于向Level 0树中写入墓碑标记。该操作复杂度为树高log(n)，代价很低。</p><h2 id="四、修改操作"><a href="#四、修改操作" class="headerlink" title="四、修改操作"></a>四、修改操作</h2><p>LSM树的修改操作和删除操作很像，也是分为三种情况：待修改数据在内存中、在磁盘中和 该数据根本不存在。</p><p><strong>4.1 待修改数据在内存中：</strong></p><p><img src="https://s2.loli.net/2022/05/31/UKyCzL9eSFEiGfP.gif" alt="lsmtree4.gif"></p><p>如图5所示，展示了待修改数据在内存中的操作过程。新的蓝色的key=7的数据，直接定位到内存中Level 0树上黄色的老的key=7的位置，将其覆盖即可。</p><p><strong>4.2 待修改数据在磁盘中：</strong></p><p><img src="https://s2.loli.net/2022/05/31/IzHol4A3mhLKv9k.gif" alt="lsmtree5.gif"></p><p>如图6所示，展示了待修改数据在磁盘中的操作过程。LSM树并不会去磁盘中的Level 1树上原地更新老的key=7的数据，而是直接将新的蓝色的节点7插入内存中的Level 0树中。</p><p><strong>4.3 该数据根本不存在：</strong></p><p>此场景等价于情况b，直接向内存中的Level 0树插入新的数据即可。</p><p>综上4.1、4.2、4.3三种情况可以看出，修改操作都是对内存中Level 0进行覆盖/新增操作。该操作复杂度为树高log(n)，代价很低。</p><p>我们会发现，LSM树的增加、删除、修改（这三个都属于写操作）都是在内存中倒腾，完全没涉及到磁盘操作，所以速度飞快，写吞吐量高的离谱。。。</p><h2 id="五、查询操作"><a href="#五、查询操作" class="headerlink" title="五、查询操作"></a>五、查询操作</h2><p>LSM树的查询操作会按顺序查找Level 0、Level 1、Level 2 … Level n 每一颗树，一旦匹配便返回目标数据，不再继续查询。该策略保证了查到的一定是目标key最新版本的数据（有点MVCC的感觉）。</p><p>我们来分场景分析：依然分为 待查询数据在内存中 和 待查询数据在磁盘中 两种情况。</p><p><strong>5.1 待查询数据在内存中：</strong></p><p>如图7所示，展示了待查询数据在内存中时的查询过程。</p><p><img src="https://s2.loli.net/2022/05/31/V3OJ6nQw4tMUruf.gif" alt="lsmtree6.gif"></p><p>沿着内存中已排好序的Level 0树递归向下比较查询，返回目标节点即可。我们注意到磁盘上的Level 1树中同样包括一个key=6的较老的数据。但LSM树查询的时候会按照Level 0、1、2 … n的顺序查询，一旦查到第一个就返回，因此磁盘上老的key=6的数据没人理它，更不会作为结果被返回。</p><p><strong>5.2 待查询数据在磁盘中：</strong></p><p>如图8所示，展示了待查询数据在磁盘上时的查询过程。</p><p><img src="https://s2.loli.net/2022/05/31/yuPIQdsvNwOKBLA.gif" alt="lsmtree7.gif"></p><p>先查询内存中的Level 0树，没查到便查询磁盘中的Level 1树，还是没查到，于是查询磁盘中的Level 2树，匹配后返回key=6的数据。</p><p>综合上述两种情况，我们发现，LSM树的查询操作相对来说代价比较高，需要从Level 0到Level n一直顺序查下去。极端情况是LSM树中不存在该数据，则需要把整个库从Level 0到Level n给扫了一遍，然后返回查无此人（可以通过 布隆过滤器 + 建立稀疏索引 来优化查询操作）。代价大于以B/B+树为基本数据结构的传统RDB存储引擎。</p><h2 id="六、合并操作"><a href="#六、合并操作" class="headerlink" title="六、合并操作"></a>六、合并操作</h2><p>合并操作是LSM树的核心（毕竟LSM树的名字就叫: 日志结构合并树，直接点名了合并这一操作）</p><p>之所以在增、删、改、查这四个基本操作之外还需要合并操作：一是因为内存不是无限大，Level 0树达到阈值时，需要将数据从内存刷到磁盘中，这是合并操作的第一个场景；二是需要对磁盘上达到阈值的顺序文件进行归并，并将归并结果写入下一层，归并过程中会清理重复的数据和被删除的数据(墓碑标记)。我们分别对上述两个场景进行分析：</p><p><strong>6.1 内存数据写入磁盘的场景：</strong></p><p>如图9所示，展示了内存中Level 0树在达到阈值后，归并写入磁盘Level 1树的场景。</p><p><img src="https://s2.loli.net/2022/05/31/2MbPpej7UJstEko.gif" alt="lsmtree8.gif"></p><p>对内存中的Level 0树进行中序遍历，将数据顺序写入磁盘的Level 1层即可，我们可以看到因为Level 0树是已经排好序的，所以写入的Level 1中的新块也是有序的（有序性保证了查询和归并操作的高效）。此时磁盘的Level 1层有两个Block块。</p><p><strong>6.2 磁盘中多个块的归并：</strong></p><p>如图10所示，该图展示了磁盘中Level 1层达到阈值时，对其包含的两个Block块进行归并，并将归并结果写入Level 2层的过程。</p><p><img src="https://s2.loli.net/2022/05/31/DWR6T8BOhreKIY2.gif" alt="lsmtree9.gif"></p><p>我们注意到key=5和key=7的数据同时存在于较老的Block 1和较新的Block 2中。而归并的过程是保留较新的数据，于是我们看到结果中，key=5和7的数据都是红色的（来自于较新的Block2）。</p><p>综上我们可以看到，不论是场景6.1还是场景6.2，由于原始数据都是有序的，因此归并的过程只需要对数据集进行一次扫描即可，复杂度为O(n)。</p><h2 id="七、优缺点分析"><a href="#七、优缺点分析" class="headerlink" title="七、优缺点分析"></a>七、优缺点分析</h2><p>以上便是对LSM树的增、删、改、查和归并五种核心操作的详细分析。</p><p>可以看到LSM树将增、删、改这三种操作都转化为内存insert + 磁盘顺序写(当Level 0满的时候)，通过这种方式得到了无与伦比的写吞吐量。</p><p>LSM树的查询能力则相对被弱化，相比于B+树的最多3~4次磁盘IO，LSM树则要从Level 0一路查询Level n，极端情况下等于做了全表扫描。（即便做了稀疏索引，也是lg(N0)+lg(N1)+…+lg(Nn)的复杂度，大于B+树的lg(N0+N1+…+Nn)的时间复杂度）。</p><p>同时，LSM树只append追加不原地修改的特性引入了归并操作，归并操作涉及到大量的磁盘IO，比较消耗性能，需要合理设置触发该操作的参数。</p><p>综上我们可以给出LSM树的优缺点：</p><p>优：增、删、改操作飞快，写吞吐量极大。</p><p>缺：读操作性能相对被弱化；不擅长区间范围的读操作； 归并操作较耗费资源。</p><p>LSMTree的增、删、改、查四种基本操作的时间复杂度分析如下所示：</p><table><thead><tr><th>操作</th><th>平均代价</th><th>最坏情况代价</th></tr></thead><tbody><tr><td>插入</td><td>1</td><td>1</td></tr><tr><td>删除</td><td>1</td><td>1</td></tr><tr><td>修改</td><td>1</td><td>1</td></tr><tr><td>查找</td><td>lgN</td><td>lgN</td></tr></tbody></table><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>以上是对LSM树基本操作以及优缺点的分析，我们可以据此得出LSM树的设计原则：</p><ol><li>先内存再磁盘</li><li>内存原地更新</li><li>磁盘追加更新</li><li>归并保留新值</li></ol><p>如果说B/B+树的读写性能基本平衡的话，LSM树的设计原则通过舍弃部分读性能，换取了无与伦比的写性能。该数据结构适合用于写吞吐量远远大于读吞吐量的场景，得到了NoSQL届的喜爱和好评。</p><p><strong>注意：转载自 <a href="https://zhuanlan.zhihu.com/p/415799237">深入浅出分析 LSM 树（日志结构合并树）</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;注意：转载自 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/415799237&quot;&gt;深入浅出分析 LSM 树（日志结构合并树）&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RPC 相关的一些文章与概念</title>
    <link href="https://codroc.github.io/2022/05/15/rpc%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://codroc.github.io/2022/05/15/rpc%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-05-15T11:57:16.000Z</published>
    <updated>2022-05-15T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC-的概念"><a href="#RPC-的概念" class="headerlink" title="RPC 的概念"></a>RPC 的概念</h1><p>RPC 是 Remote Procedure Call 的缩写。即<strong>远端过程调用</strong>。</p><p>过程可以理解为函数，远端可以理解为非本地的。</p><p>可以参考与之相反的函数本地调用，它是发生在同一个进程环境中的。先来看看它的流程：<br><a href="C:\Users\codroc\Pictures\pictures\RPC图1.PNG">本地函数调用</a></p><p>这段代码，我们知道，传入了1，2两个入参数，调用了本地代码段中的一个 Add 函数，得到了 result 出参。此时，传入数据，传出数据，代码段在同一个进程空间里，这是本地函数调用。</p><p>而 RPC 是跨进程的函数调用（大多数情况下是跨主机的），它可以用以下流程表示：<br><a href="C:\Users\codroc\Pictures\pictures\RPC图2.PNG">远端函数调用</a></p><h1 id="RPC-的作用"><a href="#RPC-的作用" class="headerlink" title="RPC 的作用"></a>RPC 的作用</h1><p>为什么要使用 RPC？我相信很多刚了解 RPC 的人都会想这个问题。对于很多人来说这其实是两个问题，<font color="red">一：为什么不把函数、方法都放在本地而要去调用远程的？二：不就是调用了一下不在本地的方法嘛，可以用 HTTP 协议通信来实现啊，为什么非要用 RPC 框架呢？</font></p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>我仔细地想过，没有绝对的答案，必须要因地制宜，具体情况具体分析。如果你只是设计一个简单的应用（比如一个静态博客），那么把函数或方法都放在本地就可以了，还减去了网络通信上的时延。</p><p>但是如果你要设计复杂的高并发系统（例如tb，pdd），你就不得不考虑到很多问题，<font color="red">例如系统的<a href="https://www.w3cschool.cn/architectroad/architectroad-high-availability.html">高可用</a>，高可靠，<a href="https://www.w3cschool.cn/architectroad/architectroad-high-concurrent.html">高并发</a>，可扩展性，系统维护等等。</font>这种系统一定是<a href="https://www.cnblogs.com/xybaby/p/7787034.html">分布式系统</a>！在分布式系统中，RPC 是很常见的。</p><hr><p>简单的从几个角度分析，复杂系统必须用分布式系统：</p><p>高可用：一个进程 cresh 了，或一台机器宕机了，或一处网络断掉了，都会导致系统不可用。为了<font color="red">防止尽量减少系统的不能提供服务的时间，必定是要做“集群化”，或者叫“冗余”</font>：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他 backup 能够顶上。</p><p>高并发：一台机器的性能是有极限的，当一台机器处理不过来时（或是存储不够时），增加服务器数量能够直接解决问题。</p><p>系统维护：复杂的系统，往往由多个功能子系统构成，如果把所有子系统都放在同一个环境下，代码的维护将变得十分困难。版本的迭代很可能出现 Bug，一旦一个功能出现问题，由于所有功能都放在了一起，导致所有的代码都要回滚。</p><hr><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>用 HTTP 协议来通信或自己设计一种通信协议不也可以做到远端的过程调用吗，那为什么非要搞出个 RPC 呢？</p><p>可以去看这篇<a href="https://www.w3cschool.cn/architectroad/architectroad-rpc-framework.html">文章</a>的“需求缘起”小节！</p><h1 id="RPC-框架的目的"><a href="#RPC-框架的目的" class="headerlink" title="RPC 框架的目的"></a>RPC 框架的目的</h1><p>目的只有一个，对整个远端过程调用进行抽象，减少业务之外的重复性技术劳动。</p><ul><li><font color="red">调用方像调用本地函数一样去调用远端的函数（服务）。</font></li><li><font color="red">服务提供方就像实现本地函数一样来实现函数。</font></li></ul><h1 id="RPC-技术点"><a href="#RPC-技术点" class="headerlink" title="RPC 技术点"></a>RPC 技术点</h1><p>RPC 一般分为 RPC-Client 和 RPC-Server，其中 RPC-Client 对服务的访问方式又分为同步访问、异步访问和半同步访问。</p><p>在 RPC-Client 中，一般需要用到以下技术点：</p><ul><li>共同技术点：序列化反序列化，连接池，故障检测，负载均衡，超时处理等</li><li>异步访问多了以下几点：上下文管理，收发队列，收发线程等</li></ul><p>这篇文章已经很好的总结了这些要点：<a href="https://www.w3cschool.cn/architectroad/architectroad-rpc-client-asynchronous-send-and-receive.html">RPC-Client异步收发</a></p><p>至于更多的技术点，我建议去看 <a href="https://github.com/apache/incubator-brpc">brpc</a>，它是国内非常优秀的 RPC 框架，并配有十分详细的文档，看了让人受益匪浅！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/xybaby/p/7787034.html">分布式系统介绍</a></li><li><a href="https://www.w3cschool.cn/architectroad/architectroad-high-availability.html">高可用</a></li><li><a href="https://www.w3cschool.cn/architectroad/architectroad-high-concurrent.html">高并发</a></li><li><a href="https://www.w3cschool.cn/architectroad/architectroad-rpc-client-asynchronous-send-and-receive.html">RPC-Client异步收发</a></li><li><a href="https://www.w3cschool.cn/architectroad/architectroad-rpc-framework.html">RPC框架</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RPC-的概念&quot;&gt;&lt;a href=&quot;#RPC-的概念&quot; class=&quot;headerlink&quot; title=&quot;RPC 的概念&quot;&gt;&lt;/a&gt;RPC 的概念&lt;/h1&gt;&lt;p&gt;RPC 是 Remote Procedure Call 的缩写。即&lt;strong&gt;远端过程调用&lt;/s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++ Chrono 库使用记录</title>
    <link href="https://codroc.github.io/2022/05/12/chrono%E5%BA%93/"/>
    <id>https://codroc.github.io/2022/05/12/chrono%E5%BA%93/</id>
    <published>2022-05-12T11:57:16.000Z</published>
    <updated>2022-05-12T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-17-chrono-库"><a href="#c-17-chrono-库" class="headerlink" title="c++17 chrono 库"></a>c++17 chrono 库</h1><p>记录下 chrono 库中常用的方法。</p><h3 id="1-获取格式化的当前日期"><a href="#1-获取格式化的当前日期" class="headerlink" title="1. 获取格式化的当前日期"></a>1. 获取格式化的当前日期</h3><p>本质还是 C 那一套：用 <code>struct tm* ctime(struct time_t*)</code> 接口，而在 C++ 中则是使用 <code>char* ctime(const std::time_t* time);</code> 接口。</p><p>可以使用 <code>std::time_t std::chrono::system_clock::to_time_t(const time_point&amp; t)</code> 接口获取 <code>std::time_t</code>，而 <code>time_point</code> 则可以用 <code>std::chrono::system_clock::now()</code> 接口获取。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> today = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(t);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::ctime(&amp;today) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c-17-chrono-库&quot;&gt;&lt;a href=&quot;#c-17-chrono-库&quot; class=&quot;headerlink&quot; title=&quot;c++17 chrono 库&quot;&gt;&lt;/a&gt;c++17 chrono 库&lt;/h1&gt;&lt;p&gt;记录下 chrono 库中常用的方法。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SSL</title>
    <link href="https://codroc.github.io/2022/04/22/SSL/"/>
    <id>https://codroc.github.io/2022/04/22/SSL/</id>
    <published>2022-04-22T11:57:16.000Z</published>
    <updated>2022-04-22T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h1><p>SSL 即 Secure Sockets Layer，是提高信道安全性的协议。不使用 SSL 的 HTTP 通信，是不安全的，所有信息明文传输。</p><blockquote><p>注意：SSL 应用于 socket，因此理论上 UDP、UnixSocket 都可以使用 SSL 协议。是现实反正我知道 openssl 可以运用于 TCP 和 UDP。查了资料显示，DTLS 协议实现了在 UDP 协议之上的 TLS 安全层。</p></blockquote><p>安全通信应该具有下列所需的特性：</p><ul><li>机密性：对数据进行加密，仅仅只有接收方和发送方能够对数据解密，其他方就算能获取数据也看不懂。（使用对称加密算法）</li><li>报文完整性：防止他人篡改数据。（可以用 MAC 来判断）</li><li>端点鉴别：鉴别另一方<strong>确实是</strong>我想要进行通信的一方。（可以用数字签名）</li></ul><p>几个基本概念：</p><ul><li>不重数</li><li>对称加密</li><li>非对称加密</li><li>哈希算法</li><li>MAC 报文鉴别码</li></ul><p><strong>不重数</strong>解决的是，防止 SSL 握手阶段<strong>重放攻击</strong>，基本的思想来自 TCP 握手阶段的 <strong>随机序号</strong>（保证了上次建立连接发送的 SYN 包不会引起下次连接）。</p><p>对称加密，必须是双方都持有同一密钥，那么就能对数据加密与解密。</p><p>非对称加密，可以用私钥加密，公钥解密（数字签名）；也可以用公钥加密私钥解密（加密通信）。</p><p>哈希算法，把非定常数据 hash 成定长字符串，无法解密，不可逆向，运算比较耗时。</p><p>MAC，即 Message Authentication Code 报文鉴别码。发送方发送在报文末尾带 MAC 的 package。MAC = h(m, s) 其中 h 为 hash 函数，m 为报文数据，s 为鉴别密钥；接收方用 鉴别密钥重新计算一遍 MAC，如果和报文末尾的一致，那么就可以保证报文的完整性。</p><p><strong>常见加密算法以及 Hash 函数：</strong></p><p>对称加密：AES、DES、Blowfish、CAST、IDEA、RC2、RC5</p><p>非对称加密：DH、RSA、DSA、EC</p><p>Hash 函数：MD5、SHA1、SHA2</p><h3 id="SSL-握手、通信、挥手的整个流程"><a href="#SSL-握手、通信、挥手的整个流程" class="headerlink" title="SSL 握手、通信、挥手的整个流程"></a>SSL 握手、通信、挥手的整个流程</h3><h4 id="1-SSL-握手"><a href="#1-SSL-握手" class="headerlink" title="1. SSL 握手"></a>1. SSL 握手</h4><p>(1) 客户端发送它支持的<strong>加密算法列表</strong>以及一个<strong>不重数</strong>。</p><p>(2) 服务器从列表中选出<strong>一个对称加密算法</strong>，<strong>一个非对称加密算法</strong>，<strong>一个 MAC 算法</strong>。它把<strong>三种算法</strong>连同自己的<strong>数字证书</strong>以及自己的<strong>不重数</strong>发给客户端。</p><p>(3) 根据 CA 给的公钥解密数字签名，得到 hash 值。验证该 hash 值是否和服务器发过来的元素经过 hash 后的值一致，来进行端点鉴别。</p><p>(4) 客户端生成一个 <strong>前主密钥</strong> PMS（Pre-Master Secret），并用服务器给的公钥加密该 PMS，然后发给服务器。</p><blockquote><p>注意：这里双方并不直接使用 PMS 对数据进行加密；而是，客户端和服务器分别通过 PMS 和自己收到的不重数，使用相同的密钥导出函数计算出自己的主密钥 MS（Master Secret），然后把 MS 切片成一个数据加密密钥 S 和一个 MAC。这样总共得到四个密钥，客户端和服务器共享这 4 个密钥。然后后面的机密性和数据完整性都由这 4 个密钥来实现。</p></blockquote><p>(5) optional</p><p>(6) optional</p><p>(7) 客户端发送一个加密后 “finished” 报文表示握手阶段结束。</p><p>(8) 服务端发送一个加密后 “finished” 报文表示握手阶段结束。</p><blockquote><p>注意：后续，客户端和服务器各需发送一个<em>所有握手报文的一个 MAC</em> 用于保证数据完整性，使握手免受篡改危害。见自顶向下p414.</p></blockquote><p>(9) 用 S 进行加密通信。用 MAC 保证数据完整性。</p><p><img src="https://s1.ax1x.com/2022/04/19/LDFMOU.png"></p><h4 id="2-SSL-挥手"><a href="#2-SSL-挥手" class="headerlink" title="2. SSL 挥手"></a>2. SSL 挥手</h4><p>不能简单的用 TCP FIN 来标识 SSL 挥手，因为这样会造成 <strong>截断攻击</strong>，即破坏者会直接发送一个 TCP FIN 过早的结束会话。具体见<strong>自顶向下p414.</strong></p><h3 id="使用-openssl-建立-安全-TCP-信道"><a href="#使用-openssl-建立-安全-TCP-信道" class="headerlink" title="使用 openssl 建立 安全 TCP 信道"></a>使用 openssl 建立 安全 TCP 信道</h3><p>这是 TCP 的安全通信。</p><p>OpenSSL 的 API 很多，但并不是都会被使用到，如果需要查看某个 API 的详细使用方法可以阅读 <a href="https://www.openssl.org/docs/">API文档</a>。</p><h4 id="1-1-初始化-OpenSSL"><a href="#1-1-初始化-OpenSSL" class="headerlink" title="1.1 初始化 OpenSSL"></a>1.1 初始化 OpenSSL</h4><p>  OpenSSL 在使用之前，必须进行相应的初始化工作。在建立 SSL 连接之前，要为 Client 和 Server 分别指定本次连接采用的协议及其版本，目前能够使用的协议版本包括 SSLv2、SSLv3、SSLv2/v3 和 TLSv1.0。SSL 连接若要正常建立，则要求 Client 和 Server 必须使用相互兼容的协议。</p><p>接下来是 openssl 库初始化的代码，根据 OpenSSL 的不同版本调用了不同的 API 进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OPENSSL_VERSION_NUMBER &gt;= 0x10100003L</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OPENSSL_init_ssl(OPENSSL_INIT_LOAD_CONFIG, <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;OPENSSL_init_ssl() failed!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * OPENSSL_init_ssl() may leave errors in the error queue</span></span><br><span class="line"><span class="comment">     * while returning success</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ERR_clear_error();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    OPENSSL_config(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    SSL_library_init();         <span class="comment">// 初始化SSL算法库函数( 加载要用到的算法 )，调用SSL函数之前必须调用此函数</span></span><br><span class="line">    SSL_load_error_strings();   <span class="comment">// 错误信息的初始化</span></span><br><span class="line"></span><br><span class="line">    OpenSSL_add_all_algorithms();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="1-2-创建-CTX"><a href="#1-2-创建-CTX" class="headerlink" title="1.2 创建 CTX"></a>1.2 创建 CTX</h4><p>  CTX 是 SSL 会话环境，建立连接时使用不同的协议，其 CTX 也不一样。创建 CTX 的相关 OpenSSL 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端、服务端都需要调用</span></span><br><span class="line">SSL_CTX_new();                       <span class="comment">//申请SSL会话环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若有验证对方证书的需求，则需调用</span></span><br><span class="line">SSL_CTX_set_verify(SSL_CTX *ctx, <span class="keyword">int</span> mode,</span><br><span class="line">     <span class="keyword">int</span> (*verify_callback)(<span class="keyword">int</span>, X509_STORE_CTX *)); <span class="comment">//指定证书验证方式</span></span><br><span class="line">SSL_CTX_load_verify_location();      <span class="comment">//为SSL会话环境加载本应用所信任的CA证书列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若有加载证书的需求，则需调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_use_certificate_file</span><span class="params">()</span></span>;      <span class="comment">//为SSL会话加载本应用的证书</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_use_certificate_chain_file</span><span class="params">()</span></span>;<span class="comment">//为SSL会话加载本应用的证书所属的证书链</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_use_PrivateKey_file</span><span class="params">()</span></span>;       <span class="comment">//为SSL会话加载本应用的私钥</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_check_private_key</span><span class="params">()</span></span>;         <span class="comment">//验证所加载的私钥和证书是否相匹配 </span></span><br></pre></td></tr></table></figure><h4 id="1-3-创建-SSL-套接字"><a href="#1-3-创建-SSL-套接字" class="headerlink" title="1.3 创建 SSL 套接字"></a>1.3 创建 SSL 套接字</h4><p>  在创建 SSL 套接字之前要先创建 Socket 套接字，建立 TCP 连接。创建 SSL 套接字相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SSL *<span class="title">SSl_new</span><span class="params">(SSL_CTX *ctx)</span></span>;          <span class="comment">//创建一个SSL套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_set_fd</span><span class="params">(SSL *ssl, <span class="keyword">int</span> fd)</span></span>;     <span class="comment">//以读写模式绑定流套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_set_rfd</span><span class="params">(SSL *ssl, <span class="keyword">int</span> fd)</span></span>;    <span class="comment">//以只读模式绑定流套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_set_wfd</span><span class="params">(SSL *ssl, <span class="keyword">int</span> fd)</span></span>;    <span class="comment">//以只写模式绑定流套接字</span></span><br></pre></td></tr></table></figure><h4 id="1-4-完成-SSL-握手"><a href="#1-4-完成-SSL-握手" class="headerlink" title="1.4 完成 SSL 握手"></a>1.4 完成 SSL 握手</h4><p>  在这一步，我们需要在普通 TCP 连接的基础上，建立 SSL 连接。与普通流套接字建立连接的过程类似：Client 使用函数SSL_connect()【类似于流套接字中用的connect()】发起握手，而 Server 使用函数 SSL_ accept()【类似于流套接字中用的accept()】对握手进行响应，从而完成握手过程。两函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_connect</span><span class="params">(SSL *ssl)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_accept</span><span class="params">(SSL *ssl)</span></span>;</span><br></pre></td></tr></table></figure><p>  握手过程完成之后，Client 通常会要求 Server 发送证书信息，以便对 Server 进行鉴别。其实现会用到以下两个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X509 *<span class="title">SSL_get_peer_certificate</span><span class="params">(SSL *ssl)</span></span>;  <span class="comment">//从SSL套接字中获取对方的证书信息</span></span><br><span class="line"><span class="function">X509_NAME *<span class="title">X509_get_subject_name</span><span class="params">(X509 *a)</span></span>; <span class="comment">//得到证书所用者的名字</span></span><br></pre></td></tr></table></figure><h4 id="1-5-数据传输"><a href="#1-5-数据传输" class="headerlink" title="1.5 数据传输"></a>1.5 数据传输</h4><p>  经过前面的一系列过程后，就可以进行安全的数据传输了。在数据传输阶段，需要使用 SSL_read( ) 和 SSL_write( ) 来代替普通流套接字所使用的 read( ) 和 write( ) 函数，以此完成对 SSL 套接字的读写操作,两个新函数的原型分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_read</span><span class="params">(SSL *ssl,<span class="keyword">void</span> *buf,<span class="keyword">int</span> num)</span></span>;            <span class="comment">//从SSL套接字读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_write</span><span class="params">(SSL *ssl,<span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">int</span> num)</span></span>;     <span class="comment">//向SSL套接字写入数据</span></span><br></pre></td></tr></table></figure><h4 id="1-6-会话结束"><a href="#1-6-会话结束" class="headerlink" title="1.6 会话结束"></a>1.6 会话结束</h4><p>  当 Client 和 Server 之间的通信过程完成后，就使用以下函数来释放前面过程中申请的 SSL 资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_shutdown</span><span class="params">(SSL *ssl)</span></span>;       <span class="comment">//关闭SSL套接字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSl_free</span><span class="params">(SSL *ssl)</span></span>;          <span class="comment">//释放SSL套接字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_CTX_free</span><span class="params">(SSL_CTX *ctx)</span></span>;  <span class="comment">//释放SSL会话环境</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/04/19/LDCCyF.png"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《计算机网络——自顶向下方法》</li><li><a href="http://www.cppblog.com/qinqing1984/archive/2014/04/11/206536.aspx">基于OpenSSL实现的安全连接</a></li><li><a href="https://www.openssl.org/docs/man1.1.0/ssl/">SSL API文档</a></li><li><a href="https://blog.csdn.net/hellopaul8597/article/details/52327730">Https协议详解</a></li><li><a href="https://blog.csdn.net/wetest_tencent/article/details/53425198">HTTPS是大势所趋？看腾讯专家通过Epoll+OpenSSL在高并发压测机器人中支持https</a></li><li><a href="https://wenku.baidu.com/view/74575278ed630b1c58eeb517.html">openssl 编程入门(含完整示例)</a></li><li><a href="https://blog.csdn.net/jinhill/article/details/3615626">SSL连接建立过程分析</a></li><li><a href="https://blog.csdn.net/pony_maggie/article/details/51315946">SSL socket 通讯详解</a></li><li><a href="https://www.jianshu.com/p/c93612b3abac">HTTPS从原理到应用(三)：SSL/TLS协议</a></li><li><a href="http://blog.jobbole.com/94332/">SSL/TLS 握手优化详解</a></li><li><a href="http://www.cnblogs.com/dongfuye/p/4121066.html">非阻塞/异步(epoll) openssl</a></li><li><a href="https://my.oschina.net/vincentwy/blog/620282?p=1">两个基于openssl的https client例子</a></li><li><a href="https://blog.csdn.net/howeverpf/article/details/18993945">OpenSSL编程初探1 — 使用OpenSSL API建立SSL通信的一般流程简介</a></li><li><a href="https://blog.csdn.net/howeverpf/article/details/14108063">OpenSSL编程初探2 — 关于证书文件的加载</a></li><li><a href="https://www.cnblogs.com/bwar/p/9879893.html">基于 openssl 的 HTTPS 通信 C++ 实现</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSL&quot;&gt;&lt;a href=&quot;#SSL&quot; class=&quot;headerlink&quot; title=&quot;SSL&quot;&gt;&lt;/a&gt;SSL&lt;/h1&gt;&lt;p&gt;SSL 即 Secure Sockets Layer，是提高信道安全性的协议。不使用 SSL 的 HTTP 通信，是不安全的，所有信</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>leveldb cache</title>
    <link href="https://codroc.github.io/2022/04/11/leveldb-cache/"/>
    <id>https://codroc.github.io/2022/04/11/leveldb-cache/</id>
    <published>2022-04-11T11:57:16.000Z</published>
    <updated>2022-04-11T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leveldb-笔记一：缓存系统-Cache"><a href="#leveldb-笔记一：缓存系统-Cache" class="headerlink" title="leveldb 笔记一：缓存系统 Cache"></a>leveldb 笔记一：缓存系统 Cache</h1><h3 id="LRUHandle"><a href="#LRUHandle" class="headerlink" title="LRUHandle"></a>LRUHandle</h3><blockquote><p>An entry is a variable length heap-allocated structure. 一个变长结构体对象，它被分配在堆上。</p></blockquote><p>LRUHandle 是 <strong>双向循环链表</strong>（为了实现 LRU 替换策略）的节点。在该链表上按访问时间排序。</p><p>变长体现在哪里？首先看它的结构体定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;</span><br><span class="line">  <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);</span><br><span class="line">  LRUHandle* next_hash;<span class="comment">// Hash 表指针，同样 Hash 值的 Handler 串接起来</span></span><br><span class="line">  LRUHandle* next;</span><br><span class="line">  LRUHandle* prev;</span><br><span class="line">  <span class="keyword">size_t</span> charge;  <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length;</span><br><span class="line">  <span class="keyword">bool</span> in_cache;     <span class="comment">// Whether entry is in the cache.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;     <span class="comment">// References, including cache reference, if present.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;     <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next is only equal to this if the LRU handle is the list head of an</span></span><br><span class="line">    <span class="comment">// empty list. List heads never have meaningful keys.</span></span><br><span class="line">    assert(next != <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Slice(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了 key_data 字段，其他都是固定长度的。因此可以这样认为，LRUHandle 是一个<strong>尾部长度可变</strong>的对象。</p><p><strong>存疑一：</strong>为什么不是 char* key_data 而是直接把 key 存储在 LRUHandle 中呢？为什么用 <code>char key_data[1]</code> 而不是 柔性数组 <code>char key_data[]</code></p><blockquote><p>Note:  GCC 由于对 C99 的支持，允许定义 char key_data[ ] 这样的柔性数组（Flexible Array)。但是由于 c++ 标准并不支持柔性数组的实现，这里定义为 key_data[1]，这也是 c++ 中的标准做法。</p></blockquote><p><strong>回答一：</strong>如果存的是指针，那么指针指向的 key 对象就也需要进行 malloc 分配空间，那么带上 LRUHandle 则需要 malloc 两次。如果把 key 对象和 LRUHandle 放在一块，只需要 malloc 一次，而 malloc 是有可能会陷入内核的，因此尽量减少 malloc 的次数，可以加快速度。</p><h3 id="HandleTable"><a href="#HandleTable" class="headerlink" title="HandleTable"></a>HandleTable</h3><p>它其实就是一个简单的 HashTable 先看它的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleTable</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">uint32_t</span> length_;</span><br><span class="line">    <span class="keyword">uint32_t</span> elems_;</span><br><span class="line">    LRUHandle** list_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它使用开链法来解决 hash 冲突，总共设置 length_ 个 bucket，每个 bucket 就是一条单向链表，每条链表的节点就是 LRUHandle，这里可以和 LRUHandle 结构体中的 next_hash 字段结合起来。elems_ 就表示了 HandleTable 中总共有多少个元素，可以用于之后对 hash table 进行 Resize。</p><p>刚开始 hash table 自然是空的，因此直接调用 Resize，进行初始化。</p><p>Resize 需要考虑两种情况：</p><ol><li>hash table 为空时进行 Resize</li><li>hash table 不为空时进行 Resize</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (new_length &lt; elems_) &#123;</span><br><span class="line">        new_length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">    <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="keyword">sizeof</span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// hash table 不为空时，需要考虑：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">        LRUHandle* h = list_[i];</span><br><span class="line">        <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            LRUHandle* next = h-&gt;next_hash; <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">uint32_t</span> hash = h-&gt;hash; <span class="comment">// 2</span></span><br><span class="line">            LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)]; <span class="comment">// 2</span></span><br><span class="line">            h-&gt;next_hash = *ptr;</span><br><span class="line">            *ptr = h;</span><br><span class="line">            h = next; <span class="comment">// 1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hash table 不为空时，需要考虑：</span></span><br><span class="line">    assert(elems_ == count);</span><br><span class="line">    <span class="keyword">delete</span>[] list_;</span><br><span class="line">    list_ = new_list;</span><br><span class="line">    length_ = new_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实要看懂这段代码，唯一的难点是理解 LRUHandle** 到底是个什么东西，它其实就是一个 数组，数组中的每一个元素就是 LRUHandle 链表<strong>头节点的指针</strong>。然后在 while 循环中使用的是 链表的 <strong>头插法</strong></p><p>接下来就是 Insert、Remove、Lookup 和 FindPointer，这里只需要看懂 FindPointer，其他的就自然看懂了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;key())) &#123;</span><br><span class="line">        ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ptr </code> 是单向链表头节点，这个在之前已经说过了。在这里 <code>LRUHandle** ptr = &amp;list_[hash &amp; (length_ - 1)];</code> 的确是这样的，但是在 while 循环中，<code>ptr</code> 已经不是这个意思了，它是 LRUHandle::next_hash 的地址；而 <code>*ptr</code> 仍然是指向 LRUHandle 节点的指针。自然，返回值也就是 LRUHandle::next_hash 的地址。<strong>因此在后续的 Insert、Remove 操作中，我们直接修改 <code>ptr</code> 所指地址处的值（也就是 LRUHandle::next_hash 的值）就可以达到我们需要的效果。</strong></p><h3 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h3><p>逻辑上，设计成列表，一个 Hash Table。两个列表用于存储 LRUHandle 节点，由循环双向链表来实现 LRU 替换策略，Hash Table 用于加速对节点的索引 O(1)，用开链法解决 hash 冲突。</p><p>两链表，一哈希表：</p><ul><li>LRUHandle <strong>lru_</strong> GUARDED_BY(mutex_); // 虚拟头节点</li><li>LRUHandle <strong>in_use_</strong> GUARDED_BY(mutex_); // 虚拟头节点</li><li>HandleTable <strong>table_</strong> GUARDED_BY(mutex_);</li></ul><p>这里两个链表的关系是这样的，我们可以把 LRUCache 内的 Handle 分为四个状态：</p><p><img src="https://s4.ax1x.com/2022/01/13/7MccTI.png"></p><ol><li>*in use (ref=2)*：该 Handle 在 HandleTable 中，并且串联在 <code>in_use_</code> 链表中；由于该 Handle 既被外部使用，也被 <code>in_use_</code> 链表使用，因此有 ref=2；</li><li>*in lru (ref=1)*：该 Handle 在 HandleTable 中，并且串联在 <code>lru_</code> 链表中；由于该 Handle 只被 <code>lru_</code> 引用，因此 ref=1；</li><li>*not in lru, not in table (ref=1)*：该 Handle 不在链表中也不再 HandleTable 中，但是仍然被外部引用而未释放，因此 ref=1；</li><li>*not in lru, not in table (ref=0)*：该 Handle 不在链表中也不再 HandleTable 中，也不被外部使用，因此 ref=0；</li></ol><p>在 LRUCache 析构时，必须保证 in_use 链表为空，也就是说<strong>没有被外部引用并且在链表中</strong>（即状态 1）的节点。之后，就可以对 lru_ 链表中的节点逐一 调用 Unref 来让节点的 deleter 去释放资源。</p><p>LRUCache 类中有一点很符合 morden c++ 的写法，也很值得我学习：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Cache::Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span></span>;</span><br><span class="line">    <span class="function">Cache::Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Cache::Handle* handle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Remove</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Append</span><span class="params">(LRUHandle* <span class="built_in">list</span>, LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">FinishErase</span><span class="params">(LRUHandle* e)</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <strong>公共接口</strong> 中，用 <code>Cache::Handle*</code> 来表示 <code>LRUHandle*</code>；而在 <strong>私有接口</strong> 中，仍旧保留 <code>LRUHandle*</code>；这其实是向外隐藏了 <code>LRUHandle*</code>；</p><h3 id="ShardedLRUCache"><a href="#ShardedLRUCache" class="headerlink" title="ShardedLRUCache"></a>ShardedLRUCache</h3><p>这个类其实就是用来减少 race condition 的，因为 leveldb 缓存系统支持并发，因此要对每一个 LRUCache 加互斥锁，如果只有一个 LRUCache 的话，虽然在外部看来是并发访问了，但是由于为了保证线程安全，在方法临界区内所有访问都被串行化了。但是如果对 Cache 进行分片，也就是增加 LRUCache 的数量（其实就是搞一个 LRUCache 数组），通过 hash 的方式索引到具体某一个 LRUCache 进行访问，这样 LRUCache 之间是可以并行访问并保证线程安全的，这就提高了整个缓存系统的并发性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LRUCache shard_[kNumShards]; <span class="comment">// 分片缓存，通过 hash 方式来索引到某一个 LRUCache</span></span><br><span class="line">    port::Mutex id_mutex_;</span><br><span class="line">    <span class="keyword">uint64_t</span> last_id_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leveldb-笔记一：缓存系统-Cache&quot;&gt;&lt;a href=&quot;#leveldb-笔记一：缓存系统-Cache&quot; class=&quot;headerlink&quot; title=&quot;leveldb 笔记一：缓存系统 Cache&quot;&gt;&lt;/a&gt;leveldb 笔记一：缓存系统 Cac</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试手撕算法记录</title>
    <link href="https://codroc.github.io/2022/04/08/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/"/>
    <id>https://codroc.github.io/2022/04/08/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-08T11:57:16.000Z</published>
    <updated>2022-04-08T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手撕算法记录"><a href="#手撕算法记录" class="headerlink" title="手撕算法记录"></a>手撕算法记录</h1><h3 id="4-月-8-日-华为云"><a href="#4-月-8-日-华为云" class="headerlink" title="4 月 8 日 华为云"></a>4 月 8 日 华为云</h3><p>给定一个 n 位的 01 串，提供两种变换方法：00–&gt;10，10–&gt;01</p><p>样例：</p><p>0010 –&gt; 1101</p><ol><li>0010–&gt;1010</li><li>1010–&gt;1001</li><li>1001–&gt;1101</li></ol><p>碰到的难题：10 可能会变到 01；什么情况下回去这么变，是为了让 00 变成 10；</p><p>刚开始没思路，面试官给提示：00 变到 10 是没代价的，而 10 变 01 是要看时机的，出现 010 这种情况时可以让 10 变 01；刚开始写的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="number">4</span></span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="built_in">string</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>     <span class="built_in">string</span> ret;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size(); ++i) &#123;</span><br><span class="line"> <span class="number">8</span>         <span class="keyword">char</span> c = s[i];</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line"><span class="number">10</span>             ret.push_back(c);</span><br><span class="line"><span class="number">11</span>             <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">12</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">13</span>             <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.size()) &#123;</span><br><span class="line"><span class="number">14</span>                 <span class="keyword">if</span> (s[i+<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="number">15</span>                     ret.push_back(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="number">16</span>                 <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">17</span>                     <span class="keyword">if</span> (i + <span class="number">2</span> &lt; s.size() &amp;&amp; s[i+<span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line"><span class="number">18</span>                         ret.append(<span class="string">&quot;101&quot;</span>);</span><br><span class="line"><span class="number">19</span>                         i += <span class="number">2</span>;</span><br><span class="line"><span class="number">20</span>                     &#125;</span><br><span class="line"><span class="number">21</span>                 &#125;</span><br><span class="line"><span class="number">22</span>             &#125;</span><br><span class="line"><span class="number">23</span>         &#125;</span><br><span class="line"><span class="number">24</span>     &#125;</span><br><span class="line"><span class="number">25</span>     <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">26</span> &#125;</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">29</span>     <span class="built_in">string</span> s = <span class="string">&quot;0000&quot;</span>;</span><br><span class="line"><span class="number">30</span>     <span class="built_in">string</span> ret = func(s);</span><br><span class="line"><span class="number">31</span>     <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="number">32</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">33</span> &#125;</span><br></pre></td></tr></table></figure><p>然后面试官提示 18 行和 13 行出错。然后我还想了一会，哎，无语~~~~</p><p>如果是 010 的情况下不是无脑把 101 压入 ret，而应该把 1 压入，然后后续再如循环进行处理。 i + 1 &lt; s.size() 不满足时如果直接返回，会导致 0000 这样的测试过不了，即最后一个字符得不到处理。</p><p>改正后的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="number">4</span></span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="built_in">string</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; tmp)</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>     <span class="built_in">string</span> s = tmp;</span><br><span class="line"> <span class="number">7</span>     <span class="built_in">string</span> ret;</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size(); ++i) &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">char</span> c = s[i];</span><br><span class="line"><span class="number">10</span>         <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123; <span class="comment">// 1</span></span><br><span class="line"><span class="number">11</span>             ret.push_back(c);</span><br><span class="line"><span class="number">12</span>             <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">13</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">14</span>             <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.size()) &#123;</span><br><span class="line"><span class="number">15</span>                 <span class="keyword">if</span> (s[i+<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="comment">// 00</span></span><br><span class="line"><span class="number">16</span>                     ret.push_back(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="number">17</span>                 <span class="keyword">else</span> &#123; <span class="comment">// 01</span></span><br><span class="line"><span class="number">18</span>                     <span class="keyword">if</span> (i + <span class="number">2</span> &lt; s.size()) &#123;</span><br><span class="line"><span class="number">19</span>                         <span class="keyword">if</span> (s[i + <span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 010</span></span><br><span class="line"><span class="number">20</span>                             ret.push_back(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="number">21</span>                             s[i + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="number">22</span>                             s[i + <span class="number">2</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="number">23</span>                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">24</span>                             <span class="comment">// 011</span></span><br><span class="line"><span class="number">25</span>                             ret.push_back(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="number">26</span>                         &#125;</span><br><span class="line"><span class="number">27</span>                     &#125; <span class="keyword">else</span> ret.push_back(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="number">28</span>                 &#125;</span><br><span class="line"><span class="number">29</span>             &#125; <span class="keyword">else</span> ret.push_back(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="number">30</span>         &#125;</span><br><span class="line"><span class="number">31</span>     &#125;</span><br><span class="line"><span class="number">32</span>     <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">33</span> &#125;</span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">35</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">36</span>     <span class="built_in">string</span> s = <span class="string">&quot;0000&quot;</span>;</span><br><span class="line"><span class="number">37</span>     <span class="built_in">string</span> ret = func(s);</span><br><span class="line"><span class="number">38</span>     <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="number">39</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">40</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手撕算法记录&quot;&gt;&lt;a href=&quot;#手撕算法记录&quot; class=&quot;headerlink&quot; title=&quot;手撕算法记录&quot;&gt;&lt;/a&gt;手撕算法记录&lt;/h1&gt;&lt;h3 id=&quot;4-月-8-日-华为云&quot;&gt;&lt;a href=&quot;#4-月-8-日-华为云&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cs144 lab3 the TCP sender</title>
    <link href="https://codroc.github.io/2022/04/02/cs144_lab3/"/>
    <id>https://codroc.github.io/2022/04/02/cs144_lab3/</id>
    <published>2022-04-02T11:57:16.000Z</published>
    <updated>2022-04-02T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144-lab3-the-TCP-sender"><a href="#cs144-lab3-the-TCP-sender" class="headerlink" title="cs144 lab3: the TCP sender"></a>cs144 lab3: the TCP sender</h1><p>在前面的实验中，我们已经接触到了，seqno、ackno、SYN、FIN 标志、checksum 等技术。这个实验涉及到一个重要技术：<strong>超时重传</strong>。这是解决不可靠网络出现分组丢失问题的重要技术之一。</p><p>如何在可能丢失分组的不可靠网络之上进行可靠传输？<strong>ARQ 协议！</strong></p><h4 id="停等-ARQ-协议"><a href="#停等-ARQ-协议" class="headerlink" title="停等 ARQ 协议"></a>停等 ARQ 协议</h4><p>停止并等待协议的工作原理如下：</p><ol><li>发送点对接收点发送数据包，然后等待接收点回复ACK并且开始计时。</li><li>在等待过程中，发送点停止发送新的数据包。</li><li>当数据包没有成功被接收点接收时候，接收点不会发送ACK.这样发送点在等待一定时间后，重新发送数据包。</li><li>反复以上步骤直到收到从接收点发送的ACK.</li></ol><h4 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h4><p>为了克服停止并等待ARQ协议长时间等待ACK的缺点。这个协议会连续发送一组数据包，然后再等待这些数据包的ACK.</p><p>本实验的实现是 <strong>连续 ARQ 协议</strong>。</p><p>需要注意的点：</p><ul><li>SYN、FIN 也会占用窗口空间</li><li>根据 receiver 发来的 segment 来设置 sender 的窗口；发第一个 syn segment 前，将 sender 的窗口设置为 1</li><li>当 peer 的窗口大小为 0 时，把发送窗口大小设置为 1</li></ul><h4 id="一些疑惑的点："><a href="#一些疑惑的点：" class="headerlink" title="一些疑惑的点："></a><strong>一些疑惑的点：</strong></h4><p>receiver 会发回来一个 <strong>ackno</strong> 和 <strong>windown_size</strong> 。<strong>receiver 发回的 ackno 表示的是 ackno 之前的所有 segment 都已经被成功接收并 reassemble</strong>。这也就是说对与一个 ByteStream 而言，receiver 已经把 [0, unwrap(ackno, isn, checkpoint) ) 范围的元素（在这里就是一个字节） reassemble 了！并且 receiver 还可以接受 [unwrap(ackno, isn, checkpoint), unwrap(ackno, isn, checkpoint) + window_size) 范围的元素，那么对于 sender 来说，它能的发送 ByteStream 的范围就是 [_next_seqno, unwrap(ackno, isn, checkpoint) + window_size)；也就是说发送窗口大小是 <code>unwrap(ackno, isn, checkpoint) + window_size - _next_seqno</code>。</p><p>本实验对于超时的 segment 的处理是这样的：仅仅设置一个定时器（<em>注意不是像 SR 中那样每一个 segment 都设一个 timer</em>），如果超时了，就重传最早的那个（seqno 最靠前的）segment，并把 RTO 乘倍。 </p><p><strong>sender 要发哪些东西给 peer？</strong></p><p>首先 payload 肯定是要发的；其次是 header 中的一些字段：SYN、FIN，seqno；</p><p>sender 的发送窗口大小就没必要发了，因为本来就是 receiver 来控制 sender 能够发多少数据，sender 控制不了 receiver！</p><p><strong>何时开启一个 timer ？</strong></p><ul><li>当带有负载或带有 SYN、FIN 标志的 segment 被发送时，就要开启 timer，<strong>因为这些 segment 都是占用了 absolut seqno 的 segment，要保证这些 segment 可靠送达对端！</strong></li><li>超时重传时要重启 timer</li></ul><p><strong>为什么超时的时候 RTO 要乘倍增长或保持不变？</strong></p><p>讲一下自己的理解：因为，如果是因为网络环境差导致的分组丢失，从而导致超时，那么我们应该尽量降低重传频率，不然网络环境会更加不堪重负，这时候就要乘倍增长 RTO 让重传频率降低；如果不是因为网络环境差，而是因为 receiver 处理数据太慢（即 ByteStream 中的数据迟迟没有读走），导致窗口大小变为 0，如果此时发送方傻傻的把发送窗口变成 0，而 receiver 又不继续发响应，那么当 receiver 的接收窗口大于 0 时，发送方无法得知，由于发送方窗口一直为 0 而导致通信被阻塞了（有没有这种可能？）。。。所以当 receiver 窗口为 0 时，而发送方仍有东西要发送时（即占用 absolute sequence number），让发送窗口为 1，这样发送方会不断向 receiver 发送一个字节，而此时 receiver 因为接收窗口为 0 而无法接收（直接不理会收到的 segment）导致发送方超时，由于这时候的超时不是网络环境导致的，所以让 RTO 保持原样是合理的！</p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p>经过大概 10 次左右的 <code>make check_lab3</code> 终于通过了所有测试用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Test project &#x2F;home&#x2F;cs144&#x2F;sponge&#x2F;build</span><br><span class="line">      Start  1: t_wrapping_ints_cmp</span><br><span class="line"> 1&#x2F;33 Test  #1: t_wrapping_ints_cmp ..............   Passed    0.00 sec</span><br><span class="line">      Start  2: t_wrapping_ints_unwrap</span><br><span class="line"> 2&#x2F;33 Test  #2: t_wrapping_ints_unwrap ...........   Passed    0.00 sec</span><br><span class="line">      Start  3: t_wrapping_ints_wrap</span><br><span class="line"> 3&#x2F;33 Test  #3: t_wrapping_ints_wrap .............   Passed    0.00 sec</span><br><span class="line">      Start  4: t_wrapping_ints_roundtrip</span><br><span class="line"> 4&#x2F;33 Test  #4: t_wrapping_ints_roundtrip ........   Passed    0.12 sec</span><br><span class="line">      Start  5: t_recv_connect</span><br><span class="line"> 5&#x2F;33 Test  #5: t_recv_connect ...................   Passed    0.00 sec</span><br><span class="line">      Start  6: t_recv_transmit</span><br><span class="line"> 6&#x2F;33 Test  #6: t_recv_transmit ..................   Passed    0.03 sec</span><br><span class="line">      Start  7: t_recv_window</span><br><span class="line"> 7&#x2F;33 Test  #7: t_recv_window ....................   Passed    0.00 sec</span><br><span class="line">      Start  8: t_recv_reorder</span><br><span class="line"> 8&#x2F;33 Test  #8: t_recv_reorder ...................   Passed    0.00 sec</span><br><span class="line">      Start  9: t_recv_close</span><br><span class="line"> 9&#x2F;33 Test  #9: t_recv_close .....................   Passed    0.00 sec</span><br><span class="line">      Start 10: t_recv_special</span><br><span class="line">10&#x2F;33 Test #10: t_recv_special ...................   Passed    0.00 sec</span><br><span class="line">      Start 11: t_send_connect</span><br><span class="line">11&#x2F;33 Test #11: t_send_connect ...................   Passed    0.00 sec</span><br><span class="line">      Start 12: t_send_transmit</span><br><span class="line">12&#x2F;33 Test #12: t_send_transmit ..................   Passed    0.03 sec</span><br><span class="line">      Start 13: t_send_retx</span><br><span class="line">13&#x2F;33 Test #13: t_send_retx ......................   Passed    0.00 sec</span><br><span class="line">      Start 14: t_send_window</span><br><span class="line">14&#x2F;33 Test #14: t_send_window ....................   Passed    0.01 sec</span><br><span class="line">      Start 15: t_send_ack</span><br><span class="line">15&#x2F;33 Test #15: t_send_ack .......................   Passed    0.00 sec</span><br><span class="line">      Start 16: t_send_close</span><br><span class="line">16&#x2F;33 Test #16: t_send_close .....................   Passed    0.00 sec</span><br><span class="line">      Start 17: t_send_extra</span><br><span class="line">17&#x2F;33 Test #17: t_send_extra .....................   Passed    0.00 sec</span><br><span class="line">      Start 18: t_strm_reassem_single</span><br><span class="line">18&#x2F;33 Test #18: t_strm_reassem_single ............   Passed    0.00 sec</span><br><span class="line">      Start 19: t_strm_reassem_seq</span><br><span class="line">19&#x2F;33 Test #19: t_strm_reassem_seq ...............   Passed    0.00 sec</span><br><span class="line">      Start 20: t_strm_reassem_dup</span><br><span class="line">20&#x2F;33 Test #20: t_strm_reassem_dup ...............   Passed    0.00 sec</span><br><span class="line">      Start 21: t_strm_reassem_holes</span><br><span class="line">21&#x2F;33 Test #21: t_strm_reassem_holes .............   Passed    0.00 sec</span><br><span class="line">      Start 22: t_strm_reassem_many</span><br><span class="line">22&#x2F;33 Test #22: t_strm_reassem_many ..............   Passed    0.04 sec</span><br><span class="line">      Start 23: t_strm_reassem_overlapping</span><br><span class="line">23&#x2F;33 Test #23: t_strm_reassem_overlapping .......   Passed    0.00 sec</span><br><span class="line">      Start 24: t_strm_reassem_win</span><br><span class="line">24&#x2F;33 Test #24: t_strm_reassem_win ...............   Passed    0.03 sec</span><br><span class="line">      Start 25: t_strm_reassem_cap</span><br><span class="line">25&#x2F;33 Test #25: t_strm_reassem_cap ...............   Passed    0.05 sec</span><br><span class="line">      Start 26: t_byte_stream_construction</span><br><span class="line">26&#x2F;33 Test #26: t_byte_stream_construction .......   Passed    0.00 sec</span><br><span class="line">      Start 27: t_byte_stream_one_write</span><br><span class="line">27&#x2F;33 Test #27: t_byte_stream_one_write ..........   Passed    0.00 sec</span><br><span class="line">      Start 28: t_byte_stream_two_writes</span><br><span class="line">28&#x2F;33 Test #28: t_byte_stream_two_writes .........   Passed    0.00 sec</span><br><span class="line">      Start 29: t_byte_stream_capacity</span><br><span class="line">29&#x2F;33 Test #29: t_byte_stream_capacity ...........   Passed    0.28 sec</span><br><span class="line">      Start 30: t_byte_stream_many_writes</span><br><span class="line">30&#x2F;33 Test #30: t_byte_stream_many_writes ........   Passed    0.00 sec</span><br><span class="line">      Start 53: t_address_dt</span><br><span class="line">31&#x2F;33 Test #53: t_address_dt .....................   Passed    5.03 sec</span><br><span class="line">      Start 54: t_parser_dt</span><br><span class="line">32&#x2F;33 Test #54: t_parser_dt ......................   Passed    0.00 sec</span><br><span class="line">      Start 55: t_socket_dt</span><br><span class="line">33&#x2F;33 Test #55: t_socket_dt ......................   Passed    0.00 sec</span><br></pre></td></tr></table></figure><p>代码如下：</p><p>重传定时器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RTimer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RTimer() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">        _time_out = to;</span><br><span class="line">        _started = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; _started = <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">time_out</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _time_out; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_time_out</span><span class="params">(<span class="keyword">size_t</span> t)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _started &amp;&amp; t &gt;= _time_out; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">started</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _started; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> _started&#123;&#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span> _time_out&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TCPSender 类中，自己添加的 private 变量 和 方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPSender</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">// my code:</span></span><br><span class="line">     RTimer _timer;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TCPSegment&gt; _outstandings;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">size_t</span> _ms_since_alive&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> _rtx&#123;&#125;; <span class="comment">// consective retransmission times</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">uint64_t</span> _checkpoint&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">uint16_t</span> _win_size&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> _rto; <span class="comment">// retransmission time out</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">bool</span> _peer_busy&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">uint64_t</span> _bytes_in_flight&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">bool</span> _fin_sended&#123;&#125;;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     <span class="function">TCPSegment <span class="title">make_segment</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span></span>;</span><br><span class="line">     <span class="function">WrappingInt32 <span class="title">get_seqno</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">uint64_t</span> <span class="title">get_absolute_seqno</span><span class="params">(WrappingInt32, WrappingInt32, <span class="keyword">uint64_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">space_available</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _win_size &gt; <span class="number">0</span>; &#125;</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">is_peer_busy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _peer_busy; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">send_and_store</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TCPSender 接口的具体实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">TCPSender::TCPSender(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity, <span class="keyword">const</span> <span class="keyword">uint16_t</span> retx_timeout, <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;WrappingInt32&gt; fixed_isn)</span><br><span class="line">     : _isn(fixed_isn.value_or(WrappingInt32&#123;random_device()()&#125;))</span><br><span class="line">     , _initial_retransmission_timeout&#123;retx_timeout&#125;</span><br><span class="line">     , _stream(capacity)</span><br><span class="line">     , _timer()</span><br><span class="line">     , _outstandings()</span><br><span class="line">     , _rto(retx_timeout)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">uint64_t</span> <span class="title">TCPSender::bytes_in_flight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> _bytes_in_flight;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!space_available()) <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">// size_t last_size = _outstandings.size();</span></span><br><span class="line">     <span class="keyword">if</span> (_next_seqno == <span class="number">0</span>) &#123; <span class="comment">// 前两次握手</span></span><br><span class="line">         <span class="keyword">size_t</span> can_read = <span class="built_in">std</span>::min(TCPConfig::MAX_PAYLOAD_SIZE,</span><br><span class="line">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>&amp;&gt;(_win_size - <span class="number">1</span>)); <span class="comment">// 预留一个字节给 syn</span></span><br><span class="line">         send_and_store(_stream.read(can_read), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_stream.input_ended() &amp;&amp; !_fin_sended) &#123; <span class="comment">// 后面四次挥手</span></span><br><span class="line">         <span class="comment">// 判断何时发送 fin</span></span><br><span class="line">         <span class="keyword">if</span> (_win_size &gt;= _stream.buffer_size() + <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="comment">// 刚好能把 fin 塞入</span></span><br><span class="line">             send_and_store(_stream.read(_win_size), <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">             _fin_sended = <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 仅传输 payload</span></span><br><span class="line">     <span class="keyword">while</span> (!_stream.buffer_empty() &amp;&amp; space_available()) &#123;</span><br><span class="line">         <span class="keyword">size_t</span> can_read = <span class="built_in">std</span>::min(TCPConfig::MAX_PAYLOAD_SIZE,</span><br><span class="line">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>&amp;&gt;(_win_size));</span><br><span class="line">         send_and_store(_stream.read(can_read), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 因为 ack_received 后会调用一次 fill_window 因此判断下是否已经 FIN_ACKED，如果 FIN_ACKED 了，那么 _outstandings 肯定为空</span></span><br><span class="line">     <span class="keyword">if</span> (!_timer.started() &amp;&amp; !_outstandings.empty())</span><br><span class="line">         _timer.start(_ms_since_alive + _rto);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"> <span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="keyword">const</span> WrappingInt32 ackno, <span class="keyword">const</span> <span class="keyword">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">uint64_t</span> left = get_absolute_seqno(ackno, _isn, _checkpoint);</span><br><span class="line">     <span class="keyword">if</span> (left &gt; _next_seqno) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">uint64_t</span> right = left + window_size;</span><br><span class="line">     _win_size = right - _next_seqno;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (window_size == <span class="number">0</span>) &#123; _peer_busy = <span class="literal">true</span>; _win_size = <span class="number">1</span>; &#125;</span><br><span class="line">     <span class="keyword">else</span> _peer_busy = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">bool</span> has_new_data = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">while</span> (!_outstandings.empty()) &#123;</span><br><span class="line">         TCPSegment segment = _outstandings.front();</span><br><span class="line">         <span class="keyword">uint64_t</span> ab_seqno = get_absolute_seqno(segment.header().seqno, _isn, _checkpoint);</span><br><span class="line">         <span class="keyword">uint16_t</span> length = segment.length_in_sequence_space();</span><br><span class="line">         <span class="keyword">if</span> (ab_seqno + length &gt; left)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         has_new_data = <span class="literal">true</span>;</span><br><span class="line">         _outstandings.pop();</span><br><span class="line">         _bytes_in_flight -= length;</span><br><span class="line"></span><br><span class="line">         _rto = _initial_retransmission_timeout;</span><br><span class="line">         _rtx = <span class="number">0</span>;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">if</span> (_outstandings.empty()) _timer.stop();</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(has_new_data) _timer.start(_ms_since_alive + _rto);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (_outstandings.empty()) <span class="keyword">return</span>;</span><br><span class="line">     _ms_since_alive += ms_since_last_tick;</span><br><span class="line">     <span class="keyword">if</span> (_timer.is_time_out(_ms_since_alive)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (is_peer_busy()) &#123;</span><br><span class="line">             <span class="comment">// 如果是对端繁忙的情况，即 发送端还有数据发，但 receiver 窗口变成 0</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 网络环境差导致丢包或延迟送达</span></span><br><span class="line">             _rtx++;</span><br><span class="line">             _rto *= <span class="number">2</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 重传最早的那个 segment，并重启定时器</span></span><br><span class="line">         <span class="comment">// assert(!_outstandings.empty()); // 一定非空</span></span><br><span class="line">         _segments_out.push(_outstandings.front());</span><br><span class="line">         <span class="comment">// _outstandings.pop();</span></span><br><span class="line">         _timer.start(_ms_since_alive + _rto);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _rtx; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     _segments_out.push(make_segment(<span class="string">&quot;&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">TCPSegment <span class="title">TCPSender::make_segment</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span> </span>&#123;</span><br><span class="line">     TCPSegment segment;</span><br><span class="line">     segment.payload() = <span class="built_in">std</span>::move(payload);</span><br><span class="line">     segment.header().seqno = get_seqno();</span><br><span class="line">     segment.header().syn = syn;</span><br><span class="line">     segment.header().fin = fin;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// _next_seqno += segment.length_in_sequence_space();</span></span><br><span class="line">     <span class="keyword">return</span> segment;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">WrappingInt32 <span class="title">TCPSender::get_seqno</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> wrap(_next_seqno, _isn);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">TCPSender::get_absolute_seqno</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="keyword">uint64_t</span> checkpoint)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> unwrap(n, isn, checkpoint);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::send_and_store</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span> </span>&#123;</span><br><span class="line">     TCPSegment segment = make_segment(<span class="built_in">std</span>::move(payload), syn, fin);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// send</span></span><br><span class="line">     <span class="keyword">uint64_t</span> length = segment.length_in_sequence_space();</span><br><span class="line">     _segments_out.push(segment);</span><br><span class="line">     _next_seqno += length;</span><br><span class="line">     _win_size -= length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// store</span></span><br><span class="line">     _outstandings.push(segment);</span><br><span class="line">     _bytes_in_flight += length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// update checkpoint</span></span><br><span class="line">     _checkpoint = _next_seqno;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144-lab3-the-TCP-sender&quot;&gt;&lt;a href=&quot;#cs144-lab3-the-TCP-sender&quot; class=&quot;headerlink&quot; title=&quot;cs144 lab3: the TCP sender&quot;&gt;&lt;/a&gt;cs144 lab3</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cs144 lab1 Stitching substrings into a byte stream</title>
    <link href="https://codroc.github.io/2022/03/27/cs144-lab1/"/>
    <id>https://codroc.github.io/2022/03/27/cs144-lab1/</id>
    <published>2022-03-27T11:57:16.000Z</published>
    <updated>2022-03-27T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144-lab1-stitching-substrings-into-a-byte-stream"><a href="#cs144-lab1-stitching-substrings-into-a-byte-stream" class="headerlink" title="cs144 lab1: stitching substrings into a byte stream"></a>cs144 lab1: stitching substrings into a byte stream</h1><p>预备知识：《计算机网络自顶向下方法》——3.4 可靠数据传输原理</p><p>复习下如何构造一个可靠数据传输协议，书中是基于三种假设，逐层递进地讲解的。</p><ul><li>rdt1.0：该协议假设底层信道完全可靠</li><li>rdt2.0：该协议假设底层信道不可靠，但仅仅会导致 datagram 的比特位出错，而不会导致任何丢失</li><li>rdt3.0：该协议假设底层信道完全不可靠，既会导致 datagram 的比特位出错，也可能导致整个包丢失</li></ul><p>对于 rdt1.0，没啥好说的。</p><h2 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h2><p>该协议要应对存在 bit 出错的可能，因此引入了以下功能：</p><ul><li>差错检验</li><li>接收方反馈</li><li>重传</li></ul><p>对于 rdt2.0 由于会存在 bit 出错的情况，因此引入一个 checksum，根据查错纠错算法和 checksum 来判断接收到的 datagram 是否有 bit 出错。</p><p>如果存在 bit 出错，那么接收方就要发送一个 NACK 给发送方，用来表示 “你发了的信息在途中遭到了破坏！请重新发送！”；如果没有 bit 出错，那么接收方就发一个 ACK 给发送方，用来表示 “我接受到了你发的信息！” 其实这里还有一个需要考虑的地方，那就是：<strong>接收方必须能够分辨出，接收到的 datagram 是发送方重传的还是最新的！</strong> 这里可以引入一个 <strong>1 bit 的序号</strong>，每次发送新的信息时进行 0，1 转换就可以分辨出发来的是新消息还是重传的消息了。</p><p>发送方，发送/重传一个消息后，必须等待接收方的反馈。并根据接收方的反馈做出具体的操作。如果收到 ACK，则发送新消息，并把新消息中的序号位反转一下以表示新消息；如果是 NACK，那么就重传旧消息。</p><h2 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h2><p>该协议不仅仅要应对 bit 出错的情况，还要应对分组丢失的情况，因此在 rdt2.0 的基础上又引入了以下功能：</p><ul><li>定时器</li></ul><p>由于发出去的消息可能在网络中丢失，那么如果让发送方不断地等待接收方的反馈，可能会导致等到地老天荒也没等来反馈。这是如果引入一个定时器，如果在规定的时间内没有收到反馈就可以简单地认为 datagram 在网络中丢失了！那么发送方就对旧消息进行重传。</p><p>但是可能信息并没有丢失，而是网络太拥堵导致它迟到了，而此时发送方已经重传了，那么这会导致冗余分组。</p><p>总结下：<strong>checksum，序号，ACK，定时器和重传</strong>等技术确保了在不可靠网络上进行可靠传输。</p><h1 id="缝合字符串"><a href="#缝合字符串" class="headerlink" title="缝合字符串"></a>缝合字符串</h1><p>回归主题，本次 lab 就是为之后的 <code>TCPReceiver</code> 做准备的。</p><p>主要是设计一个 <code>StreamReassembler</code> 把字符串碎片重新组合成一个有序的字节流 <code>ByteStream</code>，首先对字符碎片进行定义：</p><ul><li>字符碎片取自 ByteStream</li><li>字符碎片 A 和字符碎片 B 可能重叠</li><li>当字符碎片可以被 assemble 时立刻组装并交付给 ByteStream</li></ul><p>可以参考下面的图：</p><p><img src="https://s1.ax1x.com/2022/03/27/qwOpkV.png"></p><p>对于第一个定义，它想表达的是字符碎片是 ByteStream 的子串。</p><p>对于第二个定义，如果 ByteStream = “abcdefghi” 那么 A、B 可能是：A = “bcde”、B = “def”；即 A和B之间存在重叠。</p><p>对于第三个定义，什么情况下字符碎片可以被 assemble？那就是当前字符碎片的 index 是 rcv_base 的时候（这个 rcv_base 请去看《计算机网络自顶向下》3.4.4 节 图 3-23）。举个例子，我们已经收到字符碎片 A 和 B了（A、B的值和上面一样），那么可以把A 和B合并成 “bcdef”，但是由于现在的 rcv_base = 0，也就是 “a” 的index，所以不能 assemble；直到 rcv_base = 1 时我们才能把 “bcdef” 交付给 ByteStream。</p><p>就像上图，<code>first unassembled</code> 到 <code>first unacceptable</code> 的区间内，可以看到一段一段的红色，每一段都表明了一个被合并过的字符碎片，每个字符碎片都是 ByteStream 的子串。而绿色的是已经有序且连续的但未被读走的 ByteStream 子串。</p><p>其实这里就已经有 <strong>TCP 接收缓冲区（对应 ByteStream）</strong>以及<strong>滑动窗口（对应 StreamReassembler）</strong>的感觉了！</p><p>在代码实现方面，最难的是如何对<strong>接收到的字符串碎片</strong>与已经存储<strong>在 <code>first unassembled</code> 到 <code>first unacceptable</code> 的区间内的字符串碎片</strong>进行<strong>合并</strong>，这个合并涉及到了对碎片的去重叠。所以说这个 lab 更像是在做一道算法题。。。。。。</p><p>这个算法可以参考，OS 对内存页回收时要进行操作，它也要判断是否可以和前后页进行合并！但这里更加复杂，内存页的合并只需要考虑前一个页与后一个页，而这里需要考虑多个字符串碎片，因为可能存在 A = “bcd”、B = “f”、C = “hi” 然后收到了 “abcdefgh” 的情况~~~</p><p>可以把要进行合并（merge）的字符串碎片和合并会涉及到字符串碎片抽象成如下图所示：</p><p><img src="https://s1.ax1x.com/2022/03/27/qwxSu4.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::merge</span><span class="params">(StreamReassembler::Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_aux_storage.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        _aux_storage.insert(node);</span><br><span class="line">        _unassembled_bytes += node.length;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pre = _aux_storage.lower_bound(node);</span><br><span class="line">    <span class="keyword">if</span> (pre == _aux_storage.end()) &#123;</span><br><span class="line">        <span class="comment">// 有前，无后</span></span><br><span class="line">        --pre;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;end() &lt; node.index) &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            _aux_storage.insert(node);</span><br><span class="line">            update_unassembled_bytes(_aux_storage.end(), _aux_storage.end(), node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;end() &lt; node.end()) &#123;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> tmp = *pre-&gt;spStr +</span><br><span class="line">                node.spStr-&gt;substr(pre-&gt;end() - node.index);</span><br><span class="line">            node.spStr.reset(</span><br><span class="line">                    <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="built_in">std</span>::move(tmp))</span><br><span class="line">                    );</span><br><span class="line">            node.index = pre-&gt;index;</span><br><span class="line">            node.length = node.spStr-&gt;size();</span><br><span class="line"></span><br><span class="line">            _aux_storage.erase(pre);</span><br><span class="line">            _aux_storage.insert(node);</span><br><span class="line">            <span class="keyword">auto</span> begin = pre;</span><br><span class="line">            <span class="keyword">auto</span> end   = ++pre;</span><br><span class="line">            update_unassembled_bytes(begin, end, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre == _aux_storage.begin()) &#123;</span><br><span class="line">        <span class="comment">// 无前</span></span><br><span class="line">        <span class="keyword">auto</span> it = pre;</span><br><span class="line">        <span class="keyword">while</span> (it != _aux_storage.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;end() &gt; node.end()) <span class="keyword">break</span>;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it == _aux_storage.end()) <span class="comment">// 1</span></span><br><span class="line">            update_storage(_aux_storage.begin(), _aux_storage.end(), node);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;index &gt; node.end()) <span class="comment">// 2</span></span><br><span class="line">            update_storage(pre, it, node);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 3</span></span><br><span class="line">            node.spStr.reset(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*node.spStr + it-&gt;spStr-&gt;substr(node.end() - it-&gt;index)));</span><br><span class="line">            node.length = node.spStr-&gt;size();</span><br><span class="line">            ++it;</span><br><span class="line">            update_storage(pre, it, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// pre 在中间</span></span><br><span class="line">        <span class="keyword">auto</span> it = pre;</span><br><span class="line">        <span class="keyword">while</span> (it != _aux_storage.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;end() &gt; node.end()) <span class="keyword">break</span>;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it == _aux_storage.end()) &#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">// 有前，无后</span></span><br><span class="line">            <span class="keyword">auto</span> t = --pre;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;end() &lt; node.index) &#123; <span class="comment">// 1_1</span></span><br><span class="line">                ++t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 1_2</span></span><br><span class="line">                node.spStr.reset(</span><br><span class="line">                        <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*t-&gt;spStr +</span><br><span class="line">                            node.spStr-&gt;substr(</span><br><span class="line">                                t-&gt;end() - node.index</span><br><span class="line">                                )</span><br><span class="line">                            )</span><br><span class="line">                        );</span><br><span class="line">                node.index = t-&gt;index;</span><br><span class="line">            &#125;</span><br><span class="line">            update_storage(t, it, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="comment">// 有前，有后</span></span><br><span class="line">            <span class="keyword">auto</span> a = --pre;</span><br><span class="line">            <span class="keyword">auto</span> b = it;</span><br><span class="line">            <span class="keyword">if</span> (a-&gt;end() &lt; node.index &amp;&amp; node.end() &lt; b-&gt;index) &#123; <span class="comment">// 2_1</span></span><br><span class="line">                ++a;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;end() &lt; node.index) &#123; <span class="comment">// 2_2</span></span><br><span class="line">                node.spStr.reset(</span><br><span class="line">                        <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*node.spStr +</span><br><span class="line">                            b-&gt;spStr-&gt;substr(</span><br><span class="line">                                node.end() - b-&gt;index</span><br><span class="line">                                )</span><br><span class="line">                            )</span><br><span class="line">                        );</span><br><span class="line">                node.length = node.spStr-&gt;size();</span><br><span class="line"></span><br><span class="line">                ++a;</span><br><span class="line">                ++b;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.end() &lt; b-&gt;index) &#123; <span class="comment">// 2_3</span></span><br><span class="line">                <span class="keyword">if</span> (a-&gt;end() &gt;= node.end()) <span class="keyword">return</span>;</span><br><span class="line">                node.spStr.reset(</span><br><span class="line">                        <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*a-&gt;spStr +</span><br><span class="line">                            node.spStr-&gt;substr(</span><br><span class="line">                                a-&gt;end() - node.index</span><br><span class="line">                                )</span><br><span class="line">                            )</span><br><span class="line">                        );</span><br><span class="line">                node.index = a-&gt;index;</span><br><span class="line">                node.length = node.spStr-&gt;size();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2_4</span></span><br><span class="line">                node.spStr.reset(</span><br><span class="line">                        <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*a-&gt;spStr +</span><br><span class="line">                            node.spStr-&gt;substr(</span><br><span class="line">                                a-&gt;end() - node.index</span><br><span class="line">                                ) +</span><br><span class="line">                            b-&gt;spStr-&gt;substr(node.end() - b-&gt;index)</span><br><span class="line">                            )</span><br><span class="line">                        );</span><br><span class="line">                node.index = a-&gt;index;</span><br><span class="line">                node.length = node.spStr-&gt;size();</span><br><span class="line"></span><br><span class="line">                ++b;</span><br><span class="line">            &#125;</span><br><span class="line">            update_storage(a, b, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的代码都是很简单的逻辑啦~~~~</p><p>这里是功能定义：<code>stream_reassembler.hh</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamReassembler</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">         Node(<span class="keyword">size_t</span> idx, <span class="keyword">uint32_t</span> l, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; sp)</span><br><span class="line">             : index(idx),</span><br><span class="line">               length(l),</span><br><span class="line">               spStr(<span class="built_in">std</span>::move(sp))</span><br><span class="line">         &#123;&#125;</span><br><span class="line">         <span class="keyword">size_t</span> index;</span><br><span class="line">         <span class="keyword">uint32_t</span> length;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; spStr;</span><br><span class="line">         <span class="function"><span class="keyword">size_t</span> <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> index + length; &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">NodeCmp</span> &#123;</span></span><br><span class="line">         <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node&amp; lhs, <span class="keyword">const</span> Node&amp; rhs)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> lhs.index &lt; rhs.index; &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">     <span class="keyword">using</span> SetType = <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Node, NodeCmp&gt;;</span><br><span class="line">     <span class="keyword">uint32_t</span> _rcv_base&#123;<span class="number">0</span>&#125;; <span class="comment">// 下一个起始索引</span></span><br><span class="line">     <span class="keyword">uint32_t</span> _eof_index&#123;<span class="number">0xffffffff</span>&#125;;</span><br><span class="line">     <span class="keyword">uint32_t</span> _unassembled_bytes&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">     SetType _aux_storage;</span><br><span class="line"></span><br><span class="line">     ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">     <span class="keyword">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     <span class="comment">// 判断 data 是否有部分属于 assembled 但 unread</span></span><br><span class="line">     <span class="comment">// 把这一部分数据叫做有效数据 valid data</span></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;</span><br><span class="line">     get_valid_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data, <span class="keyword">const</span> <span class="keyword">size_t</span> index);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// remain capacity</span></span><br><span class="line">     <span class="function"><span class="keyword">uint32_t</span> <span class="title">remain_capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _capacity - _unassembled_bytes - _output.buffer_size(); &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 把数据交付给 ByteStream，并更新 aux_storage</span></span><br><span class="line">     <span class="function"><span class="keyword">uint32_t</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 把数据写到 aux_storage</span></span><br><span class="line">     <span class="comment">// 会出现几种情况</span></span><br><span class="line">     <span class="comment">// 1. 数据是从 _rcv_base 开始的</span></span><br><span class="line">     <span class="comment">// 2. 数据不是从 _rcv_base 开始的</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">write_to_aux_storage</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; p)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 合并碎片，可能会有多个碎片和输入碎片重叠</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Node node)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// param a: start_iterator of node which is going to be delete</span></span><br><span class="line">     <span class="comment">// param b: end_iterator of node which is going to be delete</span></span><br><span class="line">     <span class="comment">// param node: the node which is going to be insert</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">update_unassembled_bytes</span><span class="params">(SetType::iterator a, SetType::iterator b, <span class="keyword">const</span> Node&amp; node)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">uint32_t</span> total = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">auto</span> it = a; it != b; ++it)</span><br><span class="line">             total += it-&gt;length;</span><br><span class="line">         _unassembled_bytes += node.length - total;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">update_storage</span><span class="params">(SetType::iterator a, SetType::iterator b, <span class="keyword">const</span> Node&amp; node)</span> </span>&#123;</span><br><span class="line">         update_unassembled_bytes(a, b, node);</span><br><span class="line">         _aux_storage.erase(a, b);</span><br><span class="line">         _aux_storage.insert(node);</span><br><span class="line">     &#125;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里是实现：<code>stream_reassembler.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">StreamReassembler::StreamReassembler(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity)</span><br><span class="line">     : _aux_storage(),</span><br><span class="line">       _output(capacity),</span><br><span class="line">       _capacity(capacity)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::merge</span><span class="params">(StreamReassembler::Node node)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::write_to_aux_storage</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; p)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// std::string tmp = p.second.size() &gt; remain_capacity() ?</span></span><br><span class="line">     <span class="comment">//     p.second.substr(0, remain_capacity()) : p.second;</span></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">string</span> tmp = p.second.size() &gt; _capacity ?</span><br><span class="line">         p.second.substr(<span class="number">0</span>, _capacity) : p.second;</span><br><span class="line">     <span class="function">Node <span class="title">node</span><span class="params">(p.first, tmp.size(), <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(tmp))</span></span>;</span><br><span class="line">     <span class="comment">// _unassembled_bytes += tmp.size();</span></span><br><span class="line">     merge(node);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">uint32_t</span> <span class="title">StreamReassembler::update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">auto</span> it = _aux_storage.begin();</span><br><span class="line">     <span class="comment">// assert(it-&gt;index == _rcv_base);</span></span><br><span class="line">     <span class="keyword">size_t</span> writed = _output.write(*it-&gt;spStr);</span><br><span class="line">     <span class="keyword">size_t</span> ret = _rcv_base + writed;</span><br><span class="line">     _unassembled_bytes -= writed;</span><br><span class="line">     <span class="keyword">if</span> (writed == it-&gt;length) &#123;</span><br><span class="line">         _aux_storage.erase(it);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         Node node = &#123;ret, it-&gt;length - <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(writed),</span><br><span class="line">             <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;</span><br><span class="line">                 (it-&gt;spStr-&gt;substr(writed))</span><br><span class="line">                 &#125;;</span><br><span class="line">         _aux_storage.erase(it);</span><br><span class="line">         _aux_storage.insert(node);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (ret == _eof_index) _output.end_input();</span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// data: 传到 push_substring 的字符串</span></span><br><span class="line"> <span class="comment">// ret: index, valid_data</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;</span><br><span class="line"> StreamReassembler::get_valid_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data,</span><br><span class="line">         <span class="keyword">const</span> <span class="keyword">size_t</span> index) &#123;</span><br><span class="line">     <span class="keyword">if</span> (index &gt;= _rcv_base) <span class="keyword">return</span> &#123;index, data&#125;;</span><br><span class="line">     <span class="keyword">size_t</span> end = index + data.size();</span><br><span class="line">     <span class="keyword">if</span> (end &lt; _rcv_base) <span class="keyword">return</span> &#123;<span class="number">0</span>, &#123;&#125;&#125;;</span><br><span class="line">     <span class="keyword">return</span> &#123;_rcv_base, data.substr(_rcv_base - index)&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//! \details This function accepts a substring (aka a segment) of bytes,</span></span><br><span class="line"> <span class="comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span></span><br><span class="line"> <span class="comment">//! contiguous substrings and writes them into the output stream in order.</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data, <span class="keyword">const</span> <span class="keyword">size_t</span> index, <span class="keyword">const</span> <span class="keyword">bool</span> eof)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (eof) _eof_index = index + data.size();</span><br><span class="line">     <span class="keyword">auto</span> p = get_valid_data(data, index); <span class="comment">// valid_index, valid_data</span></span><br><span class="line">     <span class="comment">// index + data.size() &lt; _rcv_base</span></span><br><span class="line">     <span class="keyword">if</span> (p.second.empty()) &#123;</span><br><span class="line">         <span class="comment">// 如果只是用来通知 eof 的</span></span><br><span class="line">         <span class="keyword">if</span> (_rcv_base == _eof_index)    _output.end_input();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     write_to_aux_storage(p);</span><br><span class="line">     <span class="comment">// index + data.size() &gt;= _rcv_base &amp;&amp; index &lt;= _rcv_base</span></span><br><span class="line">     <span class="keyword">if</span> (p.first == _rcv_base) &#123;</span><br><span class="line">         _rcv_base = update();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// index &gt; _rcv_base</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">size_t</span> StreamReassembler::unassembled_bytes() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _unassembled_bytes; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == unassembled_bytes(); &#125;</span><br></pre></td></tr></table></figure><p>除此之外可以看看 Leetcode 56 题：</p><h5 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h5><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p>示例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>], end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= end)</span><br><span class="line">                end = max(end, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ret.push_back(&#123;start, end&#125;);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret.push_back(&#123;start, end&#125;);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144-lab1-stitching-substrings-into-a-byte-stream&quot;&gt;&lt;a href=&quot;#cs144-lab1-stitching-substrings-into-a-byte-stream&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Dynamic Link</title>
    <link href="https://codroc.github.io/2022/03/26/dynamic_link/"/>
    <id>https://codroc.github.io/2022/03/26/dynamic_link/</id>
    <published>2022-03-26T11:57:16.000Z</published>
    <updated>2022-03-26T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dynamic-Link"><a href="#Dynamic-Link" class="headerlink" title="Dynamic Link"></a>Dynamic Link</h1><h4 id="静态链接的缺陷"><a href="#静态链接的缺陷" class="headerlink" title="静态链接的缺陷"></a>静态链接的缺陷</h4><ul><li>浪费内存和磁盘空间</li><li>模块更新困难</li></ul><p>​    由于静态链接会把模块代码全部链接进入可执行文件，可想而知，可执行文件将会变得比较大（想象一下，每个程序内部除了保留着 printf()，scanf()，strlen() 等这样的公共函数，还有很多数量可观的其他库函数，这会使得程序变得多么庞大，而这么庞大的程序不光浪费了磁盘，当他需要被执行时，也会被加载到内存从而浪费大量内存）。<strong>在静态链接中，C 语言静态库是一个很典型的浪费空间的例子。</strong></p><p>​    除此之外，静态链接由于已经把所有模块全部放进可执行文件了，一旦程序中有任何模块更新，整个程序就要重新链接。</p><p>​    拿 LOL 举例，我们知道它是频繁更新的程序，并且不提供源代码。如果它采用静态链接，那么每一次更新后，我们就要把老版本的卸载了，从官网下载新版本的 LOL，这不光浪费时间，而且大大浪费了网络带宽，要知道很多人玩这游戏的，那么它每一次更新都可能导致网络负载大大增加（因为每个人都在那一天重新下载最新版本的 LOL），可能会导致网络瘫痪的（故意夸张了下~~）；如果采用动态链接的话，只需要下载补丁就可以了。</p><h4 id="动态链接基本思想"><a href="#动态链接基本思想" class="headerlink" title="动态链接基本思想"></a>动态链接基本思想</h4><p><strong>把程序模块相互分割开来而不是静态地链接在一起。把链接的过程推迟到运行时在进行。</strong></p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>节省磁盘和内存空间</li><li>使得程序的更新更加容易且友好</li><li>模块更加独立，耦合性更加小，增加程序的兼容性</li><li>可以减少换入换出，也可以增加 Cache 命中率，因为不同进程间地数据和指令都集中在了同一个共享模块上</li></ul><blockquote><p>其实 Plug-in 插件就是采用了动态链接的思想实现出来的</p></blockquote><p>Q1：如何理解 3？</p><p>A1：举个例子吧。比如操作系统 A 和操作系统 B 对于 printf 的实现是不一样的，如果采用静态链接，那么必须要有两份可执行文件，分别能够在两个 OS 上运行。如果采用动态链接，只要 OS A 和 OS B 都提供了一个动态链接库包含了 printf，并且这个 printf 使用了相同的接口，那么程序只需要一个版本，就能在两个操作系统上运行，动态地选择相应的 printf 的实现版本。其实可以这样想，我现在有一个充电器，房子 A 和 房子 B 的插座都是一个样的，且充电器都能插进去，那么不管我去哪个房子都能充电。房子 A 插座后面的电是通过太阳能发电得到的；而房子 B 插座后面的电是通过火力发电得到的。虽然发电方式不一样，但是充电器插头能插进插座，并且有电，我们就能充电了。</p><p>Q2：如何理解 4？</p><p>A2：因为采用动态链接，同样的指令在内存中只存在一份，这样 Cache 就不会因为查看到物理地址不一样而不命中了。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>由于把程序的链接推迟到了装载的时候，不可避免地导致了程序装载速度变慢（可以通过 lazy binding 优化），因为引入了一堆 “胶水” 代码来把共享库粘到原来的进程空间中去。</li><li>可执行程序依赖于能够兼容的共享库。在运行时找不到共享库或者版本不兼容，都会导致运行时错误。</li><li>由于动态库是在可执行文件装载时确定它们所在的进程虚拟地址空间位置的，因此它们可能广泛地分布在虚拟地址空间中，而不是在同一处，这会导致空间的局部性变差，emmm 主要还是从 TLB 缓冲失效的角度影响性能。</li></ul><h1 id="查看动态库相关信息的命令"><a href="#查看动态库相关信息的命令" class="headerlink" title="查看动态库相关信息的命令"></a>查看动态库相关信息的命令</h1><p>用 g++ 创建一个共享库 <code>b.so</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ -fPIC -shared -o b.so b.cpp</span></span><br></pre></td></tr></table></figure><p>创建一个依赖于 <code>b.so</code> 的共享库 <code>hello.so</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ -fPIC -shared -Wl,-rpath=. -o hello.so b.so hello.cpp</span></span><br></pre></td></tr></table></figure><p>编译一个依赖于  <code>hello.so</code> 的程序 <code>test_shared_map</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ test_shared_map.cpp hello.so b.so -o test_shared_map -Wl,-rpath=.</span></span><br></pre></td></tr></table></figure><p>查看一个程序链接了哪些共享库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd test_shared_map</span></span><br><span class="line">        linux-vdso.so.1 (0x0000ffffbab40000)</span><br><span class="line">        hello.so =&gt; ./hello.so (0x0000ffffbaaee000)</span><br><span class="line">        b.so =&gt; ./b.so (0x0000ffffbaadc000)</span><br><span class="line">        libstdc++.so.6 =&gt; /lib/aarch64-linux-gnu/libstdc++.so.6 (0x0000ffffba951000)</span><br><span class="line">        libm.so.6 =&gt; /lib/aarch64-linux-gnu/libm.so.6 (0x0000ffffba894000)</span><br><span class="line">        libgcc_s.so.1 =&gt; /lib/aarch64-linux-gnu/libgcc_s.so.1 (0x0000ffffba870000)</span><br><span class="line">        libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffffba6fe000)</span><br><span class="line">        /lib/ld-linux-aarch64.so.1 (0x0000ffffbab12000)</span><br></pre></td></tr></table></figure><p>查看程序的 RPATH：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chrpath -l test_shared_map</span></span><br><span class="line">test_shared_map: RUNPATH=.</span><br></pre></td></tr></table></figure><p>查看 hello.so 共享库的 <code>.got</code>  和 <code>.got.plt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -h hello.so | grep got</span></span><br><span class="line"> 18 .got          00000048  0000000000010fa0  0000000000010fa0  00000fa0  2**3</span><br><span class="line"> 19 .got.plt      00000050  0000000000010fe8  0000000000010fe8  00000fe8  2**3</span><br></pre></td></tr></table></figure><p>查看 hello.so 共享库的重定位表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -R hello.so | less</span></span><br><span class="line">0000000000010fa8 R_AARCH64_GLOB_DAT  _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@GLIBCXX_3.4</span><br><span class="line">0000000000010fb0 R_AARCH64_GLOB_DAT  __cxa_finalize@GLIBC_2.17</span><br><span class="line">0000000000010fb8 R_AARCH64_GLOB_DAT  _ZSt4cout@GLIBCXX_3.4</span><br><span class="line">0000000000010fc0 R_AARCH64_GLOB_DAT  b</span><br><span class="line">0000000000010fc8 R_AARCH64_GLOB_DAT  _ITM_deregisterTMCloneTable</span><br><span class="line">0000000000010fd0 R_AARCH64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000010fd8 R_AARCH64_GLOB_DAT  _ITM_registerTMCloneTable</span><br><span class="line">0000000000010fe0 R_AARCH64_GLOB_DAT  _ZNSt8ios_base4InitD1Ev@GLIBCXX_3.4</span><br><span class="line">0000000000011000 R_AARCH64_JUMP_SLOT  __cxa_finalize@GLIBC_2.17</span><br><span class="line">0000000000011008 R_AARCH64_JUMP_SLOT  _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@GLIBCXX_3.4</span><br><span class="line">0000000000011010 R_AARCH64_JUMP_SLOT  _ZNSolsEPFRSoS_E@GLIBCXX_3.4</span><br><span class="line">0000000000011018 R_AARCH64_JUMP_SLOT  __cxa_atexit@GLIBC_2.17</span><br><span class="line">0000000000011020 R_AARCH64_JUMP_SLOT  _ZNSt8ios_base4InitC1Ev@GLIBCXX_3.4</span><br><span class="line">0000000000011028 R_AARCH64_JUMP_SLOT  _ZNSolsEi@GLIBCXX_3.4</span><br><span class="line">0000000000011030 R_AARCH64_JUMP_SLOT  __gmon_start__</span><br></pre></td></tr></table></figure><p>可以看到 <code>R_AARCH64_GLOB_DAT</code> 类型的变量每个占 8 个字节，并且在 0000000000010fb0~0000000000010fe0 范围内，正好这段区域在 <code>.got</code> 的区域内。而 <code>R_AARCH64_JUMP_SLOT</code> 每个也占 8 个字节，且正好都在 <code>.got.plt</code> 的区域内。</p><p>查看进程 <code>test_shared_map</code> 虚拟地址空间的映射关系：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./test_shared_map &amp;</span></span><br><span class="line">[1] 27652</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/27652/maps</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/03/15/bj44gJ.png"></p><p>可以看到这个进程的地址空间的分布</p><p>OS 把进程的虚拟地址空间分配给了：</p><ul><li>可执行文件：<code>/home/cwp/test/test_shared_map</code></li><li>堆栈：<code>[heap]</code>、<code>[stack]</code></li><li>共享库：<code>/home/cwp/test/b.so</code>、<code>/usr/lib/aarch64-linux-gnu/libc-2.28.so</code>、<code>/usr/lib/aarch64-linux-gnu/libgcc_s.so.1</code>、<code>/usr/lib/aarch64-linux-gnu/libm-2.28.so</code>、<code>/usr/lib/aarch64-linux-gnu/libstdc++.so.6.0.25</code>、<code>/home/cwp/test/hello.so</code>、<code>/usr/lib/aarch64-linux-gnu/ld-2.28.so</code></li><li>绕开陷入内核，加速系统调用：<code>[vdso]</code>、<code>[vvar]</code> （具体看我文章。。。。。）</li><li>匿名映射（内存到磁盘）：mmap</li></ul><p>其实通过 proc 这个文件系统就能很清楚的得知进程的虚拟地址的分布情况，这里栈空间仅仅只有 132KB，出乎意料的小。。。。堆空间也只有 132KB，但是堆可以增大（向系统申请）呀，栈却不能变大了呀。。。系统也太抠了。。。</p><h1 id="何时使用静态库何时使用动态库？"><a href="#何时使用静态库何时使用动态库？" class="headerlink" title="何时使用静态库何时使用动态库？"></a>何时使用静态库何时使用动态库？</h1><p>如果该库不经常更新，并且不被多数的可执行文件共享，那些就应该把他们编译成 static ！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><p>程序员的自我修养——链接、装载与库</p></li><li><p><a href="https://www.ibm.com/docs/en/aix/7.2?topic=techniques-when-use-dynamic-linking-static-linking">When to use dynamic linking and static linking</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dynamic-Link&quot;&gt;&lt;a href=&quot;#Dynamic-Link&quot; class=&quot;headerlink&quot; title=&quot;Dynamic Link&quot;&gt;&lt;/a&gt;Dynamic Link&lt;/h1&gt;&lt;h4 id=&quot;静态链接的缺陷&quot;&gt;&lt;a href=&quot;#静态链接的缺</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode 刷题笔记</title>
    <link href="https://codroc.github.io/2022/03/21/leetcode/"/>
    <id>https://codroc.github.io/2022/03/21/leetcode/</id>
    <published>2022-03-21T11:57:16.000Z</published>
    <updated>2022-03-21T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-刷题笔记"><a href="#Leetcode-刷题笔记" class="headerlink" title="Leetcode 刷题笔记"></a>Leetcode 刷题笔记</h1><p><strong>要开始刷题了，记录下那些思想比较绕的，一时半会想不起来怎么做的题目</strong>。</p><p><strong><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q || !root) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* l = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* r = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="comment">// 情况 1，p、q在左右两边</span></span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; r) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">// 两边都没有 p、q，那么直接返回</span></span><br><span class="line">        <span class="comment">// 情况 2 和 3</span></span><br><span class="line">        <span class="keyword">return</span> l ? l : r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>问题描述：给定一颗树的根节点 <code>root</code>，找出节点 <code>p</code> 和 <code>q</code> 的最近的公共祖先节点。</em></p><p>这个分三种情况：</p><ol><li>祖先节点正好在中间，而 p、q 节点在左右两边</li><li>p、q 都在一边，且祖先节点为 p</li><li>p、q 都在一边，且祖先节点为 q</li></ol><p>递归地查找 p、q 位置，即到底是在左右两边，还是在同一边。</p><p>对于第一种情况，我们只要返回 root 节点就行了；对于第二种情况，返回 p；第三种情况，返回 q</p><p><strong><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></strong></p><p>这一题和 <strong>至多有K个重复字符的最长字串、无重复字符的最长字串</strong> 有类似的概念，可以一起训练。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fz</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">26</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i)</span><br><span class="line">            a[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pairs;</span><br><span class="line">        <span class="keyword">int</span> nl = l;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">bool</span> need_partation = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = l; i &lt; r &amp;&amp; nl &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt; k) &#123;</span><br><span class="line">                need_partation = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - nl &gt;= k)    pairs.push_back(&#123;nl, i&#125;);</span><br><span class="line">                <span class="keyword">while</span> (i &lt; r &amp;&amp; a[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt; k) ++i;</span><br><span class="line">                nl = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!need_partation) <span class="keyword">return</span> r - l &gt;= k ? r - l : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i - nl &gt;= k)    pairs.push_back(&#123;nl, i&#125;);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : pairs)</span><br><span class="line">            ret = max(ret, fz(s, p[<span class="number">0</span>], p[<span class="number">1</span>], k));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fz(s, <span class="number">0</span>, s.size(), k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这道题的思想很重要，采用分治的思想：<strong>如果字符出现的次数少于 K 那么该字符比不可能出现在最长字串中，因此可以用该字符对字符串进行划分，划分成一个个的区间，然后对区间内的字符串再次采用分治思想。</strong></p><p>举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分治：对于一个字符串来说，如果要求子串最少出现k次，那么如果某些字母出现的次数小于k,</span></span><br><span class="line"><span class="comment">//这些字母一定不会出现在最长的子串中，并且这些字母将整个字符子串分割成小段，这些小段有可能是最长的</span></span><br><span class="line"><span class="comment">//但是由于被分割了，还是要检查这一小段，如果某些字母出现的次数小于k,会将小段继续分割下去,</span></span><br><span class="line"><span class="comment">//比如字符串&quot;aacbbbdc&quot;，要求最少出现2次,我们记录左右闭区间，，</span></span><br><span class="line"><span class="comment">//第一轮[0,7]，处理&quot;aacbbbdc&quot;，d只出现了一次不满足，于是递归解决区间[0,5]、[7,7]</span></span><br><span class="line"><span class="comment">//第二轮[0,5]，处理&quot;aacbbb&quot;，  c只出现了一次不满足，于是递归解决区间[0,1]、[3,4] </span></span><br><span class="line"><span class="comment">//第二轮[7,7]，处理&quot;c&quot;，       c只出现了一次不满足，不继续递归</span></span><br><span class="line"><span class="comment">//第三轮[0,1]，处理&quot;aa&quot;，      满足出现次数&gt;=2,ret=2</span></span><br><span class="line"><span class="comment">//第三轮[3,4]，处理&quot;bbb&quot;，     满足出现次数&gt;=2 ret=3;</span></span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></strong></p><p>这题刚开始碰到是不会做的，感觉思想还是挺有意思的，记录下！</p><p>看下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>看下数据的范围：</p><ul><li>n == nums1.length</li><li>n == nums2.length</li><li>n == nums3.length</li><li>n == nums4.length</li><li>1 &lt;= n &lt;= 200</li><li>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</li></ul><p>n = 200，所以暴力肯定超时，最好想个 O(n*n) 的方法~</p><p>如果是两数相加要怎么做？两数相加很简单的：</p><p><code>target = a + b</code>，只要在 map 中记录 a，然后查到 b 的时候，查以下 map 里面有没有 a 就行了。</p><p>其实四数相加完全可以转化成两数相加：</p><p><code>target = (a + b) + (c + d)</code> ，那么我们先计算前两个数组之和，如示例1，<code>a + b</code>两两组合就会产生 4 个值 L1= [-1, 0, 0, 1]; <code>c + d</code> 两两组合就会产生 4 个值 L2 = [-1, 1, 2, 4];</p><p>接下来其实就是两数相加的内容了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for x1 in L1, x2 in L2:</span><br><span class="line">if x1 + x2 &#x3D;&#x3D; target</span><br><span class="line">ret++</span><br></pre></td></tr></table></figure><p>这里还可以通过 map 进行优化，最终得到的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp1, mp2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 : nums2)</span><br><span class="line">                mp1[i1+i2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 : nums4)</span><br><span class="line">                mp2[i1+i2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = mp1.begin(); it1 != mp1.end(); ++it1) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - it1-&gt;first;</span><br><span class="line">            <span class="keyword">int</span> times = it1-&gt;second;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> it2 = mp2.find(target); it2 != mp2.end()) &#123;</span><br><span class="line">                ret += it2-&gt;second * times;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">1109. 航班预定系统</a></strong></p><p>这道题就是考察一个知识点，那就是：**<a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分数组</a>**</p><p>其实一开始，我只是绝对对同一个区间进行相同的操作，没必要再遍历，但是就是找不出用什么别的方法，原来可以用差分。。。。。</p><p>差分数组的应用场景：对区间内 [l, r] 内的元素做同一类型的操作，那么就可以用差分数组。</p><p>由于差分数组是通过后一个减前一个的方式得到的即 d[i] = a[i] - a[i - 1]，i &gt; 0。因此如果在区间 [l, r] 中进行 +val 操作，就会导致：</p><ul><li>a[l] - a[l - 1] = d[l] + val</li><li>a[r + 1] - a[r] = d[r + 1] - val</li></ul><p>因此只要改变差分数组中的两个元素就可以了，一个是 d[l]，一个是 d[r + 1]</p><p>接下来看下题目：</p><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</p><p>请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer &#x3D; [10,55,45,25,25]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : bookings) &#123;</span><br><span class="line">            <span class="keyword">int</span> first = e[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> last = e[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> seats = e[<span class="number">2</span>];</span><br><span class="line">            d[first] += seats;</span><br><span class="line">            <span class="keyword">if</span> (last &gt;= n + <span class="number">1</span>)   <span class="keyword">continue</span>;</span><br><span class="line">            d[last] -= seats;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n + <span class="number">1</span>;++i)</span><br><span class="line">            d[i] = d[i] + d[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> &#123;d.data() + <span class="number">1</span>, d.data()+d.size()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></strong></p><p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,0,0,0,1,1,1,1,0], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释：[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K &#x3D; 3</span><br><span class="line">输出：10</span><br><span class="line">解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 10。</span><br></pre></td></tr></table></figure><p>这题用前缀和，v[i] 表示前面有几个 0。</p><p>但是这里的索引以及边界问题的使用很让人不解。。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            v[i] = v[i - <span class="number">1</span>] + <span class="number">1</span> - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 这里为什么要从 0 开始遍历</span></span><br><span class="line">            <span class="keyword">int</span> left = lower_bound(v.begin(), v.end(), v[i + <span class="number">1</span>] - k) - v.begin();</span><br><span class="line">            ret = max(ret, i - left + <span class="number">1</span>); <span class="comment">// 为什么是 i - left + 1 而不是 i - left</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></strong></p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><p><strong>方法：中间扩散法！</strong></p><p>首先确定回文串，就是找中心然后想两边扩散看是不是对称的就可以了。</p><p><strong>在遍历中心点的时候，要注意中心点有两种情况</strong>。</p><p>一个元素可以作为中心点，两个元素也可以作为中心点。</p><p>所以我们在计算的时候，要注意一个元素为中心点和两个元素为中心点的情况。</p><p><strong>这两种情况可以放在一起计算，但分别计算思路更清晰，我倾向于分别计算</strong>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i) &#123;</span><br><span class="line">            l = r = i;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;=<span class="number">0</span> &amp;&amp; r &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[l] != s[r]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; ret.size())</span><br><span class="line">                    ret = s.substr(l, r - l + <span class="number">1</span>);</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i) &#123;</span><br><span class="line">            l = r = i; r++;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;=<span class="number">0</span> &amp;&amp; r &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[l] != s[r]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; ret.size())</span><br><span class="line">                    ret = s.substr(l, r - l + <span class="number">1</span>);</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></strong></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>这一题实际上就是考察<strong>快排</strong>会不会，以及对快排进行优化，即随机取一个数作为<strong>比较数</strong>，而不是呆呆得永远取第一个数，</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t_l = l, t_r = r;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; l) &#123; <span class="comment">// 引入随机性，防止退化到 O(n*n)</span></span><br><span class="line">            <span class="keyword">int</span> idx = rand()%(r - l) + l; <span class="comment">// 注意 r - l = 0 时会发生计算错误</span></span><br><span class="line">            swap(nums[l], nums[idx]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp_num = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &gt; l &amp;&amp; nums[r] &lt;= cmp_num) --r;</span><br><span class="line">            swap(nums[l], nums[r]);</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &gt;= cmp_num) ++l;</span><br><span class="line">            swap(nums[l], nums[r]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> == k) <span class="keyword">return</span> nums[l];</span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span> &lt; k ? findK(nums, l + <span class="number">1</span>, t_r, k) :</span><br><span class="line">            findK(nums, t_l, r - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用快排的思想</span></span><br><span class="line">        <span class="keyword">return</span> findK(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. 数据流的中位数</a></strong></p><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addNum(1)</span><br><span class="line">addNum(2)</span><br><span class="line">findMedian() -&gt; 1.5</span><br><span class="line">addNum(3)</span><br><span class="line">findMedian() -&gt; 2</span><br></pre></td></tr></table></figure><p>进阶:</p><ol><li>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</li><li>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</li></ol><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p>中位数，只要记住用</p><ol><li><strong>大顶堆 + 小顶堆</strong></li><li><strong>大顶堆 &lt; 小顶堆</strong></li></ol><p>因此就相当于把整个有序列表划分成两部分，前面的部分在大顶堆，后面部分在小顶堆，只要保持 <strong>|大顶堆.size() - 小顶堆.size()| &lt;= 1</strong></p><p>就可以轻松获得中位数了！代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; min_pq;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; max_pq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MedianFinder()</span><br><span class="line">        : min_pq()</span><br><span class="line">        , max_pq()</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (min_pq.empty() || min_pq.top() &lt;= num) &#123;</span><br><span class="line">            min_pq.push(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> max_pq.push(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min_pq.size() &gt; max_pq.size() + <span class="number">1</span>) &#123;</span><br><span class="line">            max_pq.push(min_pq.top());</span><br><span class="line">            min_pq.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> + min_pq.size() &lt; max_pq.size()) &#123;</span><br><span class="line">            min_pq.push(max_pq.top());</span><br><span class="line">            max_pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ret;</span><br><span class="line">        <span class="keyword">if</span> (min_pq.size() == max_pq.size()) &#123;</span><br><span class="line">            ret = (min_pq.top() + max_pq.top()) * <span class="number">1.0</span> /<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(min_pq.size() &gt; max_pq.size()) &#123;</span><br><span class="line">            ret = min_pq.top() * <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> ret = max_pq.top() * <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态规划之子序列问题"><a href="#动态规划之子序列问题" class="headerlink" title="动态规划之子序列问题"></a>动态规划之子序列问题</h2><ol><li><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a></li><li><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674.最长连续递增序列</a></li><li><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718.最长重复子数组</a></li><li><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143.最长公共子序列</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html">1035.不相交的线</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">53.最大子序和</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html">392.判断子序列</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html">115.不同的子序列</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html">583.两个字符串的删除操作</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html">72.编辑距离</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html">为了绝杀编辑距离，我做了三步铺垫，你都知道么？</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html">647.回文子串</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html">516.最长回文子序列</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html">动态规划总结篇</a></li></ol><hr><p><strong><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a></strong></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长<strong>严格递增子序列</strong>的<strong>长度</strong>。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>注意项：</p><ul><li><p>注意这里说的是子序列而不是子串</p></li><li><p>只需要返回长度，不需要具体的子序列</p></li><li><p>严格递增</p></li></ul><p>用 dp[n] 表示 n 个元素的数组中，以 nums[n - 1] <strong>元素结尾</strong>的最长<strong>严格递增子序列</strong>的<strong>长度</strong> 为 dp[n]，那么</p><p>dp[n + 1] = max(dp[i] + 1)，其中必须满足 nums[i] &lt; nums[n + 1]，i = 0~n</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = max(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718.最长重复子数组</a></strong></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,3,2,1], nums2 &#x3D; [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3,2,1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [0,0,0,0,0], nums2 &#x3D; [0,0,0,0,0]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li></ul><p>这一题明显和前面的那种有较大的差别了，因为它涉及两个数组，而前面的都是在一个数组里面折腾的。</p><p>这种两个数组的优先考虑二维 DP。再结合 一维时候的思想：dp[i] 表示 第 i 个元素结尾的最长xxx子串。</p><p>最后可以想到：用 dp[i][j] 表示以 nums1[i] 和 nums2[j] 结尾的最长公共子串的长度，那么</p><ul><li>如果 nums1[i] == nums2[j]，dp[i][j] =  dp[i - 1][j - 1] + 1</li><li>如果 nums1[i] != nums2[j]，dp[i][j] =  0</li></ul><p>只要找到最大的那个 dp[i][j] 就可以了</p><p>这里还需要一个小技巧，由于依赖于 i - 1 和 j - 1 因此，遍历的 i，j 要从 1 开始。那么我们就多加一行一列，下标 1 实际上对应于数组中的下标 0，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n2 + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        ret = dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n1 + <span class="number">1</span>;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n2 + <span class="number">1</span>;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    ret = max(ret, dp[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143.最长公共子序列</a></strong></p><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><p>这里也是出现了两个字符串，毫无疑问，继续二维 DP，与上一题不同的是，这里要求的是子序列而非子串，子序列可以是不连续的。</p><p>用 dp[i][j] 表示以 text1[i]、text2[j] 结尾的字符串的最长公共子序列长度，那么会遇到两种情况：</p><ol><li>text1[i] == text2[j]，此时 dp[i][j] = dp[i - 1][j - 1] + 1;</li><li>text1[i] != text2[j]，此时取两组字符串中公共子序列最长的值，其一为 (text1[i - 1], text2[j])，其二为 (text1[i], text2[j - 1])，因此 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示字符串 text1[i]、text2[j] 的最长公共子序列长度</span></span><br><span class="line">        <span class="comment">// 如果 text1[i] == text2[j], dp[i][j] = dp[i - 1][j - 1] + 1</span></span><br><span class="line">        <span class="comment">// 如果 text1[i] != text2[j], dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</span></span><br><span class="line">        <span class="keyword">int</span> n1 = text1.size(), n2 = text2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n2 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n1 + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n2 + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给出表格更好理解：</p><p>   a b c d e</p><p>a 1 1 1 1 1</p><p>c 1 1 2 2 2</p><p>e 1 1 2 2 3</p><p><strong><a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></strong></p><p>这一题其实就是最长公共子序列的长度，也就是和 1143 这一题一样，无非是两个字符串变成了两个数组。</p><p><strong><a href="https://leetcode.cn/problems/maximum-subarray/">53.最大子串和</a></strong></p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>这题很简单啊，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i] 表示以 nums[i] 结尾的数组子串的最大和</span></span><br><span class="line">        <span class="comment">// 那么 dp[i] = max(nums[i], nums[i] + dp[i - 1]);</span></span><br><span class="line">        <span class="keyword">int</span> ret = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();++i) &#123;</span><br><span class="line">            dp[i] = max(nums[i], nums[i] + dp[i - <span class="number">1</span>]);</span><br><span class="line">            ret = max(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/is-subsequence/">392.判断子序列</a></strong></p><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 100</code></li><li><code>0 &lt;= t.length &lt;= 10^4</code></li><li>两个字符串都只由小写字符组成。</li></ul><p>这一题也是 <strong>相当于判断 s 和 t 的最长公共子序列的长度是否等于 t 的长度</strong>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">const</span> <span class="built_in">string</span>&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s.size(), n2 = t.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n2 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n1 + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n2 + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                dp[i][j] = s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>] ?</span><br><span class="line">                    dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> : dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 相当于是判断 s 和 t 的最长公共子序列的长度是否等于 t 的长度</span></span><br><span class="line">        <span class="keyword">return</span> func(s, t) == s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/distinct-subsequences/">115.不同的子序列</a></strong></p><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;rabbbit&quot;, t &#x3D; &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babgbag&quot;, t &#x3D; &quot;bag&quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>这一题属实有难度了，做了好久，主要是状态方程找不出来。思路其实还是挺类似的，这种两个字符串的，大概率就是二维 DP 了，并且一般来说 dp[i][j] 就表示以 s[i]、t[j] 结尾的字符串xxxxxx。然后比较 s[i] == t[j] 和 s[i] != t[j] 两种情况就可以了。</p><p>但是关键在于，状态方程该怎么写？最终状态方程是这样的：</p><ul><li>如果 s[i] == t[j]，dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]</li><li>如果 s[i] != t[j]，dp[i][j] = dp[i - 1][j]</li></ul><h4 id="解释如下："><a href="#解释如下：" class="headerlink" title="解释如下："></a>解释如下：</h4><p>先看s[i] == t[j] 时，以s = “rara” t = “ra” 为例，当i = 3, j = 1时，s[i] == t[j]。</p><p>此时分为2种情况，s串用最后一位的a + 不用最后一位的a。</p><p>如果用s串最后一位的a,那么t串最后一位的a也被消耗掉，此时的子序列其实=dp[i-1][j-1]</p><p>如果不用s串最后一位的a，那就得看”rar”里面是否有”ra”子序列的了，就是dp[i-1][j]</p><p>所以 dp[i][\j] = dp[i-1][j-1] + dp[i-1][j]</p><p>再看s[i] != t[j] 比如 s = “rarb” t = “ra” 还是当i = 3, j = 1时，s[i] != t[j]</p><p>此时显然最后的b想用也用不上啊。所以只能指望前面的”rar”里面是否有能匹配”ra”的</p><p>所以此时dp[i][j] = dp[i-1][j]</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583.两个字符串的删除操作</a></strong></p><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p><p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: word1 &#x3D; &quot;sea&quot;, word2 &#x3D; &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot;</span><br></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;leetcode&quot;, word2 &#x3D; &quot;etco&quot;</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>这一题就是 <strong>最长公共子序列的长度</strong> 的变形</p><p>设 n1 = word1.size(), n2 = word2.size(), n = 最长公共子序列的长度，所以 ret = n1 - n + n2 - n</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = word1.size(), n2 = word2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n2 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n1 + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n2 + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1 + n2 - <span class="number">2</span>*dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/edit-distance/">72.编辑距离</a></strong></p><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><p>这道题太难了，看了题解也模模糊糊的，见 <a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html">为了绝杀编辑距离，我做了三步铺垫，你都知道么？</a></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cost(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            cost[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            cost[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                    cost[i][j] = cost[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cost[i][j] = <span class="number">1</span> + min(cost[i<span class="number">-1</span>][j<span class="number">-1</span>], min(cost[i][j<span class="number">-1</span>], cost[i<span class="number">-1</span>][j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/palindromic-substrings/">647.回文子串</a></strong></p><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p>这一题可以用中心拓展发做，也可以用动态规划做。</p><h4 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h4><p>用 dp[i][j] 表示由字符 s[i]s[i + 1]…s[j - 1]s[j] 构成的子串<strong>是否为 回文串</strong></p><ul><li><p>如果 s[i] == s[j], dp[i][j] = dp[i + 1][j - 1]</p></li><li><p>如果 s[i] != s[j], dp[i][j] = false</p></li></ul><p>这一题的矩阵 dp 是按对角线的方向进行赋值计算的，这种遍历方式在动态规划题目中比较常见，需要掌握：</p><p>把 i 表示当前需要遍历哪一条对角线，i = 1 表示当前需要遍历第 i 条对角线，总共遍历 n - 1 条对角线，因为 i = 0 这条对角线已经初始化过了。j 表示当前在第 j 行，总共遍历 n - i 行。因此 <code>dp[i][j] 中的 i 对应代码中的 j，dp[i][j] 中的 j 对应代码中的 j + i</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用 dp[i][j] 表示由字符 s[i]s[i + 1]...s[j - 1]s[j] 构成的子串是否为 回文串</span></span><br><span class="line">        <span class="comment">// 如果 s[i] == s[j], dp[i][j] = dp[i + 1][j - 1]</span></span><br><span class="line">        <span class="comment">// 如果 s[i] != s[j], dp[i][j] = false</span></span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ret = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == s[j + i])</span><br><span class="line">                    dp[j][j + i] = dp[j + <span class="number">1</span>][j + i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j][j + i] = <span class="number">0</span>;</span><br><span class="line">                ret += dp[j][j + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中心拓展法："><a href="#中心拓展法：" class="headerlink" title="中心拓展法："></a>中心拓展法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            count(s, i, i);<span class="comment">//回文串长度为奇数</span></span><br><span class="line">            count(s, i, i+<span class="number">1</span>);<span class="comment">//回文串长度为偶数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(start) == s.charAt(end))&#123;</span><br><span class="line">            num++;</span><br><span class="line">            start--;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516.最长回文子序列</a></strong></p><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><p>这一题让我有点无从下手了，因为如果单单是一维数组，dp[i] 表示 xxx的最长回文子序列的长度，那么 s[i] 的加入对判断 能否使 回文子序列长度变长 没有帮助，因为你都不知道这个前面的回文子序列具体是什么；</p><p>因此考虑用二维 DP 试试。用 dp[i][j] 表示以 s[i] ~ s[j] 表示的子串的 最长回文子序列的长度，因此</p><ul><li>如果 s[i] == s[j]，那么 dp[i][j] = dp[i + 1][j - 1] + 2</li><li>如果 s[i] != s[j]，那么 dp[i][j] = max( dp[i + 1][j], dp[i][j - 1] )，注意 s[i + 1] ~s[j - 1] 构成的子串是 max 中的任意一个字符串的子串</li></ul><p>这一题填二维数组的方向也和之前的不太一样，因为 dp[i][j] 依赖于 dp[i + 1][j - 1] ，也就是它斜下方的那个元素，因此是 45° 斜着填二维数组。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n - i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == s[j + i]) &#123;</span><br><span class="line">                    <span class="comment">// 斜着填二维数组，本质是差分从 0 ~ n-1，起始点 j 从 0 ~ n - i - 1</span></span><br><span class="line">                    <span class="comment">// 例如 n = 5 差分为 1, 起始点从 1 ~ 3: (0, 1),(1, 2),(2, 3),(3, 4)</span></span><br><span class="line">                    dp[j][j + i] = dp[j + <span class="number">1</span>][j + i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j][j + i] = max(dp[j + <span class="number">1</span>][j + i], dp[j][j + i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><strong><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></strong></p><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></strong></p><p>给定一个整数 <code>n</code> ，返回 <code>n!</code> 结果中尾随零的数量。</p><p>提示 <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code></p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：0</span><br><span class="line">解释：3! &#x3D; 6 ，不含尾随 0</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 10000</code></li></ul><p>n! 尾零的数量即为 n! 中因子 10 的个数，而 10=2×5，因此转换成求 n! 中质因子 2 的个数和质因子 5 的个数的较小值。</p><p>由于质因子 5 的个数不会大于质因子 2 的个数（具体证明见方法二），我们可以仅考虑质因子 5 的个数。</p><p>而 n! 中质因子 5 的个数等于 [1,n] 的每个数的质因子 5 的个数之和，我们可以通过遍历 [1,n] 的所有 5 的倍数求出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i += <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = i; x % <span class="number">5</span> == <span class="number">0</span>; x /= <span class="number">5</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Leetcode-刷题笔记&quot;&gt;&lt;a href=&quot;#Leetcode-刷题笔记&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 刷题笔记&quot;&gt;&lt;/a&gt;Leetcode 刷题笔记&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;要开始刷题了，记录下那些思想比较绕的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多线程下 fork 与 exit 引发的连锁错误</title>
    <link href="https://codroc.github.io/2022/03/10/fork_and_exit_error/"/>
    <id>https://codroc.github.io/2022/03/10/fork_and_exit_error/</id>
    <published>2022-03-10T11:57:16.000Z</published>
    <updated>2022-03-10T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程下-fork-与-exit-引发的连锁错误"><a href="#多线程下-fork-与-exit-引发的连锁错误" class="headerlink" title="多线程下 fork 与 exit 引发的连锁错误"></a>多线程下 fork 与 exit 引发的连锁错误</h1><p><strong>这篇文章存在问题！！！</strong></p><p>问题出现在这样的情景下：</p><p>编译完 <code>loggerTest.cpp</code> 后，执行后，程序被阻塞不能退出,在通过 <code>ps aux|grep ./loggerTest</code> 一看，好家伙，原来是 <code>asyncLogging.cpp</code> 中的rollFile 函数 fork 出来的进程都还没释放掉，而且都处在 S 状态，也就是被阻塞了！</p><p><img src="https://s1.ax1x.com/2022/03/10/b4sqMV.png"></p><p>本来 fork 出这个进程是为了 roll file 的，也就是把 log 文件进行压缩打包用的。代码片段如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line"><span class="comment">// 执行脚本，对原来的 日志包 解包，对每个日志文件重命名（0=&gt;1，1=&gt;2 ...），然后将 1~N                                                   的日志文件重新压缩打包，父进程等待子进程退出，这阶段父进程不能持有任何锁</span></span><br><span class="line">    <span class="keyword">char</span> *args[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> newfile[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(newfile, <span class="number">0</span>, <span class="keyword">sizeof</span>(newfile));</span><br><span class="line">    <span class="built_in">memcpy</span>(newfile, ret.c_str(), ret.size());</span><br><span class="line">    args[<span class="number">0</span>] = <span class="string">&quot;jiaoben&quot;</span>;</span><br><span class="line">    args[<span class="number">1</span>] = newfile;</span><br><span class="line">    args[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        execv(<span class="string">&quot;jiaoben&quot;</span>, args);</span><br><span class="line">    wait(<span class="number">0</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到本来的预期是 fork 出一个子进程后，立马 execv 让可执行文件 <code>jiaoben</code> 来覆盖原来的内容（包括页表，各种锁、条件变量的状态，当然还有内核数据结构）。<code>jiaoben</code> 这个可执行文件就是用来执行 python 脚本的，照理说执行完会立马退出的呀！</p><p>好在这个进程没退出，我们可以用 gdb 来追踪它的状态：</p><p><img src="https://s1.ax1x.com/2022/03/10/b4sLrT.png" alt="gdb 追踪状态"></p><p>这是妥妥的连 execv 都没执行成功呀（因为 如果没有子进程 wait(0) 会直接返回 -1，所以子进程相当于继续执行下去了）！然后一看目录下，我晕，<code>jiaoben.cpp</code> 忘记编译了，所以 execv 执行失败，后端日志线程就回到 while 循环了，一直执行 <code>_cond.waitForSecs(3);</code> 这也就导致该进程在 ps 命令中看上去一直被阻塞了！</p><p>这也是血的教训呀！每次调用函数后一定要判断是否调用成功！不然有的苦头吃啊~~接下来，自然地将代码改成如下片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line"><span class="comment">// 执行脚本，对原来的 日志包 解包，对每个日志文件重命名（0=&gt;1，1=&gt;2 ...），然后将 1~N                                                   的日志文件重新压缩打包，父进程等待子进程退出，这阶段父进程不能持有任何锁</span></span><br><span class="line">    <span class="keyword">char</span> *args[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> newfile[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">memset</span>(newfile, <span class="number">0</span>, <span class="keyword">sizeof</span>(newfile));</span><br><span class="line">    <span class="built_in">memcpy</span>(newfile, ret.c_str(), ret.size());</span><br><span class="line">    args[<span class="number">0</span>] = <span class="string">&quot;jiaoben&quot;</span>;</span><br><span class="line">    args[<span class="number">1</span>] = newfile;</span><br><span class="line">    args[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == execv(<span class="string">&quot;jiaoben&quot;</span>, args))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    wait(<span class="number">0</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很自然呀！如果 execv 执行失败，让它退出就行了！但是好像并没那么容易，再次执行 <code>loggerTest</code>，发现连该进程都被阻塞了。当即用 <code>ps aux|grep ./loggerTest</code> 查看后，发现有两个名为<code>loggerTest</code> 的进程处在运行状态，退不出去！那没事，只要你还活着，我就能用 gdb attach 到你~~继续使用 gdb 去查看哪里出错了：</p><p>这一个 gdb 追踪的是原始的 <code>./loggerTest</code> 进程，因为它有 2 个线程，而 fork 只能 fork 出一个线程。</p><p><img src="https://s1.ax1x.com/2022/03/10/b46RAg.png" alt="原始 ./threadTest 进程"></p><p>可以看到测试进程<code>./loggerTest</code> 的主线程一直在 <code>AsyncLogging::stop</code> 上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 _currentBuffer 中有数据是不能让 _running 变成 False 的，不然就丢失数据了</span></span><br><span class="line">    <span class="comment">// 必须是 前端退出后，才能调用后端的 stop</span></span><br><span class="line">    assert(_running);</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexGuard <span class="title">guard</span><span class="params">(_lock)</span></span>;</span><br><span class="line">        size = _currentBuffer-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _cond.wakeup();</span><br><span class="line">        <span class="function">MutexGuard <span class="title">guard</span><span class="params">(_lock)</span></span>;</span><br><span class="line">        size = _currentBuffer-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    _running = <span class="literal">false</span>;</span><br><span class="line">    _cond.wakeup();</span><br><span class="line">    _thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个函数一直停留在 <code>stop</code> 中的唯一理由就是一直在 while 循环内出不去，也就是 wakeup 没作用，日志后端线程根本不鸟这个 wakeup。</p><p>再来看看打包日志的进程，它又是为什么迟迟不肯退出呢？</p><p><img src="https://s1.ax1x.com/2022/03/10/b46Icq.png" alt="打包日志的进程"></p><p>可以看到它也一直停留在 <code>AsyncLogging::stop</code> 上。<strong>并且这个进程只有一个线程，那么这个 wakeup 就很搞笑了呀，因为根本没有接收者，或者说接收这个 wakeup 的人就是你自己，而你此时在 while 循环里永远也接收不到</strong>。再回到 roll file 的代码片段，它是一直阻塞等待着子进程退出才会继续执行下去的，然而此时子进程（打包日志的进程）永远也退不出，这就导致了 <code>./loggerTest</code> 进程的后端日志线程永远被阻塞（可以通过 gdb 查看 thread 2 阻塞的位置就知道了 __GI__wait4），</p><p><img src="https://s1.ax1x.com/2022/03/10/b46LEF.png" alt="./loggerTest 进程的 thread 2"></p><p>进而导致前端日志线程退出时执行 <code>AsyncLogging::stop</code> 的 wakeup 却得不到后端日志线程的响应（因为它一直 wait(0) 等着子进程退出），这一系列连锁反应就导致了现在的尴尬局面~~</p><p>该怎么解决？那就是让 execv 一定要执行成功，在执行前判断脚本文件是否存在，如果不存在则不要在多线的情况下去 fork 了，很容易造成复杂的错误！</p><h1 id="带来的启发"><a href="#带来的启发" class="headerlink" title="带来的启发"></a>带来的启发</h1><ul><li>在多线程环境下，调用 fork 后一定要立马确定 execv 成功，不然的话很容易出现复杂难以诊断的错误。因为 fork 在 linux 环境下只会 fork 出一个线程，这样本质上就和 锁，条件变量 等待同步工具在概念上矛盾了（同步工具用于多线程环境，而 fork 出来的是单线程进程）。</li><li>不要以为调用了 exit 后 os 一定就会帮你释放掉资源，因为在 C++ 中，还存在全局对象析构这么一个环节，很有可能在这个环节 整个进程就阻塞住了，进而导致资源得不到释放，慢慢的把你的内存吃光！！！</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程下-fork-与-exit-引发的连锁错误&quot;&gt;&lt;a href=&quot;#多线程下-fork-与-exit-引发的连锁错误&quot; class=&quot;headerlink&quot; title=&quot;多线程下 fork 与 exit 引发的连锁错误&quot;&gt;&lt;/a&gt;多线程下 fork 与 ex</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cache coherence</title>
    <link href="https://codroc.github.io/2022/03/07/cache_coherence/"/>
    <id>https://codroc.github.io/2022/03/07/cache_coherence/</id>
    <published>2022-03-07T11:57:16.000Z</published>
    <updated>2022-03-07T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cache-Coherence"><a href="#Cache-Coherence" class="headerlink" title="Cache Coherence"></a>Cache Coherence</h2><p>​    cache coherence 也就是 cache 一致性问题，首先解释下这个问题为什么会存在。</p><h3 id="Cache-存在的必要性"><a href="#Cache-存在的必要性" class="headerlink" title="Cache 存在的必要性"></a>Cache 存在的必要性</h3><p>​    众所周知，CPU 频率远大于内存频率，那么具体大多少呢？可以看这篇文章哦~~<a href="https://zhuanlan.zhihu.com/p/98560121">《CPU到底有多快？内存：是我的250倍》</a>。我记得是拉跨的 CPU 都能在 1/3 ns 内执行完一条简单指令，而一次访存操作至少要 80 ns。</p><p>​    那么我们听到的什么 DDR4-3200-1600MHZ 是什么意思呢？3200 是指传输速率为 3.2Gbit/s，而 1600MHZ 是指接口总线频率，其工作频率实质只有 400MHZ（接口频率是工作频率的 4 倍了）。如果 2GHZ 的 CPU 算接口频率的话，集成PCI-e 3.0控制器的 CPU，接口频率可是 8 GHz；4.0的则是 16 GHz。除此之外，总线也可能造成瓶颈。</p><p>​    由于 CPU 和内存之间存在着处理能力鸿沟，因此 Cache 就应运而生了（访问 cache 大概在 1ns 吧）。</p><p>写 Cache 的两种策略：</p><ul><li>直写</li><li>写回</li></ul><p><strong>直写的逻辑</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(数据不在 Cacheline 中) &#123;</span><br><span class="line">    直接写到内存中去;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">写 Cacheline;</span><br><span class="line">    写 内存;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写回的逻辑</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(数据在 Cacheline 中) &#123;</span><br><span class="line">    直接写 Cache;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(当前 Cacheline 是脏的) &#123;</span><br><span class="line">        将 Cacheline 中的数据写回到内存;</span><br><span class="line">    &#125;</span><br><span class="line">从内存中加载数据到 Cacheline;</span><br><span class="line">    写 Cacheline;</span><br><span class="line">&#125;</span><br><span class="line">将 Cacheline 标记为脏;</span><br></pre></td></tr></table></figure><h3 id="多核导致的-Cache-不一致现象"><a href="#多核导致的-Cache-不一致现象" class="headerlink" title="多核导致的 Cache 不一致现象"></a>多核导致的 Cache 不一致现象</h3><p>现有两个核心 A,B，每个核心有自己独属的 Cache。它们都读取一个共享变量 i，并用<strong>写回策略</strong>对 i 进行 ++ 操作，整个流程可以用下图表示：</p><p><img src="https://s4.ax1x.com/2022/03/05/b01IMt.png"></p><p>由于它们都在 i = 0 时缓存了 i，并对 i 做 ++ 操作，因此最终将会导致 i = 1 而非 2；原因在于 A 核心执行 i++ 后没有将结果同步到 B 核心缓存的 i 变量上面去，也就是 i 这个共享变量的一致性遭到了破坏。</p><p>那么如何解决这个问题呢？最简单的想法就是，<strong>最好我修改之前看到的变量已经是最新的了，在我修改之后立马让所有核心看到最新的值</strong>。</p><ul><li>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播（<em>Write Propagation</em>）</strong></li><li>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串形化（<em>Transaction Serialization</em>）</strong>。</li></ul><h3 id="MESI-协议-总线嗅探机制-实现-写传播和事务串行化"><a href="#MESI-协议-总线嗅探机制-实现-写传播和事务串行化" class="headerlink" title="MESI 协议 + 总线嗅探机制 实现 写传播和事务串行化"></a>MESI 协议 + 总线嗅探机制 实现 写传播和事务串行化</h3><p>​    下图是 CPU Cache 的概览图，Cache 可以分成多个 Cacheline，每个 Cacheline 里有一个 Tag 和一个数据块。<strong>其实除此之外，还记录了当前 Cacheline 与物理地址之间的映射</strong>。Tag 中有四种标记：</p><ul><li>M: Modified</li><li>E: Exclude</li><li>S: Shared</li><li>I: Invalid</li></ul><p><img src="https://s1.ax1x.com/2022/03/07/b6ABVg.png"></p><p>​    <strong>总线嗅探机制</strong>，wiki 解释：<strong>Bus snooping</strong> or <strong>bus sniffing</strong> is a scheme by which a coherency controller (snooper) in a <a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache</a> (a <strong>snoopy cache</strong>) monitors or snoops the bus transactions, and its goal is to maintain a <a href="https://en.wikipedia.org/wiki/Cache_coherence">cache coherency</a> in <a href="https://en.wikipedia.org/wiki/Distributed_shared_memory">distributed shared memory systems</a>.</p><blockquote><p><strong>How it works?</strong> When specific data is shared by several caches and a processor modifies the value of the shared data, the change must be propagated to all the other caches which have a copy of the data. This change propagation prevents the system from violating <a href="https://en.wikipedia.org/wiki/Cache_coherence">cache coherency</a>. The notification of data change can be done by bus snooping. All the snoopers monitor every transaction on a bus. If a transaction modifying a shared cache block appears on a bus, all the snoopers check whether their caches have the same copy of the shared block. If a cache has a copy of the shared block, the corresponding snooper performs an action to ensure cache coherency. The action can be a <a href="https://forums.xilinx.com/t5/Embedded-Development-Tools/what-is-the-difference-between-cache-invalidate-and-cache-flush/td-p/74654">flush</a> or an <a href="https://en.wikipedia.org/wiki/Cache_invalidation">invalidation</a> of the cache block. It also involves a change of cache block state depending on the cache coherence protocol.</p></blockquote><p>​    其实上面的意思是当<strong>被多个核心中的 Cache 共享的数据</strong>将要发生改变时，这个<strong>即将发生改变的通知</strong>会通过总线广播到所有核心并被 Cache 中的嗅探器捕捉到，随后做出一系列操作来保证 Cache 一致性。所以这里嗅探器其实会查看自己是否拥有这个共享数据，据推断就是通过 Cacheline 与物理地址之间的映射来做判断的。</p><p>​    <strong>MESI 协议</strong>是 cache 一致性协议中的一种，也比较好理解。它借助 Cacheline 中的 Tag 标记以及 总线嗅探机制实现了一个状态机，从而实现<strong>写传播</strong>和<strong>事务串行化</strong>。</p><p>​    MESI 每一个标记都是一种状态，那么就有 4 种状态；每一种状态下，嗅探器都可能从总线上嗅探到 4 种通知：local read，local write，remote read，remote write（其实就是 local，remote 和 read，write 的排列组合）。某个核心中共享的 Cacheline 会根据自己所处的状态以及嗅探到的通知来进行状态之间的转换：</p><p><img src="https://s1.ax1x.com/2022/03/07/b6u1yR.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/98560121">《CPU到底有多快？内存：是我的250倍》</a></li><li><a href="https://www.zhihu.com/question/349982942">内存运行速度</a></li><li><a href="https://blog.csdn.net/qq_34827674/article/details/109317760">10 张图打开 CPU 缓存一致性的大门</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Cache-Coherence&quot;&gt;&lt;a href=&quot;#Cache-Coherence&quot; class=&quot;headerlink&quot; title=&quot;Cache Coherence&quot;&gt;&lt;/a&gt;Cache Coherence&lt;/h2&gt;&lt;p&gt;​    cache coheren</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Fiber 库</title>
    <link href="https://codroc.github.io/2022/02/27/Fiber/"/>
    <id>https://codroc.github.io/2022/02/27/Fiber/</id>
    <published>2022-02-27T13:29:12.000Z</published>
    <updated>2022-02-27T13:29:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于-ucontext-封装的-Fiber-库"><a href="#基于-ucontext-封装的-Fiber-库" class="headerlink" title="基于 ucontext 封装的 Fiber 库"></a>基于 ucontext 封装的 Fiber 库</h1><p>协程优点：</p><ul><li>切换速度快</li><li>切换灵活</li><li>为降低竞争提供另一种思路</li><li>实现异步 epoll</li></ul><p>​    协程是轻量级的线程，由于协程切换属于 用户级别的上下文切换，不会陷入内核，因此切换速度比线程更快自然延迟更低。根据陈海波老师的《<a href="https://www.zhihu.com/search?q=%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2153166653%7D">现代操作系统 原理与实现</a>》一书的105页中： <strong>经过测试，在使用AArch64架构的华为鲲鹏916服务器上，如果使用内核态线程，那么生产者线程切换到消费者线程需要话费约1900ns；而如果使用纤程，该切换时间降低到约500ns。</strong>可以看到差距的巨大。</p><p>​    由于协程切换是在用户级别进行的，因此完全由用户自主操控，想要在哪里切换就在哪里切换，十分灵活。</p><p>​    可以使用多进程（单线程）+协程尽可能的避免race condition，降低各种竞争，从而降低延迟。例如一个线程就可以实现生产者消费者模型，并且不需要加锁。</p><p>​    怎么实现异步 epoll？</p><p>Fiber 库特性：</p><ul><li>非对称协程</li><li>基于 POSIX ucontext.h</li></ul><p>​    我设计的 Fiber 库，每个线程都有一个主协程，并能创建多个子协程；子协程只能把 CPU 控制权交还给主协程，而不能交给其他子协程，故而为非对称协程。</p><p>​    该 Fiber 库基于 ucontext.h 实现</p><hr><p>Fiber 库应该具有的功能：</p><ul><li>隐藏主协程创建的接口，暴露子协程创建接口</li><li>从主协程切换（swapIn）到子协程</li><li>从子协程切换（swapOut）到主协程</li><li>子协程执行代码的入口函数</li><li>协程清理</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fiber</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">// 暴露子协程创建接口</span></span><br><span class="line">     Fiber(<span class="keyword">const</span> Fiber::Callback&amp; cb, <span class="keyword">size_t</span> stackSize);</span><br><span class="line">     <span class="comment">// 获取当前协程 </span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> ptr <span class="title">GetThis</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">// 设置当前协程</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetThis</span><span class="params">(ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 切换到该协程</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">swapIn</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">// 切换到主协程</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">swapOut</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 隐藏主协程创建的接口</span></span><br><span class="line">    Fiber();</span><br><span class="line">     <span class="comment">// 所有协程入口函数</span></span><br><span class="line">     <span class="comment">// 如同所有进程的入口 main 一样</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MainFunc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">ucontext_t</span> _ctx;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的重点在于为每一个线程创建一个 thread_local 用于存储 主协程指针 <code>t_threadFiber</code> 和 当前协程指针 <code>t_curFiber</code>，这样的话就能根据 这两个变量进行 主协程与子协程 间的切换了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber::ptr t_curFiber = <span class="literal">nullptr</span>; <span class="comment">// 当前协程</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber::ptr t_threadFiber = <span class="literal">nullptr</span>; <span class="comment">// 主协程,只有当线程退出时，才会将主协程析构</span></span><br><span class="line"><span class="comment">// 切换到该协程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::swapIn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SetThis(shared_from_this());</span><br><span class="line">    <span class="comment">// 主协程即将切换出去</span></span><br><span class="line">    <span class="comment">// 把上下文保存到 主协程的 ctx 中，并恢复该协程的上下文</span></span><br><span class="line">    ::swapcontext(&amp;t_threadFiber-&gt;_ctx, &amp;_ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 切换到主协程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::swapOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SetThis(t_threadFiber);</span><br><span class="line">    <span class="comment">// 即将从子协程切换出去</span></span><br><span class="line">    <span class="comment">// 把上下文保存到 该协程的 ctx 中，并恢复主协程的上下文</span></span><br><span class="line">    ::swapcontext(&amp;_ctx, &amp;t_threadFiber-&gt;_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>性能测试</strong></p><p>鲲鹏通用计算增强型 2G、1CPU 、1Core：</p><ul><li>协程：切换 100w 次 需要 814ms</li><li>线程：通过生产者消费者队列（队列长度为 1）进行测试（当然有加锁，解锁，条件变量等额外的操作）。切换 100w 次 需要 3300ms（3微秒/切换）</li></ul><p>Inter(R) Core(TM) i7-9700 CPU @ 3.00GHz ，7 Core、4G虚拟机：</p><ul><li>协程：切换 100w 次 需要 430ms</li><li>线程：通过生产者消费者队列（队列长度为 1）进行测试（当然有加锁，解锁，条件变量等额外的操作）。切换 100w 次 需要 32000ms（32微秒/切换）</li></ul><p><strong>分析：</strong></p><p>协程比线程快这是不言而喻的，但是线程上表现出来的数值就很奇怪了，在 1 Core 的鲲鹏虚拟机上 切换一次线程费时 大约 3微秒；但在更快的 i7-9700 CPU 虚拟机上却要 32微秒；这是为什么呢？</p><p>其实这两台实验设备上最大的差别就是<strong>一个是单核一个是多核</strong>。多个核共享一个变量，并把变量保存在 cacheline 中，当某个核要对该变量进行读写操作时，就要保证能看到其他核的 cacheline 中关于该变量的最新的值。这就存在 cacheline 同步的问题，只能等待 CPU 完成<a href="https://en.wikipedia.org/wiki/Cache_coherence">一致性同步</a>之后才能继续用户操作。这就导致速度变得很慢。</p><p><strong>至理名言：</strong>要提高性能，就要避免让CPU频繁同步cacheline。这不单和原子指令本身的性能有关，还会影响到程序的整体性能。最有效的解决方法很直白：<strong>尽量避免共享</strong>。                                                        —–bRPC</p><blockquote><p>一个相关的编程陷阱是false sharing：对那些不怎么被修改甚至只读变量的访问，由于同一个cacheline中的其他变量被频繁修改，而不得不经常等待cacheline同步而显著变慢了。多线程中的变量尽量按访问规律排列，频繁被其他线程修改的变量要放在独立的cacheline中。要让一个变量或结构体按cacheline对齐</p></blockquote><hr><p><strong>存在的问题：</strong></p><p>如果用户调用 swapIn 和 swapOut 的顺序不对，可能会导致 Fiber 对象无法正常释放资源，导致资源泄露。因此要设计一个自动回收永远不会再用到的 Fiber 对象的类。</p><p>当然这一点可以通过再设计一个协程调度器类来解决，把所有的 Fiber 实现都隐藏起来，也就是说用户不能自己去 swapIn、swapOut 了，全权交给调度器去做，仅仅支持用户注册一个协程或想要执行的实例。</p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于-ucontext-封装的-Fiber-库&quot;&gt;&lt;a href=&quot;#基于-ucontext-封装的-Fiber-库&quot; class=&quot;headerlink&quot; title=&quot;基于 ucontext 封装的 Fiber 库&quot;&gt;&lt;/a&gt;基于 ucontext 封装的 F</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MVCC</title>
    <link href="https://codroc.github.io/2021/12/24/MVCC/"/>
    <id>https://codroc.github.io/2021/12/24/MVCC/</id>
    <published>2021-12-23T16:00:00.000Z</published>
    <updated>2021-12-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC 即<strong>多版本并发控制</strong>，是在并发事务场景下用于支持 RC、RR 隔离级别的实现</p><p>四种隔离级别：</p><ul><li>读未提交</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatable Read）</li><li>串行</li></ul><p>事务隔离是怎么实现的？</p><p>在 mysql 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作（undo log），都可以得到前一个状态的值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="https://s4.ax1x.com/2021/12/23/T8oNDg.png"></p><p>这里可以看到一条记录存在多个版本，着就是 MVCC 的 MV 的由来。</p><h4 id="mysql-中存在两个“视图”的概念："><a href="#mysql-中存在两个“视图”的概念：" class="headerlink" title="mysql 中存在两个“视图”的概念："></a>mysql 中存在两个“视图”的概念：</h4><ul><li>一个是 view。它是用一个查询语句定义的虚拟表</li><li>另一个是 Innodb 中实现 MVCC 时用到的<strong>一致性读视图</strong>（consistent <strong>read view</strong>），用于支持 RC、RR 隔离级别的实现</li></ul><p><strong>一致性视图</strong>的创建时机有两种：</p><ul><li>在 begin/start transaction 后的第一条语句开始时创建</li><li>在 执行 start transaction with consistent snapshot 时创建</li></ul><p>这个 <strong>一致性视图</strong> 是什么东西？它其实就是一个“快照”，如果在可重复读隔离级别下的话，是对整个库的快照。它是怎么实现的呢？（即 MVCC 是怎么实现 RC、RR 隔离级别的呢？）</p><p>分四部分讲：</p><ul><li>事务 ID</li><li>行记录隐藏列</li><li>undo log</li><li>ReadView</li></ul><hr><h4 id="事务-ID"><a href="#事务-ID" class="headerlink" title="事务 ID"></a>事务 ID</h4><p>innodb 里面每个事务有一个<strong>唯一的事务 ID</strong>，它是事务开始时向 innodb 的事务系统申请的，是按申请顺序严格递增的。</p><h4 id="行记录的隐藏列"><a href="#行记录的隐藏列" class="headerlink" title="行记录的隐藏列"></a>行记录的隐藏列</h4><ul><li>row_id: 隐藏的行 ID ，用来生成默认的聚集索引。如果创建数据表时没指定聚集索引，这时 innodb 就会用这个隐藏 ID 来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率</li><li>trx_id: 即最后一个对数据插入或者更新的事务 ID，每一次<strong>事务</strong>对索引对应的记录进行改动时，都会把该事务的 ID 赋值给 trx_id</li></ul><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p><img src="https://s4.ax1x.com/2021/12/24/TJ7ttH.png" alt="undo log"></p><p>这里 U1、U2、U3 都是 undo log，如果最新版本的记录 V4 要回到 V3 只要通过 U3 就可以了，同理回到 V2 只要通过 U3、U2 就可以了。</p><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>ReadView 中主要包含4个比较重要的内容：</p><ul><li>m_ids：表示在生成 ReadView 时当前系统中活跃（值事务启动了但还没提交）的读写事务的事务 id 列表</li><li>min_trx_id：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的事务 id，也就是 m_ids 中的最小值</li><li>max_trx_id：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值</li><li>creator_trx_id：表示生成该 ReadView 的事务的事务 id</li></ul><p><img src="https://s4.ax1x.com/2021/12/23/T8OSRs.jpg" alt="ReadView"></p><h4 id="ReadView-是如何工作的？"><a href="#ReadView-是如何工作的？" class="headerlink" title="ReadView 是如何工作的？"></a>ReadView 是如何工作的？</h4><p>有了这些信息，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问</li><li>如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问</li><li>如果被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问</li><li>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问</li></ul><p><strong>innodb 利用了 “所有数据都有多个版本” 的特性，实现了 “秒级创建快照” 的能力。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MVCC&quot;&gt;&lt;a href=&quot;#MVCC&quot; class=&quot;headerlink&quot; title=&quot;MVCC&quot;&gt;&lt;/a&gt;MVCC&lt;/h2&gt;&lt;p&gt;MVCC 即&lt;strong&gt;多版本并发控制&lt;/strong&gt;，是在并发事务场景下用于支持 RC、RR 隔离级别的实现&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMake Template</title>
    <link href="https://codroc.github.io/2021/12/14/cmake_templates/"/>
    <id>https://codroc.github.io/2021/12/14/cmake_templates/</id>
    <published>2021-12-14T08:01:19.233Z</published>
    <updated>2021-12-14T08:01:19.233Z</updated>
    
    <content type="html"><![CDATA[<p>常用 <strong>CMake</strong> 模板，边学边更新</p><span id="more"></span><!-- vim-markdown-toc GitLab --><ul><li><a href="#%E7%8E%AF%E5%A2%83">环境</a></li><li><a href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">简单介绍</a></li><li><a href="#%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%8E%E5%A4%B4%E6%96%87%E4%BB%B6%E9%83%BD%E5%9C%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B">源文件与头文件都在根目录下</a><ul><li><a href="#%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F">内置变量</a></li></ul></li><li><a href="#%E6%BA%90%E6%96%87%E4%BB%B6%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E5%88%86%E5%BC%80%E5%AD%98%E6%94%BE">源文件和头文件分开存放</a></li><li><a href="#%E6%89%BE%E8%B7%AF%E5%BE%84">找路径</a></li><li><a href="#%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%BA%93%E6%88%96%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6">生成静态库或共享库文件</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>我个人使用的是 <strong>Ubuntu18.04</strong>，可以通过 <code>sudo apt install cmake</code> 来安装 <strong>CMake</strong>，在终端输入 <code>cmake --version</code> 可查看版本。</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p><strong>CMake</strong> 是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个库。 它用配置文件控制建构过程 <em>（build process）</em> 的方式和 <strong>Unix 的 make</strong> 相似，只是 <strong>CMake</strong> 的配置文件取名为 <strong>CMakeLists.txt</strong>。<strong>CMake</strong> 并不直接建构出最终的软件，而是产生标准的建构档（如 <strong>Unix的Makefile</strong> 或 <strong>Windows Visual C++的projects/workspaces</strong>），然后再依一般的建构方式使用。</p><p>上面这句话摘自 <a href="https://zh.wikipedia.org/wiki/CMake">Wiki</a>，它说的是什么意思？如果你跟我一样在 <strong>linux</strong> 环境下工作，那么你一定听过 <strong>make</strong>，<strong>make</strong> 能够根据 <strong>makefile</strong> 文件中的说明来一步步地自动构建目标文件；<strong>make</strong> 是一种工具（可执行程序），<strong>makefile</strong> 是文件，里面说明了如何去构建目标文件，<strong>make</strong> 程序会从 <strong>makefile</strong> 中一条条地读出相关的指令去执行。那么 <strong>CMake</strong> 和 <strong>makefile</strong> 有什么关系呢？在没有 <strong>CMake</strong> 之前，我们需要自己动手写 <strong>makefile</strong>，然后去运行 <strong>make</strong>，而这需要你去学习 <strong>makefile</strong> 的语法，十分费时费精力；而现在有了 <strong>CMake</strong>，它可以根据你的指示(都写在 <strong>CMakeLists.txt</strong> 中)自动地去生成 <strong>makefile</strong>，然后你再用 <strong>make</strong> 去构建目标文件即可。写 <strong>CMakeLists.txt</strong> 比写 <strong>makefile</strong> 可容易太多了！</p><h1 id="源文件与头文件都在根目录下"><a href="#源文件与头文件都在根目录下" class="headerlink" title="源文件与头文件都在根目录下"></a>源文件与头文件都在根目录下</h1><p>这种是最简单的情况，例如我的目录下有这些文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── hello.c</span><br><span class="line">├── main.c</span><br><span class="line">├── hello.h</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure><p>如果在 g++ 中执行时命令是这样的：<code>g++ hello.c main.c -o main</code><br>那么我可以在当前目录下编写 <strong>CMakeLists.txt</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8)</span><br><span class="line"></span><br><span class="line">project(main VERSION 1.0)</span><br><span class="line"></span><br><span class="line">add_executable(main hello.c main.c)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>cmake_minimum_required(VERSION)</code> 用来表示可接受的 <strong>CMake</strong> 最低版本</li><li><code>project(name)</code> 用来定义项目名称</li><li><code>add_executable(name sources)</code> 第一个参数是项目名称，第二个参数是源文件名(多个文件名之间用空格隔开)</li></ul><p>编写完 <strong>CMakeLists.txt</strong> 文件后，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>可以看到目标文件已经构建完成！现在的目录层级是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── main</span><br><span class="line">│   └── makefile ...</span><br><span class="line">├── hello.c</span><br><span class="line">├── main.c</span><br><span class="line">├── hello.h</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure><p>这里创建 build 目录是为了更好的层次化管理文件，build 目录内放置所有的二进制文件，而源文件和头文件一般都在项目根目录下</p><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><p><strong>CMake</strong> 定义了相当丰富的变量，然而，我常用的也就那几个。</p><table><thead><tr><th align="left">name</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">PROJECT_BINARY_DIR</td><td align="left">是指包含最近的 project() 命令的 build 目录</td></tr><tr><td align="left">PROJECT_SOURCE_DIR</td><td align="left">是指包含最近的 project() 命令的 CMakeLists.txt 的目录</td></tr><tr><td align="left">CMAKE_CURRENT_BINARY_DIR</td><td align="left">当前处理的 CMakeLists.txt 所在的 build 目录</td></tr><tr><td align="left">CMAKE_CURRENT_SOURCE_DIR</td><td align="left">当前处理的 CMakeLists.txt 所在的目录</td></tr><tr><td align="left">CMAKE_SOURCE_DIC</td><td align="left">指定义了顶级 CMakeLists.txt 的目录</td></tr><tr><td align="left">EXECUTABLE_OUTPUT_PATH</td><td align="left">生成的可执行文件的存储目录</td></tr><tr><td align="left">LIBRARY_OUTPUT_PATH</td><td align="left">生成的库的存储目录</td></tr><tr><td align="left">PROJECT_NAME</td><td align="left">项目名称</td></tr><tr><td align="left">PROJECT_VERSION_MAJOR</td><td align="left">项目主版本号（例如 2.8 的主版本号是 2）</td></tr><tr><td align="left">PROJECT_VERSION_MINOR</td><td align="left">项目次版本号 （例如 2.8 的次版本号是 8）</td></tr><tr><td align="left">PROJECT_VERSION_PATCH</td><td align="left">项目版本的补丁号（例如 2.8.1 的补丁号是 1）</td></tr><tr><td align="left">BUILD_SHARED_LIBS</td><td align="left">用于控制 cmake 的 add_library 指令是否默认生成 动态so（yes if flag=on）还是 静态库.a （if flag=off）。默认是 flag=on</td></tr><tr><td align="left">CMAKE_C_FLAGS</td><td align="left">编译器 gcc 的标志</td></tr><tr><td align="left">CMAKE_CXX_FLAGS</td><td align="left">编译器 g++ 的标志</td></tr></tbody></table><p>记不住变量的值时，可以使用 cmake 的 <strong>message 函数</strong>输出变量值。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(show_vars VERSION <span class="number">1.0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了分行确定输出内容</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;1.PROJECT_BINARY_DIR = $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;2.PROJECT_SOURCE _DIR = $&#123;_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;3.CMAKE_CURRRENT_BINARY_DIR = $&#123;CMAKE_CURRRENT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;4.CMAKE_CURRENT_SOURCE_DIR = $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;5.CMAKE_SOURCE_DIR = $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;6.EXECUTABLE_OUTPUT_PATH = $&#123;EXECUTABLE_OUTPUT_PATH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;7.LIBRARY_OUTPUT_PATH = $&#123;LIBRARY_OUTPUT_PATH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;8.PROJECT_NAME = $&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;9.PROJECT_VERSION_MAJOR = $&#123;PROJECT_VERSION_MAJOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;10.PROJECT_VERSION_MINOR = $&#123;PROJECT_VERSION_MINOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;11.PROJECT_VERSION_PATCH = $&#123;PROJECT_VERSION_PATCH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;12.BUILD_SHARED_LIBS = $&#123;BUILD_SHARED_LIBS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;13.CMAKE_C_FLAGS = $&#123;CMAKE_C_FLAGS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;14.CMAKE_CXX_FLAGS = $&#123;CMAKE_CXX_FLAGS&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="源文件和头文件分开存放"><a href="#源文件和头文件分开存放" class="headerlink" title="源文件和头文件分开存放"></a>源文件和头文件分开存放</h1><p>现在有以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── hello.h</span><br><span class="line">└── source</span><br><span class="line">    ├── hello.cc</span><br><span class="line">    └── main.cc</span><br></pre></td></tr></table></figure><p>这种情况下的 CMakeLists.txt 文件应该这样编写：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/source/*.cc</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(main SOURCES)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(main PRIVATE <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p><strong>set(name value)</strong> 可以自己定义一个变量，<em>name</em> 是变量名，<em>value</em> 是变量值</p><p>这里 <em>PROJECT_SOURCE_DIR</em> 的值就是 <em>./</em> (项目根目录)</p><p><strong>target_include_directories(<target> &lt;PRIVATE|INTERFACE|PUBLIC&gt; [item])</target></strong> 是用来标明头文件路径的，相当于编译器选项的 <strong>-I</strong>, 这里 <em>target</em> 就是项目名称，<em>&lt;PRIVATE|INTERFACE|PUBLIC&gt;</em> 三种属性我现在还没搞懂。。。*[item]* 就是头文件路径。</p><p>你可以在 make 时开启输出模式 <code>make VERBOSE=1</code> 来看看编译器的参数，应该是:<br><code>g++ -I 根目录/include 根目录/hello.cc 根目录/main.cc -o 根目录/build/main </code></p><h1 id="找路径"><a href="#找路径" class="headerlink" title="找路径"></a>找路径</h1><p>cmake find_path 命令用来寻找包含指定文件名称的目录。</p><p>通常，它的签名如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_path</span> (</span><br><span class="line">          &lt;VAR&gt;</span><br><span class="line">          name | NAMES name1 [name2 ...]</span><br><span class="line">          [HINTS path1 [path2 ... ENV var]]</span><br><span class="line">          [PATHS path1 [path2 ... ENV var]]</span><br><span class="line">          [PATH_SUFFIXES suffix1 [suffix2 ...]]</span><br><span class="line">          [DOC <span class="string">&quot;cache documentation string&quot;</span>]</span><br><span class="line">          [REQUIRED]</span><br><span class="line">          [NO_DEFAULT_PATH]</span><br><span class="line">          [NO_PACKAGE_ROOT_PATH]</span><br><span class="line">          [NO_CMAKE_PATH]</span><br><span class="line">          [NO_CMAKE_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_SYSTEM_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_CMAKE_SYSTEM_PATH]</span><br><span class="line">          [CMAKE_FIND_ROOT_PATH_BOTH |</span><br><span class="line">           ONLY_CMAKE_FIND_ROOT_PATH |</span><br><span class="line">           NO_CMAKE_FIND_ROOT_PATH]</span><br><span class="line">         )</span><br></pre></td></tr></table></figure><p><code>&lt;VAR&gt;</code> 是一个变量，用于存放该命令得到的结果。它有点像 find 命令，如果在某个目录下找到了指定的文件名，目录名将会存到 <code>&lt;VAR&gt;</code> 变量中，并且 find 搜索将会停止！如果没有找到，结果将会是<code>&lt;VAR&gt;-NOTFOUND</code>。</p><p>举个栗子就懂了，例如 muduo-tutorial 项目 cmake 目录下的 CMakeLists.txt 文件中有这样两行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set(MUDUO_PATH &quot;/opt/muduo_hdrs_libs&quot;)</span></span><br><span class="line"><span class="keyword">find_path</span>(Muduo_INCLUDE_DIR muduo <span class="string">&quot;$&#123;MUDUO_PATH&#125;/include&quot;</span>)</span><br><span class="line"><span class="keyword">find_path</span>(Muduo_LIBRARY_DIR libmuduo_net.a <span class="string">&quot;$&#123;MUDUO_PATH&#125;/lib&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls /opt/muduo_hdrs_libs</span><br><span class="line">inludelib</span><br><span class="line">$ ls /opt/muduo_hdrs_libs/include</span><br><span class="line">muduo</span><br><span class="line">$ ls /opt/muduo_hdrs_libs/lib</span><br><span class="line">libmuduo_base.a  libmuduo_http.a  libmuduo_inspect.a  libmuduo_net.a  libmuduo_pubsub.a</span><br></pre></td></tr></table></figure><p>因此我这里 Muduo_INCLUDE_DIR 就是 <code>/opt/muduo_hdrs_libs/include</code>，Muduo_LIBRARY_DIR 就是 <code>/opt/muduo_hdrs_libs/lib</code>。</p><h1 id="生成静态库或共享库文件"><a href="#生成静态库或共享库文件" class="headerlink" title="生成静态库或共享库文件"></a>生成静态库或共享库文件</h1><p>可以使用 add_library(libname, srcs) 来生产静态库</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.<a href="https://mlog.club/article/1918025">https://mlog.club/article/1918025</a><br>2. <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html#packaging-debug-and-release-step-12">https://cmake.org/cmake/help/latest/guide/tutorial/index.html#packaging-debug-and-release-step-12</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用 &lt;strong&gt;CMake&lt;/strong&gt; 模板，边学边更新&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
