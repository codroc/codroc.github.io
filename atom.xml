<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Codroc Blog</title>
  
  
  <link href="https://codroc.github.io/atom.xml" rel="self"/>
  
  <link href="https://codroc.github.io/"/>
  <updated>2022-05-15T11:57:16.000Z</updated>
  <id>https://codroc.github.io/</id>
  
  <author>
    <name>Codroc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RPC 相关的一些文章与概念</title>
    <link href="https://codroc.github.io/2022/05/15/rpc%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://codroc.github.io/2022/05/15/rpc%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-05-15T11:57:16.000Z</published>
    <updated>2022-05-15T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC-的概念"><a href="#RPC-的概念" class="headerlink" title="RPC 的概念"></a>RPC 的概念</h1><p>RPC 是 Remote Procedure Call 的缩写。即<strong>远端过程调用</strong>。</p><p>过程可以理解为函数，远端可以理解为非本地的。</p><p>可以参考与之相反的函数本地调用，它是发生在同一个进程环境中的。先来看看它的流程：<br><a href="C:\Users\codroc\Pictures\pictures\RPC图1.PNG">本地函数调用</a></p><p>这段代码，我们知道，传入了1，2两个入参数，调用了本地代码段中的一个 Add 函数，得到了 result 出参。此时，传入数据，传出数据，代码段在同一个进程空间里，这是本地函数调用。</p><p>而 RPC 是跨进程的函数调用（大多数情况下是跨主机的），它可以用以下流程表示：<br><a href="C:\Users\codroc\Pictures\pictures\RPC图2.PNG">远端函数调用</a></p><h1 id="RPC-的作用"><a href="#RPC-的作用" class="headerlink" title="RPC 的作用"></a>RPC 的作用</h1><p>为什么要使用 RPC？我相信很多刚了解 RPC 的人都会想这个问题。对于很多人来说这其实是两个问题，<font color="red">一：为什么不把函数、方法都放在本地而要去调用远程的？二：不就是调用了一下不在本地的方法嘛，可以用 HTTP 协议通信来实现啊，为什么非要用 RPC 框架呢？</font></p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>我仔细地想过，没有绝对的答案，必须要因地制宜，具体情况具体分析。如果你只是设计一个简单的应用（比如一个静态博客），那么把函数或方法都放在本地就可以了，还减去了网络通信上的时延。</p><p>但是如果你要设计复杂的高并发系统（例如tb，pdd），你就不得不考虑到很多问题，<font color="red">例如系统的<a href="https://www.w3cschool.cn/architectroad/architectroad-high-availability.html">高可用</a>，高可靠，<a href="https://www.w3cschool.cn/architectroad/architectroad-high-concurrent.html">高并发</a>，可扩展性，系统维护等等。</font>这种系统一定是<a href="https://www.cnblogs.com/xybaby/p/7787034.html">分布式系统</a>！在分布式系统中，RPC 是很常见的。</p><hr><p>简单的从几个角度分析，复杂系统必须用分布式系统：</p><p>高可用：一个进程 cresh 了，或一台机器宕机了，或一处网络断掉了，都会导致系统不可用。为了<font color="red">防止尽量减少系统的不能提供服务的时间，必定是要做“集群化”，或者叫“冗余”</font>：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他 backup 能够顶上。</p><p>高并发：一台机器的性能是有极限的，当一台机器处理不过来时（或是存储不够时），增加服务器数量能够直接解决问题。</p><p>系统维护：复杂的系统，往往由多个功能子系统构成，如果把所有子系统都放在同一个环境下，代码的维护将变得十分困难。版本的迭代很可能出现 Bug，一旦一个功能出现问题，由于所有功能都放在了一起，导致所有的代码都要回滚。</p><hr><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>用 HTTP 协议来通信或自己设计一种通信协议不也可以做到远端的过程调用吗，那为什么非要搞出个 RPC 呢？</p><p>可以去看这篇<a href="https://www.w3cschool.cn/architectroad/architectroad-rpc-framework.html">文章</a>的“需求缘起”小节！</p><h1 id="RPC-框架的目的"><a href="#RPC-框架的目的" class="headerlink" title="RPC 框架的目的"></a>RPC 框架的目的</h1><p>目的只有一个，对整个远端过程调用进行抽象，减少业务之外的重复性技术劳动。</p><ul><li><font color="red">调用方像调用本地函数一样去调用远端的函数（服务）。</font></li><li><font color="red">服务提供方就像实现本地函数一样来实现函数。</font></li></ul><h1 id="RPC-技术点"><a href="#RPC-技术点" class="headerlink" title="RPC 技术点"></a>RPC 技术点</h1><p>RPC 一般分为 RPC-Client 和 RPC-Server，其中 RPC-Client 对服务的访问方式又分为同步访问、异步访问和半同步访问。</p><p>在 RPC-Client 中，一般需要用到以下技术点：</p><ul><li>共同技术点：序列化反序列化，连接池，故障检测，负载均衡，超时处理等</li><li>异步访问多了以下几点：上下文管理，收发队列，收发线程等</li></ul><p>这篇文章已经很好的总结了这些要点：<a href="https://www.w3cschool.cn/architectroad/architectroad-rpc-client-asynchronous-send-and-receive.html">RPC-Client异步收发</a></p><p>至于更多的技术点，我建议去看 <a href="https://github.com/apache/incubator-brpc">brpc</a>，它是国内非常优秀的 RPC 框架，并配有十分详细的文档，看了让人受益匪浅！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/xybaby/p/7787034.html">分布式系统介绍</a></li><li><a href="https://www.w3cschool.cn/architectroad/architectroad-high-availability.html">高可用</a></li><li><a href="https://www.w3cschool.cn/architectroad/architectroad-high-concurrent.html">高并发</a></li><li><a href="https://www.w3cschool.cn/architectroad/architectroad-rpc-client-asynchronous-send-and-receive.html">RPC-Client异步收发</a></li><li><a href="https://www.w3cschool.cn/architectroad/architectroad-rpc-framework.html">RPC框架</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RPC-的概念&quot;&gt;&lt;a href=&quot;#RPC-的概念&quot; class=&quot;headerlink&quot; title=&quot;RPC 的概念&quot;&gt;&lt;/a&gt;RPC 的概念&lt;/h1&gt;&lt;p&gt;RPC 是 Remote Procedure Call 的缩写。即&lt;strong&gt;远端过程调用&lt;/s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++ Chrono 库使用记录</title>
    <link href="https://codroc.github.io/2022/05/12/chrono%E5%BA%93/"/>
    <id>https://codroc.github.io/2022/05/12/chrono%E5%BA%93/</id>
    <published>2022-05-12T11:57:16.000Z</published>
    <updated>2022-05-12T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-17-chrono-库"><a href="#c-17-chrono-库" class="headerlink" title="c++17 chrono 库"></a>c++17 chrono 库</h1><p>记录下 chrono 库中常用的方法。</p><h3 id="1-获取格式化的当前日期"><a href="#1-获取格式化的当前日期" class="headerlink" title="1. 获取格式化的当前日期"></a>1. 获取格式化的当前日期</h3><p>本质还是 C 那一套：用 <code>struct tm* ctime(struct time_t*)</code> 接口，而在 C++ 中则是使用 <code>char* ctime(const std::time_t* time);</code> 接口。</p><p>可以使用 <code>std::time_t std::chrono::system_clock::to_time_t(const time_point&amp; t)</code> 接口获取 <code>std::time_t</code>，而 <code>time_point</code> 则可以用 <code>std::chrono::system_clock::now()</code> 接口获取。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> today = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(t);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::ctime(&amp;today) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c-17-chrono-库&quot;&gt;&lt;a href=&quot;#c-17-chrono-库&quot; class=&quot;headerlink&quot; title=&quot;c++17 chrono 库&quot;&gt;&lt;/a&gt;c++17 chrono 库&lt;/h1&gt;&lt;p&gt;记录下 chrono 库中常用的方法。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SSL</title>
    <link href="https://codroc.github.io/2022/04/22/SSL/"/>
    <id>https://codroc.github.io/2022/04/22/SSL/</id>
    <published>2022-04-22T11:57:16.000Z</published>
    <updated>2022-04-22T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h1><p>SSL 即 Secure Sockets Layer，是提高信道安全性的协议。不使用 SSL 的 HTTP 通信，是不安全的，所有信息明文传输。</p><blockquote><p>注意：SSL 应用于 socket，因此理论上 UDP、UnixSocket 都可以使用 SSL 协议。是现实反正我知道 openssl 可以运用于 TCP 和 UDP。查了资料显示，DTLS 协议实现了在 UDP 协议之上的 TLS 安全层。</p></blockquote><p>安全通信应该具有下列所需的特性：</p><ul><li>机密性：对数据进行加密，仅仅只有接收方和发送方能够对数据解密，其他方就算能获取数据也看不懂。（使用对称加密算法）</li><li>报文完整性：防止他人篡改数据。（可以用 MAC 来判断）</li><li>端点鉴别：鉴别另一方<strong>确实是</strong>我想要进行通信的一方。（可以用数字签名）</li></ul><p>几个基本概念：</p><ul><li>不重数</li><li>对称加密</li><li>非对称加密</li><li>哈希算法</li><li>MAC 报文鉴别码</li></ul><p><strong>不重数</strong>解决的是，防止 SSL 握手阶段<strong>重放攻击</strong>，基本的思想来自 TCP 握手阶段的 <strong>随机序号</strong>（保证了上次建立连接发送的 SYN 包不会引起下次连接）。</p><p>对称加密，必须是双方都持有同一密钥，那么就能对数据加密与解密。</p><p>非对称加密，可以用私钥加密，公钥解密（数字签名）；也可以用公钥加密私钥解密（加密通信）。</p><p>哈希算法，把非定常数据 hash 成定长字符串，无法解密，不可逆向，运算比较耗时。</p><p>MAC，即 Message Authentication Code 报文鉴别码。发送方发送在报文末尾带 MAC 的 package。MAC = h(m, s) 其中 h 为 hash 函数，m 为报文数据，s 为鉴别密钥；接收方用 鉴别密钥重新计算一遍 MAC，如果和报文末尾的一致，那么就可以保证报文的完整性。</p><p><strong>常见加密算法以及 Hash 函数：</strong></p><p>对称加密：AES、DES、Blowfish、CAST、IDEA、RC2、RC5</p><p>非对称加密：DH、RSA、DSA、EC</p><p>Hash 函数：MD5、SHA1、SHA2</p><h3 id="SSL-握手、通信、挥手的整个流程"><a href="#SSL-握手、通信、挥手的整个流程" class="headerlink" title="SSL 握手、通信、挥手的整个流程"></a>SSL 握手、通信、挥手的整个流程</h3><h4 id="1-SSL-握手"><a href="#1-SSL-握手" class="headerlink" title="1. SSL 握手"></a>1. SSL 握手</h4><p>(1) 客户端发送它支持的<strong>加密算法列表</strong>以及一个<strong>不重数</strong>。</p><p>(2) 服务器从列表中选出<strong>一个对称加密算法</strong>，<strong>一个非对称加密算法</strong>，<strong>一个 MAC 算法</strong>。它把<strong>三种算法</strong>连同自己的<strong>数字证书</strong>以及自己的<strong>不重数</strong>发给客户端。</p><p>(3) 根据 CA 给的公钥解密数字签名，得到 hash 值。验证该 hash 值是否和服务器发过来的元素经过 hash 后的值一致，来进行端点鉴别。</p><p>(4) 客户端生成一个 <strong>前主密钥</strong> PMS（Pre-Master Secret），并用服务器给的公钥加密该 PMS，然后发给服务器。</p><blockquote><p>注意：这里双方并不直接使用 PMS 对数据进行加密；而是，客户端和服务器分别通过 PMS 和自己收到的不重数，使用相同的密钥导出函数计算出自己的主密钥 MS（Master Secret），然后把 MS 切片成一个数据加密密钥 S 和一个 MAC。这样总共得到四个密钥，客户端和服务器共享这 4 个密钥。然后后面的机密性和数据完整性都由这 4 个密钥来实现。</p></blockquote><p>(5) optional</p><p>(6) optional</p><p>(7) 客户端发送一个加密后 “finished” 报文表示握手阶段结束。</p><p>(8) 服务端发送一个加密后 “finished” 报文表示握手阶段结束。</p><blockquote><p>注意：后续，客户端和服务器各需发送一个<em>所有握手报文的一个 MAC</em> 用于保证数据完整性，使握手免受篡改危害。见自顶向下p414.</p></blockquote><p>(9) 用 S 进行加密通信。用 MAC 保证数据完整性。</p><p><img src="https://s1.ax1x.com/2022/04/19/LDFMOU.png"></p><h4 id="2-SSL-挥手"><a href="#2-SSL-挥手" class="headerlink" title="2. SSL 挥手"></a>2. SSL 挥手</h4><p>不能简单的用 TCP FIN 来标识 SSL 挥手，因为这样会造成 <strong>截断攻击</strong>，即破坏者会直接发送一个 TCP FIN 过早的结束会话。具体见<strong>自顶向下p414.</strong></p><h3 id="使用-openssl-建立-安全-TCP-信道"><a href="#使用-openssl-建立-安全-TCP-信道" class="headerlink" title="使用 openssl 建立 安全 TCP 信道"></a>使用 openssl 建立 安全 TCP 信道</h3><p>这是 TCP 的安全通信。</p><p>OpenSSL 的 API 很多，但并不是都会被使用到，如果需要查看某个 API 的详细使用方法可以阅读 <a href="https://www.openssl.org/docs/">API文档</a>。</p><h4 id="1-1-初始化-OpenSSL"><a href="#1-1-初始化-OpenSSL" class="headerlink" title="1.1 初始化 OpenSSL"></a>1.1 初始化 OpenSSL</h4><p>  OpenSSL 在使用之前，必须进行相应的初始化工作。在建立 SSL 连接之前，要为 Client 和 Server 分别指定本次连接采用的协议及其版本，目前能够使用的协议版本包括 SSLv2、SSLv3、SSLv2/v3 和 TLSv1.0。SSL 连接若要正常建立，则要求 Client 和 Server 必须使用相互兼容的协议。</p><p>接下来是 openssl 库初始化的代码，根据 OpenSSL 的不同版本调用了不同的 API 进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OPENSSL_VERSION_NUMBER &gt;= 0x10100003L</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OPENSSL_init_ssl(OPENSSL_INIT_LOAD_CONFIG, <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;OPENSSL_init_ssl() failed!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * OPENSSL_init_ssl() may leave errors in the error queue</span></span><br><span class="line"><span class="comment">     * while returning success</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ERR_clear_error();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    OPENSSL_config(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    SSL_library_init();         <span class="comment">// 初始化SSL算法库函数( 加载要用到的算法 )，调用SSL函数之前必须调用此函数</span></span><br><span class="line">    SSL_load_error_strings();   <span class="comment">// 错误信息的初始化</span></span><br><span class="line"></span><br><span class="line">    OpenSSL_add_all_algorithms();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="1-2-创建-CTX"><a href="#1-2-创建-CTX" class="headerlink" title="1.2 创建 CTX"></a>1.2 创建 CTX</h4><p>  CTX 是 SSL 会话环境，建立连接时使用不同的协议，其 CTX 也不一样。创建 CTX 的相关 OpenSSL 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端、服务端都需要调用</span></span><br><span class="line">SSL_CTX_new();                       <span class="comment">//申请SSL会话环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若有验证对方证书的需求，则需调用</span></span><br><span class="line">SSL_CTX_set_verify(SSL_CTX *ctx, <span class="keyword">int</span> mode,</span><br><span class="line">     <span class="keyword">int</span> (*verify_callback)(<span class="keyword">int</span>, X509_STORE_CTX *)); <span class="comment">//指定证书验证方式</span></span><br><span class="line">SSL_CTX_load_verify_location();      <span class="comment">//为SSL会话环境加载本应用所信任的CA证书列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若有加载证书的需求，则需调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_use_certificate_file</span><span class="params">()</span></span>;      <span class="comment">//为SSL会话加载本应用的证书</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_use_certificate_chain_file</span><span class="params">()</span></span>;<span class="comment">//为SSL会话加载本应用的证书所属的证书链</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_use_PrivateKey_file</span><span class="params">()</span></span>;       <span class="comment">//为SSL会话加载本应用的私钥</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_check_private_key</span><span class="params">()</span></span>;         <span class="comment">//验证所加载的私钥和证书是否相匹配 </span></span><br></pre></td></tr></table></figure><h4 id="1-3-创建-SSL-套接字"><a href="#1-3-创建-SSL-套接字" class="headerlink" title="1.3 创建 SSL 套接字"></a>1.3 创建 SSL 套接字</h4><p>  在创建 SSL 套接字之前要先创建 Socket 套接字，建立 TCP 连接。创建 SSL 套接字相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SSL *<span class="title">SSl_new</span><span class="params">(SSL_CTX *ctx)</span></span>;          <span class="comment">//创建一个SSL套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_set_fd</span><span class="params">(SSL *ssl, <span class="keyword">int</span> fd)</span></span>;     <span class="comment">//以读写模式绑定流套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_set_rfd</span><span class="params">(SSL *ssl, <span class="keyword">int</span> fd)</span></span>;    <span class="comment">//以只读模式绑定流套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_set_wfd</span><span class="params">(SSL *ssl, <span class="keyword">int</span> fd)</span></span>;    <span class="comment">//以只写模式绑定流套接字</span></span><br></pre></td></tr></table></figure><h4 id="1-4-完成-SSL-握手"><a href="#1-4-完成-SSL-握手" class="headerlink" title="1.4 完成 SSL 握手"></a>1.4 完成 SSL 握手</h4><p>  在这一步，我们需要在普通 TCP 连接的基础上，建立 SSL 连接。与普通流套接字建立连接的过程类似：Client 使用函数SSL_connect()【类似于流套接字中用的connect()】发起握手，而 Server 使用函数 SSL_ accept()【类似于流套接字中用的accept()】对握手进行响应，从而完成握手过程。两函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_connect</span><span class="params">(SSL *ssl)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_accept</span><span class="params">(SSL *ssl)</span></span>;</span><br></pre></td></tr></table></figure><p>  握手过程完成之后，Client 通常会要求 Server 发送证书信息，以便对 Server 进行鉴别。其实现会用到以下两个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X509 *<span class="title">SSL_get_peer_certificate</span><span class="params">(SSL *ssl)</span></span>;  <span class="comment">//从SSL套接字中获取对方的证书信息</span></span><br><span class="line"><span class="function">X509_NAME *<span class="title">X509_get_subject_name</span><span class="params">(X509 *a)</span></span>; <span class="comment">//得到证书所用者的名字</span></span><br></pre></td></tr></table></figure><h4 id="1-5-数据传输"><a href="#1-5-数据传输" class="headerlink" title="1.5 数据传输"></a>1.5 数据传输</h4><p>  经过前面的一系列过程后，就可以进行安全的数据传输了。在数据传输阶段，需要使用 SSL_read( ) 和 SSL_write( ) 来代替普通流套接字所使用的 read( ) 和 write( ) 函数，以此完成对 SSL 套接字的读写操作,两个新函数的原型分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_read</span><span class="params">(SSL *ssl,<span class="keyword">void</span> *buf,<span class="keyword">int</span> num)</span></span>;            <span class="comment">//从SSL套接字读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_write</span><span class="params">(SSL *ssl,<span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">int</span> num)</span></span>;     <span class="comment">//向SSL套接字写入数据</span></span><br></pre></td></tr></table></figure><h4 id="1-6-会话结束"><a href="#1-6-会话结束" class="headerlink" title="1.6 会话结束"></a>1.6 会话结束</h4><p>  当 Client 和 Server 之间的通信过程完成后，就使用以下函数来释放前面过程中申请的 SSL 资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_shutdown</span><span class="params">(SSL *ssl)</span></span>;       <span class="comment">//关闭SSL套接字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSl_free</span><span class="params">(SSL *ssl)</span></span>;          <span class="comment">//释放SSL套接字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_CTX_free</span><span class="params">(SSL_CTX *ctx)</span></span>;  <span class="comment">//释放SSL会话环境</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/04/19/LDCCyF.png"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>《计算机网络——自顶向下方法》</li><li><a href="http://www.cppblog.com/qinqing1984/archive/2014/04/11/206536.aspx">基于OpenSSL实现的安全连接</a></li><li><a href="https://www.openssl.org/docs/man1.1.0/ssl/">SSL API文档</a></li><li><a href="https://blog.csdn.net/hellopaul8597/article/details/52327730">Https协议详解</a></li><li><a href="https://blog.csdn.net/wetest_tencent/article/details/53425198">HTTPS是大势所趋？看腾讯专家通过Epoll+OpenSSL在高并发压测机器人中支持https</a></li><li><a href="https://wenku.baidu.com/view/74575278ed630b1c58eeb517.html">openssl 编程入门(含完整示例)</a></li><li><a href="https://blog.csdn.net/jinhill/article/details/3615626">SSL连接建立过程分析</a></li><li><a href="https://blog.csdn.net/pony_maggie/article/details/51315946">SSL socket 通讯详解</a></li><li><a href="https://www.jianshu.com/p/c93612b3abac">HTTPS从原理到应用(三)：SSL/TLS协议</a></li><li><a href="http://blog.jobbole.com/94332/">SSL/TLS 握手优化详解</a></li><li><a href="http://www.cnblogs.com/dongfuye/p/4121066.html">非阻塞/异步(epoll) openssl</a></li><li><a href="https://my.oschina.net/vincentwy/blog/620282?p=1">两个基于openssl的https client例子</a></li><li><a href="https://blog.csdn.net/howeverpf/article/details/18993945">OpenSSL编程初探1 — 使用OpenSSL API建立SSL通信的一般流程简介</a></li><li><a href="https://blog.csdn.net/howeverpf/article/details/14108063">OpenSSL编程初探2 — 关于证书文件的加载</a></li><li><a href="https://www.cnblogs.com/bwar/p/9879893.html">基于 openssl 的 HTTPS 通信 C++ 实现</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSL&quot;&gt;&lt;a href=&quot;#SSL&quot; class=&quot;headerlink&quot; title=&quot;SSL&quot;&gt;&lt;/a&gt;SSL&lt;/h1&gt;&lt;p&gt;SSL 即 Secure Sockets Layer，是提高信道安全性的协议。不使用 SSL 的 HTTP 通信，是不安全的，所有信</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>leveldb cache</title>
    <link href="https://codroc.github.io/2022/04/11/leveldb-cache/"/>
    <id>https://codroc.github.io/2022/04/11/leveldb-cache/</id>
    <published>2022-04-11T11:57:16.000Z</published>
    <updated>2022-04-11T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leveldb-笔记一：缓存系统-Cache"><a href="#leveldb-笔记一：缓存系统-Cache" class="headerlink" title="leveldb 笔记一：缓存系统 Cache"></a>leveldb 笔记一：缓存系统 Cache</h1><h3 id="LRUHandle"><a href="#LRUHandle" class="headerlink" title="LRUHandle"></a>LRUHandle</h3><blockquote><p>An entry is a variable length heap-allocated structure. 一个变长结构体对象，它被分配在堆上。</p></blockquote><p>LRUHandle 是 <strong>双向循环链表</strong>（为了实现 LRU 替换策略）的节点。在该链表上按访问时间排序。</p><p>变长体现在哪里？首先看它的结构体定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;</span><br><span class="line">  <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);</span><br><span class="line">  LRUHandle* next_hash;<span class="comment">// Hash 表指针，同样 Hash 值的 Handler 串接起来</span></span><br><span class="line">  LRUHandle* next;</span><br><span class="line">  LRUHandle* prev;</span><br><span class="line">  <span class="keyword">size_t</span> charge;  <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length;</span><br><span class="line">  <span class="keyword">bool</span> in_cache;     <span class="comment">// Whether entry is in the cache.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;     <span class="comment">// References, including cache reference, if present.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;     <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next is only equal to this if the LRU handle is the list head of an</span></span><br><span class="line">    <span class="comment">// empty list. List heads never have meaningful keys.</span></span><br><span class="line">    assert(next != <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Slice(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了 key_data 字段，其他都是固定长度的。因此可以这样认为，LRUHandle 是一个<strong>尾部长度可变</strong>的对象。</p><p><strong>存疑一：</strong>为什么不是 char* key_data 而是直接把 key 存储在 LRUHandle 中呢？为什么用 <code>char key_data[1]</code> 而不是 柔性数组 <code>char key_data[]</code></p><blockquote><p>Note:  GCC 由于对 C99 的支持，允许定义 char key_data[ ] 这样的柔性数组（Flexible Array)。但是由于 c++ 标准并不支持柔性数组的实现，这里定义为 key_data[1]，这也是 c++ 中的标准做法。</p></blockquote><p><strong>回答一：</strong>如果存的是指针，那么指针指向的 key 对象就也需要进行 malloc 分配空间，那么带上 LRUHandle 则需要 malloc 两次。如果把 key 对象和 LRUHandle 放在一块，只需要 malloc 一次，而 malloc 是有可能会陷入内核的，因此尽量减少 malloc 的次数，可以加快速度。</p><h3 id="HandleTable"><a href="#HandleTable" class="headerlink" title="HandleTable"></a>HandleTable</h3><p>它其实就是一个简单的 HashTable 先看它的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleTable</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">uint32_t</span> length_;</span><br><span class="line">    <span class="keyword">uint32_t</span> elems_;</span><br><span class="line">    LRUHandle** list_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它使用开链法来解决 hash 冲突，总共设置 length_ 个 bucket，每个 bucket 就是一条单向链表，每条链表的节点就是 LRUHandle，这里可以和 LRUHandle 结构体中的 next_hash 字段结合起来。elems_ 就表示了 HandleTable 中总共有多少个元素，可以用于之后对 hash table 进行 Resize。</p><p>刚开始 hash table 自然是空的，因此直接调用 Resize，进行初始化。</p><p>Resize 需要考虑两种情况：</p><ol><li>hash table 为空时进行 Resize</li><li>hash table 不为空时进行 Resize</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (new_length &lt; elems_) &#123;</span><br><span class="line">        new_length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">    <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="keyword">sizeof</span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// hash table 不为空时，需要考虑：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">        LRUHandle* h = list_[i];</span><br><span class="line">        <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            LRUHandle* next = h-&gt;next_hash; <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">uint32_t</span> hash = h-&gt;hash; <span class="comment">// 2</span></span><br><span class="line">            LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)]; <span class="comment">// 2</span></span><br><span class="line">            h-&gt;next_hash = *ptr;</span><br><span class="line">            *ptr = h;</span><br><span class="line">            h = next; <span class="comment">// 1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hash table 不为空时，需要考虑：</span></span><br><span class="line">    assert(elems_ == count);</span><br><span class="line">    <span class="keyword">delete</span>[] list_;</span><br><span class="line">    list_ = new_list;</span><br><span class="line">    length_ = new_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实要看懂这段代码，唯一的难点是理解 LRUHandle** 到底是个什么东西，它其实就是一个 数组，数组中的每一个元素就是 LRUHandle 链表<strong>头节点的指针</strong>。然后在 while 循环中使用的是 链表的 <strong>头插法</strong></p><p>接下来就是 Insert、Remove、Lookup 和 FindPointer，这里只需要看懂 FindPointer，其他的就自然看懂了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;key())) &#123;</span><br><span class="line">        ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ptr </code> 是单向链表头节点，这个在之前已经说过了。在这里 <code>LRUHandle** ptr = &amp;list_[hash &amp; (length_ - 1)];</code> 的确是这样的，但是在 while 循环中，<code>ptr</code> 已经不是这个意思了，它是 LRUHandle::next_hash 的地址；而 <code>*ptr</code> 仍然是指向 LRUHandle 节点的指针。自然，返回值也就是 LRUHandle::next_hash 的地址。<strong>因此在后续的 Insert、Remove 操作中，我们直接修改 <code>ptr</code> 所指地址处的值（也就是 LRUHandle::next_hash 的值）就可以达到我们需要的效果。</strong></p><h3 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h3><p>逻辑上，设计成列表，一个 Hash Table。两个列表用于存储 LRUHandle 节点，由循环双向链表来实现 LRU 替换策略，Hash Table 用于加速对节点的索引 O(1)，用开链法解决 hash 冲突。</p><p>两链表，一哈希表：</p><ul><li>LRUHandle <strong>lru_</strong> GUARDED_BY(mutex_); // 虚拟头节点</li><li>LRUHandle <strong>in_use_</strong> GUARDED_BY(mutex_); // 虚拟头节点</li><li>HandleTable <strong>table_</strong> GUARDED_BY(mutex_);</li></ul><p>这里两个链表的关系是这样的，我们可以把 LRUCache 内的 Handle 分为四个状态：</p><p><img src="https://s4.ax1x.com/2022/01/13/7MccTI.png"></p><ol><li>*in use (ref=2)*：该 Handle 在 HandleTable 中，并且串联在 <code>in_use_</code> 链表中；由于该 Handle 既被外部使用，也被 <code>in_use_</code> 链表使用，因此有 ref=2；</li><li>*in lru (ref=1)*：该 Handle 在 HandleTable 中，并且串联在 <code>lru_</code> 链表中；由于该 Handle 只被 <code>lru_</code> 引用，因此 ref=1；</li><li>*not in lru, not in table (ref=1)*：该 Handle 不在链表中也不再 HandleTable 中，但是仍然被外部引用而未释放，因此 ref=1；</li><li>*not in lru, not in table (ref=0)*：该 Handle 不在链表中也不再 HandleTable 中，也不被外部使用，因此 ref=0；</li></ol><p>在 LRUCache 析构时，必须保证 in_use 链表为空，也就是说<strong>没有被外部引用并且在链表中</strong>（即状态 1）的节点。之后，就可以对 lru_ 链表中的节点逐一 调用 Unref 来让节点的 deleter 去释放资源。</p><p>LRUCache 类中有一点很符合 morden c++ 的写法，也很值得我学习：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Cache::Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span></span>;</span><br><span class="line">    <span class="function">Cache::Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Cache::Handle* handle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Remove</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Append</span><span class="params">(LRUHandle* <span class="built_in">list</span>, LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">FinishErase</span><span class="params">(LRUHandle* e)</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <strong>公共接口</strong> 中，用 <code>Cache::Handle*</code> 来表示 <code>LRUHandle*</code>；而在 <strong>私有接口</strong> 中，仍旧保留 <code>LRUHandle*</code>；这其实是向外隐藏了 <code>LRUHandle*</code>；</p><h3 id="ShardedLRUCache"><a href="#ShardedLRUCache" class="headerlink" title="ShardedLRUCache"></a>ShardedLRUCache</h3><p>这个类其实就是用来减少 race condition 的，因为 leveldb 缓存系统支持并发，因此要对每一个 LRUCache 加互斥锁，如果只有一个 LRUCache 的话，虽然在外部看来是并发访问了，但是由于为了保证线程安全，在方法临界区内所有访问都被串行化了。但是如果对 Cache 进行分片，也就是增加 LRUCache 的数量（其实就是搞一个 LRUCache 数组），通过 hash 的方式索引到具体某一个 LRUCache 进行访问，这样 LRUCache 之间是可以并行访问并保证线程安全的，这就提高了整个缓存系统的并发性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LRUCache shard_[kNumShards]; <span class="comment">// 分片缓存，通过 hash 方式来索引到某一个 LRUCache</span></span><br><span class="line">    port::Mutex id_mutex_;</span><br><span class="line">    <span class="keyword">uint64_t</span> last_id_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leveldb-笔记一：缓存系统-Cache&quot;&gt;&lt;a href=&quot;#leveldb-笔记一：缓存系统-Cache&quot; class=&quot;headerlink&quot; title=&quot;leveldb 笔记一：缓存系统 Cache&quot;&gt;&lt;/a&gt;leveldb 笔记一：缓存系统 Cac</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试手撕算法记录</title>
    <link href="https://codroc.github.io/2022/04/08/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/"/>
    <id>https://codroc.github.io/2022/04/08/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-08T11:57:16.000Z</published>
    <updated>2022-04-08T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手撕算法记录"><a href="#手撕算法记录" class="headerlink" title="手撕算法记录"></a>手撕算法记录</h1><h3 id="4-月-8-日-华为云"><a href="#4-月-8-日-华为云" class="headerlink" title="4 月 8 日 华为云"></a>4 月 8 日 华为云</h3><p>给定一个 n 位的 01 串，提供两种变换方法：00–&gt;10，10–&gt;01</p><p>样例：</p><p>0010 –&gt; 1101</p><ol><li>0010–&gt;1010</li><li>1010–&gt;1001</li><li>1001–&gt;1101</li></ol><p>碰到的难题：10 可能会变到 01；什么情况下回去这么变，是为了让 00 变成 10；</p><p>刚开始没思路，面试官给提示：00 变到 10 是没代价的，而 10 变 01 是要看时机的，出现 010 这种情况时可以让 10 变 01；刚开始写的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="number">4</span></span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="built_in">string</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>     <span class="built_in">string</span> ret;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size(); ++i) &#123;</span><br><span class="line"> <span class="number">8</span>         <span class="keyword">char</span> c = s[i];</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line"><span class="number">10</span>             ret.push_back(c);</span><br><span class="line"><span class="number">11</span>             <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">12</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">13</span>             <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.size()) &#123;</span><br><span class="line"><span class="number">14</span>                 <span class="keyword">if</span> (s[i+<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="number">15</span>                     ret.push_back(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="number">16</span>                 <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">17</span>                     <span class="keyword">if</span> (i + <span class="number">2</span> &lt; s.size() &amp;&amp; s[i+<span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line"><span class="number">18</span>                         ret.append(<span class="string">&quot;101&quot;</span>);</span><br><span class="line"><span class="number">19</span>                         i += <span class="number">2</span>;</span><br><span class="line"><span class="number">20</span>                     &#125;</span><br><span class="line"><span class="number">21</span>                 &#125;</span><br><span class="line"><span class="number">22</span>             &#125;</span><br><span class="line"><span class="number">23</span>         &#125;</span><br><span class="line"><span class="number">24</span>     &#125;</span><br><span class="line"><span class="number">25</span>     <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">26</span> &#125;</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">29</span>     <span class="built_in">string</span> s = <span class="string">&quot;0000&quot;</span>;</span><br><span class="line"><span class="number">30</span>     <span class="built_in">string</span> ret = func(s);</span><br><span class="line"><span class="number">31</span>     <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="number">32</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">33</span> &#125;</span><br></pre></td></tr></table></figure><p>然后面试官提示 18 行和 13 行出错。然后我还想了一会，哎，无语~~~~</p><p>如果是 010 的情况下不是无脑把 101 压入 ret，而应该把 1 压入，然后后续再如循环进行处理。 i + 1 &lt; s.size() 不满足时如果直接返回，会导致 0000 这样的测试过不了，即最后一个字符得不到处理。</p><p>改正后的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="number">4</span></span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="built_in">string</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; tmp)</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>     <span class="built_in">string</span> s = tmp;</span><br><span class="line"> <span class="number">7</span>     <span class="built_in">string</span> ret;</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size(); ++i) &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">char</span> c = s[i];</span><br><span class="line"><span class="number">10</span>         <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123; <span class="comment">// 1</span></span><br><span class="line"><span class="number">11</span>             ret.push_back(c);</span><br><span class="line"><span class="number">12</span>             <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">13</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">14</span>             <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.size()) &#123;</span><br><span class="line"><span class="number">15</span>                 <span class="keyword">if</span> (s[i+<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="comment">// 00</span></span><br><span class="line"><span class="number">16</span>                     ret.push_back(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="number">17</span>                 <span class="keyword">else</span> &#123; <span class="comment">// 01</span></span><br><span class="line"><span class="number">18</span>                     <span class="keyword">if</span> (i + <span class="number">2</span> &lt; s.size()) &#123;</span><br><span class="line"><span class="number">19</span>                         <span class="keyword">if</span> (s[i + <span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 010</span></span><br><span class="line"><span class="number">20</span>                             ret.push_back(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="number">21</span>                             s[i + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="number">22</span>                             s[i + <span class="number">2</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="number">23</span>                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">24</span>                             <span class="comment">// 011</span></span><br><span class="line"><span class="number">25</span>                             ret.push_back(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="number">26</span>                         &#125;</span><br><span class="line"><span class="number">27</span>                     &#125; <span class="keyword">else</span> ret.push_back(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="number">28</span>                 &#125;</span><br><span class="line"><span class="number">29</span>             &#125; <span class="keyword">else</span> ret.push_back(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="number">30</span>         &#125;</span><br><span class="line"><span class="number">31</span>     &#125;</span><br><span class="line"><span class="number">32</span>     <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">33</span> &#125;</span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">35</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">36</span>     <span class="built_in">string</span> s = <span class="string">&quot;0000&quot;</span>;</span><br><span class="line"><span class="number">37</span>     <span class="built_in">string</span> ret = func(s);</span><br><span class="line"><span class="number">38</span>     <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="number">39</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">40</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手撕算法记录&quot;&gt;&lt;a href=&quot;#手撕算法记录&quot; class=&quot;headerlink&quot; title=&quot;手撕算法记录&quot;&gt;&lt;/a&gt;手撕算法记录&lt;/h1&gt;&lt;h3 id=&quot;4-月-8-日-华为云&quot;&gt;&lt;a href=&quot;#4-月-8-日-华为云&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cs144 lab3 the TCP sender</title>
    <link href="https://codroc.github.io/2022/04/02/cs144_lab3/"/>
    <id>https://codroc.github.io/2022/04/02/cs144_lab3/</id>
    <published>2022-04-02T11:57:16.000Z</published>
    <updated>2022-04-02T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144-lab3-the-TCP-sender"><a href="#cs144-lab3-the-TCP-sender" class="headerlink" title="cs144 lab3: the TCP sender"></a>cs144 lab3: the TCP sender</h1><p>在前面的实验中，我们已经接触到了，seqno、ackno、SYN、FIN 标志、checksum 等技术。这个实验涉及到一个重要技术：<strong>超时重传</strong>。这是解决不可靠网络出现分组丢失问题的重要技术之一。</p><p>如何在可能丢失分组的不可靠网络之上进行可靠传输？<strong>ARQ 协议！</strong></p><h4 id="停等-ARQ-协议"><a href="#停等-ARQ-协议" class="headerlink" title="停等 ARQ 协议"></a>停等 ARQ 协议</h4><p>停止并等待协议的工作原理如下：</p><ol><li>发送点对接收点发送数据包，然后等待接收点回复ACK并且开始计时。</li><li>在等待过程中，发送点停止发送新的数据包。</li><li>当数据包没有成功被接收点接收时候，接收点不会发送ACK.这样发送点在等待一定时间后，重新发送数据包。</li><li>反复以上步骤直到收到从接收点发送的ACK.</li></ol><h4 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h4><p>为了克服停止并等待ARQ协议长时间等待ACK的缺点。这个协议会连续发送一组数据包，然后再等待这些数据包的ACK.</p><p>本实验的实现是 <strong>连续 ARQ 协议</strong>。</p><p>需要注意的点：</p><ul><li>SYN、FIN 也会占用窗口空间</li><li>根据 receiver 发来的 segment 来设置 sender 的窗口；发第一个 syn segment 前，将 sender 的窗口设置为 1</li><li>当 peer 的窗口大小为 0 时，把发送窗口大小设置为 1</li></ul><h4 id="一些疑惑的点："><a href="#一些疑惑的点：" class="headerlink" title="一些疑惑的点："></a><strong>一些疑惑的点：</strong></h4><p>receiver 会发回来一个 <strong>ackno</strong> 和 <strong>windown_size</strong> 。<strong>receiver 发回的 ackno 表示的是 ackno 之前的所有 segment 都已经被成功接收并 reassemble</strong>。这也就是说对与一个 ByteStream 而言，receiver 已经把 [0, unwrap(ackno, isn, checkpoint) ) 范围的元素（在这里就是一个字节） reassemble 了！并且 receiver 还可以接受 [unwrap(ackno, isn, checkpoint), unwrap(ackno, isn, checkpoint) + window_size) 范围的元素，那么对于 sender 来说，它能的发送 ByteStream 的范围就是 [_next_seqno, unwrap(ackno, isn, checkpoint) + window_size)；也就是说发送窗口大小是 <code>unwrap(ackno, isn, checkpoint) + window_size - _next_seqno</code>。</p><p>本实验对于超时的 segment 的处理是这样的：仅仅设置一个定时器（<em>注意不是像 SR 中那样每一个 segment 都设一个 timer</em>），如果超时了，就重传最早的那个（seqno 最靠前的）segment，并把 RTO 乘倍。 </p><p><strong>sender 要发哪些东西给 peer？</strong></p><p>首先 payload 肯定是要发的；其次是 header 中的一些字段：SYN、FIN，seqno；</p><p>sender 的发送窗口大小就没必要发了，因为本来就是 receiver 来控制 sender 能够发多少数据，sender 控制不了 receiver！</p><p><strong>何时开启一个 timer ？</strong></p><ul><li>当带有负载或带有 SYN、FIN 标志的 segment 被发送时，就要开启 timer，<strong>因为这些 segment 都是占用了 absolut seqno 的 segment，要保证这些 segment 可靠送达对端！</strong></li><li>超时重传时要重启 timer</li></ul><p><strong>为什么超时的时候 RTO 要乘倍增长或保持不变？</strong></p><p>讲一下自己的理解：因为，如果是因为网络环境差导致的分组丢失，从而导致超时，那么我们应该尽量降低重传频率，不然网络环境会更加不堪重负，这时候就要乘倍增长 RTO 让重传频率降低；如果不是因为网络环境差，而是因为 receiver 处理数据太慢（即 ByteStream 中的数据迟迟没有读走），导致窗口大小变为 0，如果此时发送方傻傻的把发送窗口变成 0，而 receiver 又不继续发响应，那么当 receiver 的接收窗口大于 0 时，发送方无法得知，由于发送方窗口一直为 0 而导致通信被阻塞了（有没有这种可能？）。。。所以当 receiver 窗口为 0 时，而发送方仍有东西要发送时（即占用 absolute sequence number），让发送窗口为 1，这样发送方会不断向 receiver 发送一个字节，而此时 receiver 因为接收窗口为 0 而无法接收（直接不理会收到的 segment）导致发送方超时，由于这时候的超时不是网络环境导致的，所以让 RTO 保持原样是合理的！</p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p>经过大概 10 次左右的 <code>make check_lab3</code> 终于通过了所有测试用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Test project &#x2F;home&#x2F;cs144&#x2F;sponge&#x2F;build</span><br><span class="line">      Start  1: t_wrapping_ints_cmp</span><br><span class="line"> 1&#x2F;33 Test  #1: t_wrapping_ints_cmp ..............   Passed    0.00 sec</span><br><span class="line">      Start  2: t_wrapping_ints_unwrap</span><br><span class="line"> 2&#x2F;33 Test  #2: t_wrapping_ints_unwrap ...........   Passed    0.00 sec</span><br><span class="line">      Start  3: t_wrapping_ints_wrap</span><br><span class="line"> 3&#x2F;33 Test  #3: t_wrapping_ints_wrap .............   Passed    0.00 sec</span><br><span class="line">      Start  4: t_wrapping_ints_roundtrip</span><br><span class="line"> 4&#x2F;33 Test  #4: t_wrapping_ints_roundtrip ........   Passed    0.12 sec</span><br><span class="line">      Start  5: t_recv_connect</span><br><span class="line"> 5&#x2F;33 Test  #5: t_recv_connect ...................   Passed    0.00 sec</span><br><span class="line">      Start  6: t_recv_transmit</span><br><span class="line"> 6&#x2F;33 Test  #6: t_recv_transmit ..................   Passed    0.03 sec</span><br><span class="line">      Start  7: t_recv_window</span><br><span class="line"> 7&#x2F;33 Test  #7: t_recv_window ....................   Passed    0.00 sec</span><br><span class="line">      Start  8: t_recv_reorder</span><br><span class="line"> 8&#x2F;33 Test  #8: t_recv_reorder ...................   Passed    0.00 sec</span><br><span class="line">      Start  9: t_recv_close</span><br><span class="line"> 9&#x2F;33 Test  #9: t_recv_close .....................   Passed    0.00 sec</span><br><span class="line">      Start 10: t_recv_special</span><br><span class="line">10&#x2F;33 Test #10: t_recv_special ...................   Passed    0.00 sec</span><br><span class="line">      Start 11: t_send_connect</span><br><span class="line">11&#x2F;33 Test #11: t_send_connect ...................   Passed    0.00 sec</span><br><span class="line">      Start 12: t_send_transmit</span><br><span class="line">12&#x2F;33 Test #12: t_send_transmit ..................   Passed    0.03 sec</span><br><span class="line">      Start 13: t_send_retx</span><br><span class="line">13&#x2F;33 Test #13: t_send_retx ......................   Passed    0.00 sec</span><br><span class="line">      Start 14: t_send_window</span><br><span class="line">14&#x2F;33 Test #14: t_send_window ....................   Passed    0.01 sec</span><br><span class="line">      Start 15: t_send_ack</span><br><span class="line">15&#x2F;33 Test #15: t_send_ack .......................   Passed    0.00 sec</span><br><span class="line">      Start 16: t_send_close</span><br><span class="line">16&#x2F;33 Test #16: t_send_close .....................   Passed    0.00 sec</span><br><span class="line">      Start 17: t_send_extra</span><br><span class="line">17&#x2F;33 Test #17: t_send_extra .....................   Passed    0.00 sec</span><br><span class="line">      Start 18: t_strm_reassem_single</span><br><span class="line">18&#x2F;33 Test #18: t_strm_reassem_single ............   Passed    0.00 sec</span><br><span class="line">      Start 19: t_strm_reassem_seq</span><br><span class="line">19&#x2F;33 Test #19: t_strm_reassem_seq ...............   Passed    0.00 sec</span><br><span class="line">      Start 20: t_strm_reassem_dup</span><br><span class="line">20&#x2F;33 Test #20: t_strm_reassem_dup ...............   Passed    0.00 sec</span><br><span class="line">      Start 21: t_strm_reassem_holes</span><br><span class="line">21&#x2F;33 Test #21: t_strm_reassem_holes .............   Passed    0.00 sec</span><br><span class="line">      Start 22: t_strm_reassem_many</span><br><span class="line">22&#x2F;33 Test #22: t_strm_reassem_many ..............   Passed    0.04 sec</span><br><span class="line">      Start 23: t_strm_reassem_overlapping</span><br><span class="line">23&#x2F;33 Test #23: t_strm_reassem_overlapping .......   Passed    0.00 sec</span><br><span class="line">      Start 24: t_strm_reassem_win</span><br><span class="line">24&#x2F;33 Test #24: t_strm_reassem_win ...............   Passed    0.03 sec</span><br><span class="line">      Start 25: t_strm_reassem_cap</span><br><span class="line">25&#x2F;33 Test #25: t_strm_reassem_cap ...............   Passed    0.05 sec</span><br><span class="line">      Start 26: t_byte_stream_construction</span><br><span class="line">26&#x2F;33 Test #26: t_byte_stream_construction .......   Passed    0.00 sec</span><br><span class="line">      Start 27: t_byte_stream_one_write</span><br><span class="line">27&#x2F;33 Test #27: t_byte_stream_one_write ..........   Passed    0.00 sec</span><br><span class="line">      Start 28: t_byte_stream_two_writes</span><br><span class="line">28&#x2F;33 Test #28: t_byte_stream_two_writes .........   Passed    0.00 sec</span><br><span class="line">      Start 29: t_byte_stream_capacity</span><br><span class="line">29&#x2F;33 Test #29: t_byte_stream_capacity ...........   Passed    0.28 sec</span><br><span class="line">      Start 30: t_byte_stream_many_writes</span><br><span class="line">30&#x2F;33 Test #30: t_byte_stream_many_writes ........   Passed    0.00 sec</span><br><span class="line">      Start 53: t_address_dt</span><br><span class="line">31&#x2F;33 Test #53: t_address_dt .....................   Passed    5.03 sec</span><br><span class="line">      Start 54: t_parser_dt</span><br><span class="line">32&#x2F;33 Test #54: t_parser_dt ......................   Passed    0.00 sec</span><br><span class="line">      Start 55: t_socket_dt</span><br><span class="line">33&#x2F;33 Test #55: t_socket_dt ......................   Passed    0.00 sec</span><br></pre></td></tr></table></figure><p>代码如下：</p><p>重传定时器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RTimer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RTimer() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">        _time_out = to;</span><br><span class="line">        _started = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; _started = <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">time_out</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _time_out; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_time_out</span><span class="params">(<span class="keyword">size_t</span> t)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _started &amp;&amp; t &gt;= _time_out; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">started</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _started; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> _started&#123;&#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span> _time_out&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TCPSender 类中，自己添加的 private 变量 和 方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPSender</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">// my code:</span></span><br><span class="line">     RTimer _timer;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TCPSegment&gt; _outstandings;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">size_t</span> _ms_since_alive&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> _rtx&#123;&#125;; <span class="comment">// consective retransmission times</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">uint64_t</span> _checkpoint&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">uint16_t</span> _win_size&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> _rto; <span class="comment">// retransmission time out</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">bool</span> _peer_busy&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">uint64_t</span> _bytes_in_flight&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">bool</span> _fin_sended&#123;&#125;;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     <span class="function">TCPSegment <span class="title">make_segment</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span></span>;</span><br><span class="line">     <span class="function">WrappingInt32 <span class="title">get_seqno</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">uint64_t</span> <span class="title">get_absolute_seqno</span><span class="params">(WrappingInt32, WrappingInt32, <span class="keyword">uint64_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">space_available</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _win_size &gt; <span class="number">0</span>; &#125;</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">is_peer_busy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _peer_busy; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">send_and_store</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TCPSender 接口的具体实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">TCPSender::TCPSender(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity, <span class="keyword">const</span> <span class="keyword">uint16_t</span> retx_timeout, <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;WrappingInt32&gt; fixed_isn)</span><br><span class="line">     : _isn(fixed_isn.value_or(WrappingInt32&#123;random_device()()&#125;))</span><br><span class="line">     , _initial_retransmission_timeout&#123;retx_timeout&#125;</span><br><span class="line">     , _stream(capacity)</span><br><span class="line">     , _timer()</span><br><span class="line">     , _outstandings()</span><br><span class="line">     , _rto(retx_timeout)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">uint64_t</span> <span class="title">TCPSender::bytes_in_flight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> _bytes_in_flight;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!space_available()) <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">// size_t last_size = _outstandings.size();</span></span><br><span class="line">     <span class="keyword">if</span> (_next_seqno == <span class="number">0</span>) &#123; <span class="comment">// 前两次握手</span></span><br><span class="line">         <span class="keyword">size_t</span> can_read = <span class="built_in">std</span>::min(TCPConfig::MAX_PAYLOAD_SIZE,</span><br><span class="line">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>&amp;&gt;(_win_size - <span class="number">1</span>)); <span class="comment">// 预留一个字节给 syn</span></span><br><span class="line">         send_and_store(_stream.read(can_read), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_stream.input_ended() &amp;&amp; !_fin_sended) &#123; <span class="comment">// 后面四次挥手</span></span><br><span class="line">         <span class="comment">// 判断何时发送 fin</span></span><br><span class="line">         <span class="keyword">if</span> (_win_size &gt;= _stream.buffer_size() + <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="comment">// 刚好能把 fin 塞入</span></span><br><span class="line">             send_and_store(_stream.read(_win_size), <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">             _fin_sended = <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 仅传输 payload</span></span><br><span class="line">     <span class="keyword">while</span> (!_stream.buffer_empty() &amp;&amp; space_available()) &#123;</span><br><span class="line">         <span class="keyword">size_t</span> can_read = <span class="built_in">std</span>::min(TCPConfig::MAX_PAYLOAD_SIZE,</span><br><span class="line">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>&amp;&gt;(_win_size));</span><br><span class="line">         send_and_store(_stream.read(can_read), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 因为 ack_received 后会调用一次 fill_window 因此判断下是否已经 FIN_ACKED，如果 FIN_ACKED 了，那么 _outstandings 肯定为空</span></span><br><span class="line">     <span class="keyword">if</span> (!_timer.started() &amp;&amp; !_outstandings.empty())</span><br><span class="line">         _timer.start(_ms_since_alive + _rto);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"> <span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="keyword">const</span> WrappingInt32 ackno, <span class="keyword">const</span> <span class="keyword">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">uint64_t</span> left = get_absolute_seqno(ackno, _isn, _checkpoint);</span><br><span class="line">     <span class="keyword">if</span> (left &gt; _next_seqno) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">uint64_t</span> right = left + window_size;</span><br><span class="line">     _win_size = right - _next_seqno;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (window_size == <span class="number">0</span>) &#123; _peer_busy = <span class="literal">true</span>; _win_size = <span class="number">1</span>; &#125;</span><br><span class="line">     <span class="keyword">else</span> _peer_busy = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">bool</span> has_new_data = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">while</span> (!_outstandings.empty()) &#123;</span><br><span class="line">         TCPSegment segment = _outstandings.front();</span><br><span class="line">         <span class="keyword">uint64_t</span> ab_seqno = get_absolute_seqno(segment.header().seqno, _isn, _checkpoint);</span><br><span class="line">         <span class="keyword">uint16_t</span> length = segment.length_in_sequence_space();</span><br><span class="line">         <span class="keyword">if</span> (ab_seqno + length &gt; left)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         has_new_data = <span class="literal">true</span>;</span><br><span class="line">         _outstandings.pop();</span><br><span class="line">         _bytes_in_flight -= length;</span><br><span class="line"></span><br><span class="line">         _rto = _initial_retransmission_timeout;</span><br><span class="line">         _rtx = <span class="number">0</span>;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">if</span> (_outstandings.empty()) _timer.stop();</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(has_new_data) _timer.start(_ms_since_alive + _rto);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (_outstandings.empty()) <span class="keyword">return</span>;</span><br><span class="line">     _ms_since_alive += ms_since_last_tick;</span><br><span class="line">     <span class="keyword">if</span> (_timer.is_time_out(_ms_since_alive)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (is_peer_busy()) &#123;</span><br><span class="line">             <span class="comment">// 如果是对端繁忙的情况，即 发送端还有数据发，但 receiver 窗口变成 0</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 网络环境差导致丢包或延迟送达</span></span><br><span class="line">             _rtx++;</span><br><span class="line">             _rto *= <span class="number">2</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 重传最早的那个 segment，并重启定时器</span></span><br><span class="line">         <span class="comment">// assert(!_outstandings.empty()); // 一定非空</span></span><br><span class="line">         _segments_out.push(_outstandings.front());</span><br><span class="line">         <span class="comment">// _outstandings.pop();</span></span><br><span class="line">         _timer.start(_ms_since_alive + _rto);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _rtx; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     _segments_out.push(make_segment(<span class="string">&quot;&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">TCPSegment <span class="title">TCPSender::make_segment</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span> </span>&#123;</span><br><span class="line">     TCPSegment segment;</span><br><span class="line">     segment.payload() = <span class="built_in">std</span>::move(payload);</span><br><span class="line">     segment.header().seqno = get_seqno();</span><br><span class="line">     segment.header().syn = syn;</span><br><span class="line">     segment.header().fin = fin;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// _next_seqno += segment.length_in_sequence_space();</span></span><br><span class="line">     <span class="keyword">return</span> segment;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">WrappingInt32 <span class="title">TCPSender::get_seqno</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> wrap(_next_seqno, _isn);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">TCPSender::get_absolute_seqno</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="keyword">uint64_t</span> checkpoint)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> unwrap(n, isn, checkpoint);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::send_and_store</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span> </span>&#123;</span><br><span class="line">     TCPSegment segment = make_segment(<span class="built_in">std</span>::move(payload), syn, fin);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// send</span></span><br><span class="line">     <span class="keyword">uint64_t</span> length = segment.length_in_sequence_space();</span><br><span class="line">     _segments_out.push(segment);</span><br><span class="line">     _next_seqno += length;</span><br><span class="line">     _win_size -= length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// store</span></span><br><span class="line">     _outstandings.push(segment);</span><br><span class="line">     _bytes_in_flight += length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// update checkpoint</span></span><br><span class="line">     _checkpoint = _next_seqno;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144-lab3-the-TCP-sender&quot;&gt;&lt;a href=&quot;#cs144-lab3-the-TCP-sender&quot; class=&quot;headerlink&quot; title=&quot;cs144 lab3: the TCP sender&quot;&gt;&lt;/a&gt;cs144 lab3</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cs144 lab1 Stitching substrings into a byte stream</title>
    <link href="https://codroc.github.io/2022/03/27/cs144-lab1/"/>
    <id>https://codroc.github.io/2022/03/27/cs144-lab1/</id>
    <published>2022-03-27T11:57:16.000Z</published>
    <updated>2022-03-27T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144-lab1-stitching-substrings-into-a-byte-stream"><a href="#cs144-lab1-stitching-substrings-into-a-byte-stream" class="headerlink" title="cs144 lab1: stitching substrings into a byte stream"></a>cs144 lab1: stitching substrings into a byte stream</h1><p>预备知识：《计算机网络自顶向下方法》——3.4 可靠数据传输原理</p><p>复习下如何构造一个可靠数据传输协议，书中是基于三种假设，逐层递进地讲解的。</p><ul><li>rdt1.0：该协议假设底层信道完全可靠</li><li>rdt2.0：该协议假设底层信道不可靠，但仅仅会导致 datagram 的比特位出错，而不会导致任何丢失</li><li>rdt3.0：该协议假设底层信道完全不可靠，既会导致 datagram 的比特位出错，也可能导致整个包丢失</li></ul><p>对于 rdt1.0，没啥好说的。</p><h2 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h2><p>该协议要应对存在 bit 出错的可能，因此引入了以下功能：</p><ul><li>差错检验</li><li>接收方反馈</li><li>重传</li></ul><p>对于 rdt2.0 由于会存在 bit 出错的情况，因此引入一个 checksum，根据查错纠错算法和 checksum 来判断接收到的 datagram 是否有 bit 出错。</p><p>如果存在 bit 出错，那么接收方就要发送一个 NACK 给发送方，用来表示 “你发了的信息在途中遭到了破坏！请重新发送！”；如果没有 bit 出错，那么接收方就发一个 ACK 给发送方，用来表示 “我接受到了你发的信息！” 其实这里还有一个需要考虑的地方，那就是：<strong>接收方必须能够分辨出，接收到的 datagram 是发送方重传的还是最新的！</strong> 这里可以引入一个 <strong>1 bit 的序号</strong>，每次发送新的信息时进行 0，1 转换就可以分辨出发来的是新消息还是重传的消息了。</p><p>发送方，发送/重传一个消息后，必须等待接收方的反馈。并根据接收方的反馈做出具体的操作。如果收到 ACK，则发送新消息，并把新消息中的序号位反转一下以表示新消息；如果是 NACK，那么就重传旧消息。</p><h2 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h2><p>该协议不仅仅要应对 bit 出错的情况，还要应对分组丢失的情况，因此在 rdt2.0 的基础上又引入了以下功能：</p><ul><li>定时器</li></ul><p>由于发出去的消息可能在网络中丢失，那么如果让发送方不断地等待接收方的反馈，可能会导致等到地老天荒也没等来反馈。这是如果引入一个定时器，如果在规定的时间内没有收到反馈就可以简单地认为 datagram 在网络中丢失了！那么发送方就对旧消息进行重传。</p><p>但是可能信息并没有丢失，而是网络太拥堵导致它迟到了，而此时发送方已经重传了，那么这会导致冗余分组。</p><p>总结下：<strong>checksum，序号，ACK，定时器和重传</strong>等技术确保了在不可靠网络上进行可靠传输。</p><h1 id="缝合字符串"><a href="#缝合字符串" class="headerlink" title="缝合字符串"></a>缝合字符串</h1><p>回归主题，本次 lab 就是为之后的 <code>TCPReceiver</code> 做准备的。</p><p>主要是设计一个 <code>StreamReassembler</code> 把字符串碎片重新组合成一个有序的字节流 <code>ByteStream</code>，首先对字符碎片进行定义：</p><ul><li>字符碎片取自 ByteStream</li><li>字符碎片 A 和字符碎片 B 可能重叠</li><li>当字符碎片可以被 assemble 时立刻组装并交付给 ByteStream</li></ul><p>可以参考下面的图：</p><p><img src="https://s1.ax1x.com/2022/03/27/qwOpkV.png"></p><p>对于第一个定义，它想表达的是字符碎片是 ByteStream 的子串。</p><p>对于第二个定义，如果 ByteStream = “abcdefghi” 那么 A、B 可能是：A = “bcde”、B = “def”；即 A和B之间存在重叠。</p><p>对于第三个定义，什么情况下字符碎片可以被 assemble？那就是当前字符碎片的 index 是 rcv_base 的时候（这个 rcv_base 请去看《计算机网络自顶向下》3.4.4 节 图 3-23）。举个例子，我们已经收到字符碎片 A 和 B了（A、B的值和上面一样），那么可以把A 和B合并成 “bcdef”，但是由于现在的 rcv_base = 0，也就是 “a” 的index，所以不能 assemble；直到 rcv_base = 1 时我们才能把 “bcdef” 交付给 ByteStream。</p><p>就像上图，<code>first unassembled</code> 到 <code>first unacceptable</code> 的区间内，可以看到一段一段的红色，每一段都表明了一个被合并过的字符碎片，每个字符碎片都是 ByteStream 的子串。而绿色的是已经有序且连续的但未被读走的 ByteStream 子串。</p><p>其实这里就已经有 <strong>TCP 接收缓冲区（对应 ByteStream）</strong>以及<strong>滑动窗口（对应 StreamReassembler）</strong>的感觉了！</p><p>在代码实现方面，最难的是如何对<strong>接收到的字符串碎片</strong>与已经存储<strong>在 <code>first unassembled</code> 到 <code>first unacceptable</code> 的区间内的字符串碎片</strong>进行<strong>合并</strong>，这个合并涉及到了对碎片的去重叠。所以说这个 lab 更像是在做一道算法题。。。。。。</p><p>这个算法可以参考，OS 对内存页回收时要进行操作，它也要判断是否可以和前后页进行合并！但这里更加复杂，内存页的合并只需要考虑前一个页与后一个页，而这里需要考虑多个字符串碎片，因为可能存在 A = “bcd”、B = “f”、C = “hi” 然后收到了 “abcdefgh” 的情况~~~</p><p>可以把要进行合并（merge）的字符串碎片和合并会涉及到字符串碎片抽象成如下图所示：</p><p><img src="https://s1.ax1x.com/2022/03/27/qwxSu4.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::merge</span><span class="params">(StreamReassembler::Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_aux_storage.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        _aux_storage.insert(node);</span><br><span class="line">        _unassembled_bytes += node.length;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pre = _aux_storage.lower_bound(node);</span><br><span class="line">    <span class="keyword">if</span> (pre == _aux_storage.end()) &#123;</span><br><span class="line">        <span class="comment">// 有前，无后</span></span><br><span class="line">        --pre;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;end() &lt; node.index) &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            _aux_storage.insert(node);</span><br><span class="line">            update_unassembled_bytes(_aux_storage.end(), _aux_storage.end(), node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;end() &lt; node.end()) &#123;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> tmp = *pre-&gt;spStr +</span><br><span class="line">                node.spStr-&gt;substr(pre-&gt;end() - node.index);</span><br><span class="line">            node.spStr.reset(</span><br><span class="line">                    <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="built_in">std</span>::move(tmp))</span><br><span class="line">                    );</span><br><span class="line">            node.index = pre-&gt;index;</span><br><span class="line">            node.length = node.spStr-&gt;size();</span><br><span class="line"></span><br><span class="line">            _aux_storage.erase(pre);</span><br><span class="line">            _aux_storage.insert(node);</span><br><span class="line">            <span class="keyword">auto</span> begin = pre;</span><br><span class="line">            <span class="keyword">auto</span> end   = ++pre;</span><br><span class="line">            update_unassembled_bytes(begin, end, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre == _aux_storage.begin()) &#123;</span><br><span class="line">        <span class="comment">// 无前</span></span><br><span class="line">        <span class="keyword">auto</span> it = pre;</span><br><span class="line">        <span class="keyword">while</span> (it != _aux_storage.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;end() &gt; node.end()) <span class="keyword">break</span>;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it == _aux_storage.end()) <span class="comment">// 1</span></span><br><span class="line">            update_storage(_aux_storage.begin(), _aux_storage.end(), node);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;index &gt; node.end()) <span class="comment">// 2</span></span><br><span class="line">            update_storage(pre, it, node);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 3</span></span><br><span class="line">            node.spStr.reset(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*node.spStr + it-&gt;spStr-&gt;substr(node.end() - it-&gt;index)));</span><br><span class="line">            node.length = node.spStr-&gt;size();</span><br><span class="line">            ++it;</span><br><span class="line">            update_storage(pre, it, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// pre 在中间</span></span><br><span class="line">        <span class="keyword">auto</span> it = pre;</span><br><span class="line">        <span class="keyword">while</span> (it != _aux_storage.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;end() &gt; node.end()) <span class="keyword">break</span>;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it == _aux_storage.end()) &#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">// 有前，无后</span></span><br><span class="line">            <span class="keyword">auto</span> t = --pre;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;end() &lt; node.index) &#123; <span class="comment">// 1_1</span></span><br><span class="line">                ++t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 1_2</span></span><br><span class="line">                node.spStr.reset(</span><br><span class="line">                        <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*t-&gt;spStr +</span><br><span class="line">                            node.spStr-&gt;substr(</span><br><span class="line">                                t-&gt;end() - node.index</span><br><span class="line">                                )</span><br><span class="line">                            )</span><br><span class="line">                        );</span><br><span class="line">                node.index = t-&gt;index;</span><br><span class="line">            &#125;</span><br><span class="line">            update_storage(t, it, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="comment">// 有前，有后</span></span><br><span class="line">            <span class="keyword">auto</span> a = --pre;</span><br><span class="line">            <span class="keyword">auto</span> b = it;</span><br><span class="line">            <span class="keyword">if</span> (a-&gt;end() &lt; node.index &amp;&amp; node.end() &lt; b-&gt;index) &#123; <span class="comment">// 2_1</span></span><br><span class="line">                ++a;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;end() &lt; node.index) &#123; <span class="comment">// 2_2</span></span><br><span class="line">                node.spStr.reset(</span><br><span class="line">                        <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*node.spStr +</span><br><span class="line">                            b-&gt;spStr-&gt;substr(</span><br><span class="line">                                node.end() - b-&gt;index</span><br><span class="line">                                )</span><br><span class="line">                            )</span><br><span class="line">                        );</span><br><span class="line">                node.length = node.spStr-&gt;size();</span><br><span class="line"></span><br><span class="line">                ++a;</span><br><span class="line">                ++b;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.end() &lt; b-&gt;index) &#123; <span class="comment">// 2_3</span></span><br><span class="line">                <span class="keyword">if</span> (a-&gt;end() &gt;= node.end()) <span class="keyword">return</span>;</span><br><span class="line">                node.spStr.reset(</span><br><span class="line">                        <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*a-&gt;spStr +</span><br><span class="line">                            node.spStr-&gt;substr(</span><br><span class="line">                                a-&gt;end() - node.index</span><br><span class="line">                                )</span><br><span class="line">                            )</span><br><span class="line">                        );</span><br><span class="line">                node.index = a-&gt;index;</span><br><span class="line">                node.length = node.spStr-&gt;size();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2_4</span></span><br><span class="line">                node.spStr.reset(</span><br><span class="line">                        <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*a-&gt;spStr +</span><br><span class="line">                            node.spStr-&gt;substr(</span><br><span class="line">                                a-&gt;end() - node.index</span><br><span class="line">                                ) +</span><br><span class="line">                            b-&gt;spStr-&gt;substr(node.end() - b-&gt;index)</span><br><span class="line">                            )</span><br><span class="line">                        );</span><br><span class="line">                node.index = a-&gt;index;</span><br><span class="line">                node.length = node.spStr-&gt;size();</span><br><span class="line"></span><br><span class="line">                ++b;</span><br><span class="line">            &#125;</span><br><span class="line">            update_storage(a, b, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的代码都是很简单的逻辑啦~~~~</p><p>这里是功能定义：<code>stream_reassembler.hh</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamReassembler</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">         Node(<span class="keyword">size_t</span> idx, <span class="keyword">uint32_t</span> l, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; sp)</span><br><span class="line">             : index(idx),</span><br><span class="line">               length(l),</span><br><span class="line">               spStr(<span class="built_in">std</span>::move(sp))</span><br><span class="line">         &#123;&#125;</span><br><span class="line">         <span class="keyword">size_t</span> index;</span><br><span class="line">         <span class="keyword">uint32_t</span> length;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; spStr;</span><br><span class="line">         <span class="function"><span class="keyword">size_t</span> <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> index + length; &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">NodeCmp</span> &#123;</span></span><br><span class="line">         <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node&amp; lhs, <span class="keyword">const</span> Node&amp; rhs)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> lhs.index &lt; rhs.index; &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">     <span class="keyword">using</span> SetType = <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Node, NodeCmp&gt;;</span><br><span class="line">     <span class="keyword">uint32_t</span> _rcv_base&#123;<span class="number">0</span>&#125;; <span class="comment">// 下一个起始索引</span></span><br><span class="line">     <span class="keyword">uint32_t</span> _eof_index&#123;<span class="number">0xffffffff</span>&#125;;</span><br><span class="line">     <span class="keyword">uint32_t</span> _unassembled_bytes&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">     SetType _aux_storage;</span><br><span class="line"></span><br><span class="line">     ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">     <span class="keyword">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     <span class="comment">// 判断 data 是否有部分属于 assembled 但 unread</span></span><br><span class="line">     <span class="comment">// 把这一部分数据叫做有效数据 valid data</span></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;</span><br><span class="line">     get_valid_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data, <span class="keyword">const</span> <span class="keyword">size_t</span> index);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// remain capacity</span></span><br><span class="line">     <span class="function"><span class="keyword">uint32_t</span> <span class="title">remain_capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _capacity - _unassembled_bytes - _output.buffer_size(); &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 把数据交付给 ByteStream，并更新 aux_storage</span></span><br><span class="line">     <span class="function"><span class="keyword">uint32_t</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 把数据写到 aux_storage</span></span><br><span class="line">     <span class="comment">// 会出现几种情况</span></span><br><span class="line">     <span class="comment">// 1. 数据是从 _rcv_base 开始的</span></span><br><span class="line">     <span class="comment">// 2. 数据不是从 _rcv_base 开始的</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">write_to_aux_storage</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; p)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 合并碎片，可能会有多个碎片和输入碎片重叠</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Node node)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// param a: start_iterator of node which is going to be delete</span></span><br><span class="line">     <span class="comment">// param b: end_iterator of node which is going to be delete</span></span><br><span class="line">     <span class="comment">// param node: the node which is going to be insert</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">update_unassembled_bytes</span><span class="params">(SetType::iterator a, SetType::iterator b, <span class="keyword">const</span> Node&amp; node)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">uint32_t</span> total = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">auto</span> it = a; it != b; ++it)</span><br><span class="line">             total += it-&gt;length;</span><br><span class="line">         _unassembled_bytes += node.length - total;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">update_storage</span><span class="params">(SetType::iterator a, SetType::iterator b, <span class="keyword">const</span> Node&amp; node)</span> </span>&#123;</span><br><span class="line">         update_unassembled_bytes(a, b, node);</span><br><span class="line">         _aux_storage.erase(a, b);</span><br><span class="line">         _aux_storage.insert(node);</span><br><span class="line">     &#125;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里是实现：<code>stream_reassembler.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">StreamReassembler::StreamReassembler(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity)</span><br><span class="line">     : _aux_storage(),</span><br><span class="line">       _output(capacity),</span><br><span class="line">       _capacity(capacity)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::merge</span><span class="params">(StreamReassembler::Node node)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::write_to_aux_storage</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; p)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// std::string tmp = p.second.size() &gt; remain_capacity() ?</span></span><br><span class="line">     <span class="comment">//     p.second.substr(0, remain_capacity()) : p.second;</span></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">string</span> tmp = p.second.size() &gt; _capacity ?</span><br><span class="line">         p.second.substr(<span class="number">0</span>, _capacity) : p.second;</span><br><span class="line">     <span class="function">Node <span class="title">node</span><span class="params">(p.first, tmp.size(), <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(tmp))</span></span>;</span><br><span class="line">     <span class="comment">// _unassembled_bytes += tmp.size();</span></span><br><span class="line">     merge(node);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">uint32_t</span> <span class="title">StreamReassembler::update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">auto</span> it = _aux_storage.begin();</span><br><span class="line">     <span class="comment">// assert(it-&gt;index == _rcv_base);</span></span><br><span class="line">     <span class="keyword">size_t</span> writed = _output.write(*it-&gt;spStr);</span><br><span class="line">     <span class="keyword">size_t</span> ret = _rcv_base + writed;</span><br><span class="line">     _unassembled_bytes -= writed;</span><br><span class="line">     <span class="keyword">if</span> (writed == it-&gt;length) &#123;</span><br><span class="line">         _aux_storage.erase(it);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         Node node = &#123;ret, it-&gt;length - <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(writed),</span><br><span class="line">             <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;</span><br><span class="line">                 (it-&gt;spStr-&gt;substr(writed))</span><br><span class="line">                 &#125;;</span><br><span class="line">         _aux_storage.erase(it);</span><br><span class="line">         _aux_storage.insert(node);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (ret == _eof_index) _output.end_input();</span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// data: 传到 push_substring 的字符串</span></span><br><span class="line"> <span class="comment">// ret: index, valid_data</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;</span><br><span class="line"> StreamReassembler::get_valid_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data,</span><br><span class="line">         <span class="keyword">const</span> <span class="keyword">size_t</span> index) &#123;</span><br><span class="line">     <span class="keyword">if</span> (index &gt;= _rcv_base) <span class="keyword">return</span> &#123;index, data&#125;;</span><br><span class="line">     <span class="keyword">size_t</span> end = index + data.size();</span><br><span class="line">     <span class="keyword">if</span> (end &lt; _rcv_base) <span class="keyword">return</span> &#123;<span class="number">0</span>, &#123;&#125;&#125;;</span><br><span class="line">     <span class="keyword">return</span> &#123;_rcv_base, data.substr(_rcv_base - index)&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//! \details This function accepts a substring (aka a segment) of bytes,</span></span><br><span class="line"> <span class="comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span></span><br><span class="line"> <span class="comment">//! contiguous substrings and writes them into the output stream in order.</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data, <span class="keyword">const</span> <span class="keyword">size_t</span> index, <span class="keyword">const</span> <span class="keyword">bool</span> eof)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (eof) _eof_index = index + data.size();</span><br><span class="line">     <span class="keyword">auto</span> p = get_valid_data(data, index); <span class="comment">// valid_index, valid_data</span></span><br><span class="line">     <span class="comment">// index + data.size() &lt; _rcv_base</span></span><br><span class="line">     <span class="keyword">if</span> (p.second.empty()) &#123;</span><br><span class="line">         <span class="comment">// 如果只是用来通知 eof 的</span></span><br><span class="line">         <span class="keyword">if</span> (_rcv_base == _eof_index)    _output.end_input();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     write_to_aux_storage(p);</span><br><span class="line">     <span class="comment">// index + data.size() &gt;= _rcv_base &amp;&amp; index &lt;= _rcv_base</span></span><br><span class="line">     <span class="keyword">if</span> (p.first == _rcv_base) &#123;</span><br><span class="line">         _rcv_base = update();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// index &gt; _rcv_base</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">size_t</span> StreamReassembler::unassembled_bytes() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _unassembled_bytes; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == unassembled_bytes(); &#125;</span><br></pre></td></tr></table></figure><p>除此之外可以看看 Leetcode 56 题：</p><h5 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h5><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p>示例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>], end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= end)</span><br><span class="line">                end = max(end, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ret.push_back(&#123;start, end&#125;);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret.push_back(&#123;start, end&#125;);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144-lab1-stitching-substrings-into-a-byte-stream&quot;&gt;&lt;a href=&quot;#cs144-lab1-stitching-substrings-into-a-byte-stream&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Dynamic Link</title>
    <link href="https://codroc.github.io/2022/03/26/dynamic_link/"/>
    <id>https://codroc.github.io/2022/03/26/dynamic_link/</id>
    <published>2022-03-26T11:57:16.000Z</published>
    <updated>2022-03-26T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dynamic-Link"><a href="#Dynamic-Link" class="headerlink" title="Dynamic Link"></a>Dynamic Link</h1><h4 id="静态链接的缺陷"><a href="#静态链接的缺陷" class="headerlink" title="静态链接的缺陷"></a>静态链接的缺陷</h4><ul><li>浪费内存和磁盘空间</li><li>模块更新困难</li></ul><p>​    由于静态链接会把模块代码全部链接进入可执行文件，可想而知，可执行文件将会变得比较大（想象一下，每个程序内部除了保留着 printf()，scanf()，strlen() 等这样的公共函数，还有很多数量可观的其他库函数，这会使得程序变得多么庞大，而这么庞大的程序不光浪费了磁盘，当他需要被执行时，也会被加载到内存从而浪费大量内存）。<strong>在静态链接中，C 语言静态库是一个很典型的浪费空间的例子。</strong></p><p>​    除此之外，静态链接由于已经把所有模块全部放进可执行文件了，一旦程序中有任何模块更新，整个程序就要重新链接。</p><p>​    拿 LOL 举例，我们知道它是频繁更新的程序，并且不提供源代码。如果它采用静态链接，那么每一次更新后，我们就要把老版本的卸载了，从官网下载新版本的 LOL，这不光浪费时间，而且大大浪费了网络带宽，要知道很多人玩这游戏的，那么它每一次更新都可能导致网络负载大大增加（因为每个人都在那一天重新下载最新版本的 LOL），可能会导致网络瘫痪的（故意夸张了下~~）；如果采用动态链接的话，只需要下载补丁就可以了。</p><h4 id="动态链接基本思想"><a href="#动态链接基本思想" class="headerlink" title="动态链接基本思想"></a>动态链接基本思想</h4><p><strong>把程序模块相互分割开来而不是静态地链接在一起。把链接的过程推迟到运行时在进行。</strong></p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>节省磁盘和内存空间</li><li>使得程序的更新更加容易且友好</li><li>模块更加独立，耦合性更加小，增加程序的兼容性</li><li>可以减少换入换出，也可以增加 Cache 命中率，因为不同进程间地数据和指令都集中在了同一个共享模块上</li></ul><blockquote><p>其实 Plug-in 插件就是采用了动态链接的思想实现出来的</p></blockquote><p>Q1：如何理解 3？</p><p>A1：举个例子吧。比如操作系统 A 和操作系统 B 对于 printf 的实现是不一样的，如果采用静态链接，那么必须要有两份可执行文件，分别能够在两个 OS 上运行。如果采用动态链接，只要 OS A 和 OS B 都提供了一个动态链接库包含了 printf，并且这个 printf 使用了相同的接口，那么程序只需要一个版本，就能在两个操作系统上运行，动态地选择相应的 printf 的实现版本。其实可以这样想，我现在有一个充电器，房子 A 和 房子 B 的插座都是一个样的，且充电器都能插进去，那么不管我去哪个房子都能充电。房子 A 插座后面的电是通过太阳能发电得到的；而房子 B 插座后面的电是通过火力发电得到的。虽然发电方式不一样，但是充电器插头能插进插座，并且有电，我们就能充电了。</p><p>Q2：如何理解 4？</p><p>A2：因为采用动态链接，同样的指令在内存中只存在一份，这样 Cache 就不会因为查看到物理地址不一样而不命中了。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>由于把程序的链接推迟到了装载的时候，不可避免地导致了程序装载速度变慢（可以通过 lazy binding 优化），因为引入了一堆 “胶水” 代码来把共享库粘到原来的进程空间中去。</li><li>可执行程序依赖于能够兼容的共享库。在运行时找不到共享库或者版本不兼容，都会导致运行时错误。</li><li>由于动态库是在可执行文件装载时确定它们所在的进程虚拟地址空间位置的，因此它们可能广泛地分布在虚拟地址空间中，而不是在同一处，这会导致空间的局部性变差，emmm 主要还是从 TLB 缓冲失效的角度影响性能。</li></ul><h1 id="查看动态库相关信息的命令"><a href="#查看动态库相关信息的命令" class="headerlink" title="查看动态库相关信息的命令"></a>查看动态库相关信息的命令</h1><p>用 g++ 创建一个共享库 <code>b.so</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ -fPIC -shared -o b.so b.cpp</span></span><br></pre></td></tr></table></figure><p>创建一个依赖于 <code>b.so</code> 的共享库 <code>hello.so</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ -fPIC -shared -Wl,-rpath=. -o hello.so b.so hello.cpp</span></span><br></pre></td></tr></table></figure><p>编译一个依赖于  <code>hello.so</code> 的程序 <code>test_shared_map</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ test_shared_map.cpp hello.so b.so -o test_shared_map -Wl,-rpath=.</span></span><br></pre></td></tr></table></figure><p>查看一个程序链接了哪些共享库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd test_shared_map</span></span><br><span class="line">        linux-vdso.so.1 (0x0000ffffbab40000)</span><br><span class="line">        hello.so =&gt; ./hello.so (0x0000ffffbaaee000)</span><br><span class="line">        b.so =&gt; ./b.so (0x0000ffffbaadc000)</span><br><span class="line">        libstdc++.so.6 =&gt; /lib/aarch64-linux-gnu/libstdc++.so.6 (0x0000ffffba951000)</span><br><span class="line">        libm.so.6 =&gt; /lib/aarch64-linux-gnu/libm.so.6 (0x0000ffffba894000)</span><br><span class="line">        libgcc_s.so.1 =&gt; /lib/aarch64-linux-gnu/libgcc_s.so.1 (0x0000ffffba870000)</span><br><span class="line">        libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffffba6fe000)</span><br><span class="line">        /lib/ld-linux-aarch64.so.1 (0x0000ffffbab12000)</span><br></pre></td></tr></table></figure><p>查看程序的 RPATH：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chrpath -l test_shared_map</span></span><br><span class="line">test_shared_map: RUNPATH=.</span><br></pre></td></tr></table></figure><p>查看 hello.so 共享库的 <code>.got</code>  和 <code>.got.plt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -h hello.so | grep got</span></span><br><span class="line"> 18 .got          00000048  0000000000010fa0  0000000000010fa0  00000fa0  2**3</span><br><span class="line"> 19 .got.plt      00000050  0000000000010fe8  0000000000010fe8  00000fe8  2**3</span><br></pre></td></tr></table></figure><p>查看 hello.so 共享库的重定位表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -R hello.so | less</span></span><br><span class="line">0000000000010fa8 R_AARCH64_GLOB_DAT  _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@GLIBCXX_3.4</span><br><span class="line">0000000000010fb0 R_AARCH64_GLOB_DAT  __cxa_finalize@GLIBC_2.17</span><br><span class="line">0000000000010fb8 R_AARCH64_GLOB_DAT  _ZSt4cout@GLIBCXX_3.4</span><br><span class="line">0000000000010fc0 R_AARCH64_GLOB_DAT  b</span><br><span class="line">0000000000010fc8 R_AARCH64_GLOB_DAT  _ITM_deregisterTMCloneTable</span><br><span class="line">0000000000010fd0 R_AARCH64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000010fd8 R_AARCH64_GLOB_DAT  _ITM_registerTMCloneTable</span><br><span class="line">0000000000010fe0 R_AARCH64_GLOB_DAT  _ZNSt8ios_base4InitD1Ev@GLIBCXX_3.4</span><br><span class="line">0000000000011000 R_AARCH64_JUMP_SLOT  __cxa_finalize@GLIBC_2.17</span><br><span class="line">0000000000011008 R_AARCH64_JUMP_SLOT  _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@GLIBCXX_3.4</span><br><span class="line">0000000000011010 R_AARCH64_JUMP_SLOT  _ZNSolsEPFRSoS_E@GLIBCXX_3.4</span><br><span class="line">0000000000011018 R_AARCH64_JUMP_SLOT  __cxa_atexit@GLIBC_2.17</span><br><span class="line">0000000000011020 R_AARCH64_JUMP_SLOT  _ZNSt8ios_base4InitC1Ev@GLIBCXX_3.4</span><br><span class="line">0000000000011028 R_AARCH64_JUMP_SLOT  _ZNSolsEi@GLIBCXX_3.4</span><br><span class="line">0000000000011030 R_AARCH64_JUMP_SLOT  __gmon_start__</span><br></pre></td></tr></table></figure><p>可以看到 <code>R_AARCH64_GLOB_DAT</code> 类型的变量每个占 8 个字节，并且在 0000000000010fb0~0000000000010fe0 范围内，正好这段区域在 <code>.got</code> 的区域内。而 <code>R_AARCH64_JUMP_SLOT</code> 每个也占 8 个字节，且正好都在 <code>.got.plt</code> 的区域内。</p><p>查看进程 <code>test_shared_map</code> 虚拟地址空间的映射关系：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./test_shared_map &amp;</span></span><br><span class="line">[1] 27652</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/27652/maps</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/03/15/bj44gJ.png"></p><p>可以看到这个进程的地址空间的分布</p><p>OS 把进程的虚拟地址空间分配给了：</p><ul><li>可执行文件：<code>/home/cwp/test/test_shared_map</code></li><li>堆栈：<code>[heap]</code>、<code>[stack]</code></li><li>共享库：<code>/home/cwp/test/b.so</code>、<code>/usr/lib/aarch64-linux-gnu/libc-2.28.so</code>、<code>/usr/lib/aarch64-linux-gnu/libgcc_s.so.1</code>、<code>/usr/lib/aarch64-linux-gnu/libm-2.28.so</code>、<code>/usr/lib/aarch64-linux-gnu/libstdc++.so.6.0.25</code>、<code>/home/cwp/test/hello.so</code>、<code>/usr/lib/aarch64-linux-gnu/ld-2.28.so</code></li><li>绕开陷入内核，加速系统调用：<code>[vdso]</code>、<code>[vvar]</code> （具体看我文章。。。。。）</li><li>匿名映射（内存到磁盘）：mmap</li></ul><p>其实通过 proc 这个文件系统就能很清楚的得知进程的虚拟地址的分布情况，这里栈空间仅仅只有 132KB，出乎意料的小。。。。堆空间也只有 132KB，但是堆可以增大（向系统申请）呀，栈却不能变大了呀。。。系统也太抠了。。。</p><h1 id="何时使用静态库何时使用动态库？"><a href="#何时使用静态库何时使用动态库？" class="headerlink" title="何时使用静态库何时使用动态库？"></a>何时使用静态库何时使用动态库？</h1><p>如果该库不经常更新，并且不被多数的可执行文件共享，那些就应该把他们编译成 static ！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><p>程序员的自我修养——链接、装载与库</p></li><li><p><a href="https://www.ibm.com/docs/en/aix/7.2?topic=techniques-when-use-dynamic-linking-static-linking">When to use dynamic linking and static linking</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dynamic-Link&quot;&gt;&lt;a href=&quot;#Dynamic-Link&quot; class=&quot;headerlink&quot; title=&quot;Dynamic Link&quot;&gt;&lt;/a&gt;Dynamic Link&lt;/h1&gt;&lt;h4 id=&quot;静态链接的缺陷&quot;&gt;&lt;a href=&quot;#静态链接的缺</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode 刷题笔记</title>
    <link href="https://codroc.github.io/2022/03/21/leetcode/"/>
    <id>https://codroc.github.io/2022/03/21/leetcode/</id>
    <published>2022-03-21T11:57:16.000Z</published>
    <updated>2022-03-21T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-刷题笔记"><a href="#Leetcode-刷题笔记" class="headerlink" title="Leetcode 刷题笔记"></a>Leetcode 刷题笔记</h1><p><strong>要开始刷题了，记录下那些思想比较绕的，一时半会想不起来怎么做的题目</strong>。</p><p><strong><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q || !root) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* l = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* r = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="comment">// 情况 1，p、q在左右两边</span></span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; r) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">// 两边都没有 p、q，那么直接返回</span></span><br><span class="line">        <span class="comment">// 情况 2 和 3</span></span><br><span class="line">        <span class="keyword">return</span> l ? l : r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>问题描述：给定一颗树的根节点 <code>root</code>，找出节点 <code>p</code> 和 <code>q</code> 的最近的公共祖先节点。</em></p><p>这个分三种情况：</p><ol><li>祖先节点正好在中间，而 p、q 节点在左右两边</li><li>p、q 都在一边，且祖先节点为 p</li><li>p、q 都在一边，且祖先节点为 q</li></ol><p>递归地查找 p、q 位置，即到底是在左右两边，还是在同一边。</p><p>对于第一种情况，我们只要返回 root 节点就行了；对于第二种情况，返回 p；第三种情况，返回 q</p><p><strong><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></strong></p><p>这一题和 <strong>至多有K个重复字符的最长字串、无重复字符的最长字串</strong> 有类似的概念，可以一起训练。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fz</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">26</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i)</span><br><span class="line">            a[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pairs;</span><br><span class="line">        <span class="keyword">int</span> nl = l;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">bool</span> need_partation = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = l; i &lt; r &amp;&amp; nl &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt; k) &#123;</span><br><span class="line">                need_partation = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - nl &gt;= k)    pairs.push_back(&#123;nl, i&#125;);</span><br><span class="line">                <span class="keyword">while</span> (i &lt; r &amp;&amp; a[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt; k) ++i;</span><br><span class="line">                nl = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!need_partation) <span class="keyword">return</span> r - l &gt;= k ? r - l : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i - nl &gt;= k)    pairs.push_back(&#123;nl, i&#125;);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : pairs)</span><br><span class="line">            ret = max(ret, fz(s, p[<span class="number">0</span>], p[<span class="number">1</span>], k));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fz(s, <span class="number">0</span>, s.size(), k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这道题的思想很重要，采用分治的思想：<strong>如果字符出现的次数少于 K 那么该字符比不可能出现在最长字串中，因此可以用该字符对字符串进行划分，划分成一个个的区间，然后对区间内的字符串再次采用分治思想。</strong></p><p>举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分治：对于一个字符串来说，如果要求子串最少出现k次，那么如果某些字母出现的次数小于k,</span></span><br><span class="line"><span class="comment">//这些字母一定不会出现在最长的子串中，并且这些字母将整个字符子串分割成小段，这些小段有可能是最长的</span></span><br><span class="line"><span class="comment">//但是由于被分割了，还是要检查这一小段，如果某些字母出现的次数小于k,会将小段继续分割下去,</span></span><br><span class="line"><span class="comment">//比如字符串&quot;aacbbbdc&quot;，要求最少出现2次,我们记录左右闭区间，，</span></span><br><span class="line"><span class="comment">//第一轮[0,7]，处理&quot;aacbbbdc&quot;，d只出现了一次不满足，于是递归解决区间[0,5]、[7,7]</span></span><br><span class="line"><span class="comment">//第二轮[0,5]，处理&quot;aacbbb&quot;，  c只出现了一次不满足，于是递归解决区间[0,1]、[3,4] </span></span><br><span class="line"><span class="comment">//第二轮[7,7]，处理&quot;c&quot;，       c只出现了一次不满足，不继续递归</span></span><br><span class="line"><span class="comment">//第三轮[0,1]，处理&quot;aa&quot;，      满足出现次数&gt;=2,ret=2</span></span><br><span class="line"><span class="comment">//第三轮[3,4]，处理&quot;bbb&quot;，     满足出现次数&gt;=2 ret=3;</span></span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></strong></p><p>这题刚开始碰到是不会做的，感觉思想还是挺有意思的，记录下！</p><p>看下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>看下数据的范围：</p><ul><li>n == nums1.length</li><li>n == nums2.length</li><li>n == nums3.length</li><li>n == nums4.length</li><li>1 &lt;= n &lt;= 200</li><li>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</li></ul><p>n = 200，所以暴力肯定超时，最好想个 O(n*n) 的方法~</p><p>如果是两数相加要怎么做？两数相加很简单的：</p><p><code>target = a + b</code>，只要在 map 中记录 a，然后查到 b 的时候，查以下 map 里面有没有 a 就行了。</p><p>其实四数相加完全可以转化成两数相加：</p><p><code>target = (a + b) + (c + d)</code> ，那么我们先计算前两个数组之和，如示例1，<code>a + b</code>两两组合就会产生 4 个值 L1= [-1, 0, 0, 1]; <code>c + d</code> 两两组合就会产生 4 个值 L2 = [-1, 1, 2, 4];</p><p>接下来其实就是两数相加的内容了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for x1 in L1, x2 in L2:</span><br><span class="line">if x1 + x2 &#x3D;&#x3D; target</span><br><span class="line">ret++</span><br></pre></td></tr></table></figure><p>这里还可以通过 map 进行优化，最终得到的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp1, mp2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 : nums2)</span><br><span class="line">                mp1[i1+i2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 : nums4)</span><br><span class="line">                mp2[i1+i2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = mp1.begin(); it1 != mp1.end(); ++it1) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - it1-&gt;first;</span><br><span class="line">            <span class="keyword">int</span> times = it1-&gt;second;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> it2 = mp2.find(target); it2 != mp2.end()) &#123;</span><br><span class="line">                ret += it2-&gt;second * times;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">1109. 航班预定系统</a></strong></p><p>这道题就是考察一个知识点，那就是：**<a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分数组</a>**</p><p>其实一开始，我只是绝对对同一个区间进行相同的操作，没必要再遍历，但是就是找不出用什么别的方法，原来可以用差分。。。。。</p><p>差分数组的应用场景：对区间内 [l, r] 内的元素做同一类型的操作，那么就可以用差分数组。</p><p>由于差分数组是通过后一个减前一个的方式得到的即 d[i] = a[i] - a[i - 1]，i &gt; 0。因此如果在区间 [l, r] 中进行 +val 操作，就会导致：</p><ul><li>a[l] - a[l - 1] = d[l] + val</li><li>a[r + 1] - a[r] = d[r + 1] - val</li></ul><p>因此只要改变差分数组中的两个元素就可以了，一个是 d[l]，一个是 d[r + 1]</p><p>接下来看下题目：</p><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</p><p>请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer &#x3D; [10,55,45,25,25]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : bookings) &#123;</span><br><span class="line">            <span class="keyword">int</span> first = e[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> last = e[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> seats = e[<span class="number">2</span>];</span><br><span class="line">            d[first] += seats;</span><br><span class="line">            <span class="keyword">if</span> (last &gt;= n + <span class="number">1</span>)   <span class="keyword">continue</span>;</span><br><span class="line">            d[last] -= seats;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n + <span class="number">1</span>;++i)</span><br><span class="line">            d[i] = d[i] + d[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> &#123;d.data() + <span class="number">1</span>, d.data()+d.size()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></strong></p><p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,0,0,0,1,1,1,1,0], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释：[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K &#x3D; 3</span><br><span class="line">输出：10</span><br><span class="line">解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 10。</span><br></pre></td></tr></table></figure><p>这题用前缀和，v[i] 表示前面有几个 0。</p><p>但是这里的索引以及边界问题的使用很让人不解。。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            v[i] = v[i - <span class="number">1</span>] + <span class="number">1</span> - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 这里为什么要从 0 开始遍历</span></span><br><span class="line">            <span class="keyword">int</span> left = lower_bound(v.begin(), v.end(), v[i + <span class="number">1</span>] - k) - v.begin();</span><br><span class="line">            ret = max(ret, i - left + <span class="number">1</span>); <span class="comment">// 为什么是 i - left + 1 而不是 i - left</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></strong></p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><p><strong>方法：中间扩散法！</strong></p><p>首先确定回文串，就是找中心然后想两边扩散看是不是对称的就可以了。</p><p><strong>在遍历中心点的时候，要注意中心点有两种情况</strong>。</p><p>一个元素可以作为中心点，两个元素也可以作为中心点。</p><p>所以我们在计算的时候，要注意一个元素为中心点和两个元素为中心点的情况。</p><p><strong>这两种情况可以放在一起计算，但分别计算思路更清晰，我倾向于分别计算</strong>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i) &#123;</span><br><span class="line">            l = r = i;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;=<span class="number">0</span> &amp;&amp; r &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[l] != s[r]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; ret.size())</span><br><span class="line">                    ret = s.substr(l, r - l + <span class="number">1</span>);</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i) &#123;</span><br><span class="line">            l = r = i; r++;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;=<span class="number">0</span> &amp;&amp; r &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[l] != s[r]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; ret.size())</span><br><span class="line">                    ret = s.substr(l, r - l + <span class="number">1</span>);</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></strong></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>这一题实际上就是考察<strong>快排</strong>会不会，以及对快排进行优化，即随机取一个数作为<strong>比较数</strong>，而不是呆呆得永远取第一个数，</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t_l = l, t_r = r;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; l) &#123; <span class="comment">// 引入随机性，防止退化到 O(n*n)</span></span><br><span class="line">            <span class="keyword">int</span> idx = rand()%(r - l) + l; <span class="comment">// 注意 r - l = 0 时会发生计算错误</span></span><br><span class="line">            swap(nums[l], nums[idx]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp_num = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &gt; l &amp;&amp; nums[r] &lt;= cmp_num) --r;</span><br><span class="line">            swap(nums[l], nums[r]);</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &gt;= cmp_num) ++l;</span><br><span class="line">            swap(nums[l], nums[r]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> == k) <span class="keyword">return</span> nums[l];</span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span> &lt; k ? findK(nums, l + <span class="number">1</span>, t_r, k) :</span><br><span class="line">            findK(nums, t_l, r - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用快排的思想</span></span><br><span class="line">        <span class="keyword">return</span> findK(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. 数据流的中位数</a></strong></p><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addNum(1)</span><br><span class="line">addNum(2)</span><br><span class="line">findMedian() -&gt; 1.5</span><br><span class="line">addNum(3)</span><br><span class="line">findMedian() -&gt; 2</span><br></pre></td></tr></table></figure><p>进阶:</p><ol><li>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</li><li>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</li></ol><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p>中位数，只要记住用</p><ol><li><strong>大顶堆 + 小顶堆</strong></li><li><strong>大顶堆 &lt; 小顶堆</strong></li></ol><p>因此就相当于把整个有序列表划分成两部分，前面的部分在大顶堆，后面部分在小顶堆，只要保持 <strong>|大顶堆.size() - 小顶堆.size()| &lt;= 1</strong></p><p>就可以轻松获得中位数了！代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; min_pq;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; max_pq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MedianFinder()</span><br><span class="line">        : min_pq()</span><br><span class="line">        , max_pq()</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (min_pq.empty() || min_pq.top() &lt;= num) &#123;</span><br><span class="line">            min_pq.push(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> max_pq.push(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min_pq.size() &gt; max_pq.size() + <span class="number">1</span>) &#123;</span><br><span class="line">            max_pq.push(min_pq.top());</span><br><span class="line">            min_pq.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> + min_pq.size() &lt; max_pq.size()) &#123;</span><br><span class="line">            min_pq.push(max_pq.top());</span><br><span class="line">            max_pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ret;</span><br><span class="line">        <span class="keyword">if</span> (min_pq.size() == max_pq.size()) &#123;</span><br><span class="line">            ret = (min_pq.top() + max_pq.top()) * <span class="number">1.0</span> /<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(min_pq.size() &gt; max_pq.size()) &#123;</span><br><span class="line">            ret = min_pq.top() * <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> ret = max_pq.top() * <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态规划之子序列问题"><a href="#动态规划之子序列问题" class="headerlink" title="动态规划之子序列问题"></a>动态规划之子序列问题</h2><ol><li><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a></li><li><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674.最长连续递增序列</a></li><li><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718.最长重复子数组</a></li><li><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143.最长公共子序列</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html">1035.不相交的线</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">53.最大子序和</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html">392.判断子序列</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html">115.不同的子序列</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html">583.两个字符串的删除操作</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html">72.编辑距离</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html">为了绝杀编辑距离，我做了三步铺垫，你都知道么？</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html">647.回文子串</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html">516.最长回文子序列</a></li><li><a href="https://leetcode-cn.com/link/?target=https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html">动态规划总结篇</a></li></ol><hr><p><strong><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a></strong></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长<strong>严格递增子序列</strong>的<strong>长度</strong>。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>注意项：</p><ul><li><p>注意这里说的是子序列而不是子串</p></li><li><p>只需要返回长度，不需要具体的子序列</p></li><li><p>严格递增</p></li></ul><p>用 dp[n] 表示 n 个元素的数组中，以 nums[n - 1] <strong>元素结尾</strong>的最长<strong>严格递增子序列</strong>的<strong>长度</strong> 为 dp[n]，那么</p><p>dp[n + 1] = max(dp[i] + 1)，其中必须满足 nums[i] &lt; nums[n + 1]，i = 0~n</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = max(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718.最长重复子数组</a></strong></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,3,2,1], nums2 &#x3D; [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3,2,1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [0,0,0,0,0], nums2 &#x3D; [0,0,0,0,0]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li></ul><p>这一题明显和前面的那种有较大的差别了，因为它涉及两个数组，而前面的都是在一个数组里面折腾的。</p><p>这种两个数组的优先考虑二维 DP。再结合 一维时候的思想：dp[i] 表示 第 i 个元素结尾的最长xxx子串。</p><p>最后可以想到：用 dp[i][j] 表示以 nums1[i] 和 nums2[j] 结尾的最长公共子串的长度，那么</p><ul><li>如果 nums1[i] == nums2[j]，dp[i][j] =  dp[i - 1][j - 1] + 1</li><li>如果 nums1[i] != nums2[j]，dp[i][j] =  0</li></ul><p>只要找到最大的那个 dp[i][j] 就可以了</p><p>这里还需要一个小技巧，由于依赖于 i - 1 和 j - 1 因此，遍历的 i，j 要从 1 开始。那么我们就多加一行一列，下标 1 实际上对应于数组中的下标 0，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n2 + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        ret = dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n1 + <span class="number">1</span>;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n2 + <span class="number">1</span>;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    ret = max(ret, dp[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143.最长公共子序列</a></strong></p><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><p>这里也是出现了两个字符串，毫无疑问，继续二维 DP，与上一题不同的是，这里要求的是子序列而非子串，子序列可以是不连续的。</p><p>用 dp[i][j] 表示以 text1[i]、text2[j] 结尾的字符串的最长公共子序列长度，那么会遇到两种情况：</p><ol><li>text1[i] == text2[j]，此时 dp[i][j] = dp[i - 1][j - 1] + 1;</li><li>text1[i] != text2[j]，此时取两组字符串中公共子序列最长的值，其一为 (text1[i - 1], text2[j])，其二为 (text1[i], text2[j - 1])，因此 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示字符串 text1[i]、text2[j] 的最长公共子序列长度</span></span><br><span class="line">        <span class="comment">// 如果 text1[i] == text2[j], dp[i][j] = dp[i - 1][j - 1] + 1</span></span><br><span class="line">        <span class="comment">// 如果 text1[i] != text2[j], dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</span></span><br><span class="line">        <span class="keyword">int</span> n1 = text1.size(), n2 = text2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n2 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n1 + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n2 + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给出表格更好理解：</p><p>   a b c d e</p><p>a 1 1 1 1 1</p><p>c 1 1 2 2 2</p><p>e 1 1 2 2 3</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Leetcode-刷题笔记&quot;&gt;&lt;a href=&quot;#Leetcode-刷题笔记&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 刷题笔记&quot;&gt;&lt;/a&gt;Leetcode 刷题笔记&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;要开始刷题了，记录下那些思想比较绕的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多线程下 fork 与 exit 引发的连锁错误</title>
    <link href="https://codroc.github.io/2022/03/10/fork_and_exit_error/"/>
    <id>https://codroc.github.io/2022/03/10/fork_and_exit_error/</id>
    <published>2022-03-10T11:57:16.000Z</published>
    <updated>2022-03-10T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程下-fork-与-exit-引发的连锁错误"><a href="#多线程下-fork-与-exit-引发的连锁错误" class="headerlink" title="多线程下 fork 与 exit 引发的连锁错误"></a>多线程下 fork 与 exit 引发的连锁错误</h1><p><strong>这篇文章存在问题！！！</strong></p><p>问题出现在这样的情景下：</p><p>编译完 <code>loggerTest.cpp</code> 后，执行后，程序被阻塞不能退出,在通过 <code>ps aux|grep ./loggerTest</code> 一看，好家伙，原来是 <code>asyncLogging.cpp</code> 中的rollFile 函数 fork 出来的进程都还没释放掉，而且都处在 S 状态，也就是被阻塞了！</p><p><img src="https://s1.ax1x.com/2022/03/10/b4sqMV.png"></p><p>本来 fork 出这个进程是为了 roll file 的，也就是把 log 文件进行压缩打包用的。代码片段如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line"><span class="comment">// 执行脚本，对原来的 日志包 解包，对每个日志文件重命名（0=&gt;1，1=&gt;2 ...），然后将 1~N                                                   的日志文件重新压缩打包，父进程等待子进程退出，这阶段父进程不能持有任何锁</span></span><br><span class="line">    <span class="keyword">char</span> *args[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> newfile[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(newfile, <span class="number">0</span>, <span class="keyword">sizeof</span>(newfile));</span><br><span class="line">    <span class="built_in">memcpy</span>(newfile, ret.c_str(), ret.size());</span><br><span class="line">    args[<span class="number">0</span>] = <span class="string">&quot;jiaoben&quot;</span>;</span><br><span class="line">    args[<span class="number">1</span>] = newfile;</span><br><span class="line">    args[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        execv(<span class="string">&quot;jiaoben&quot;</span>, args);</span><br><span class="line">    wait(<span class="number">0</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到本来的预期是 fork 出一个子进程后，立马 execv 让可执行文件 <code>jiaoben</code> 来覆盖原来的内容（包括页表，各种锁、条件变量的状态，当然还有内核数据结构）。<code>jiaoben</code> 这个可执行文件就是用来执行 python 脚本的，照理说执行完会立马退出的呀！</p><p>好在这个进程没退出，我们可以用 gdb 来追踪它的状态：</p><p><img src="https://s1.ax1x.com/2022/03/10/b4sLrT.png" alt="gdb 追踪状态"></p><p>这是妥妥的连 execv 都没执行成功呀（因为 如果没有子进程 wait(0) 会直接返回 -1，所以子进程相当于继续执行下去了）！然后一看目录下，我晕，<code>jiaoben.cpp</code> 忘记编译了，所以 execv 执行失败，后端日志线程就回到 while 循环了，一直执行 <code>_cond.waitForSecs(3);</code> 这也就导致该进程在 ps 命令中看上去一直被阻塞了！</p><p>这也是血的教训呀！每次调用函数后一定要判断是否调用成功！不然有的苦头吃啊~~接下来，自然地将代码改成如下片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line"><span class="comment">// 执行脚本，对原来的 日志包 解包，对每个日志文件重命名（0=&gt;1，1=&gt;2 ...），然后将 1~N                                                   的日志文件重新压缩打包，父进程等待子进程退出，这阶段父进程不能持有任何锁</span></span><br><span class="line">    <span class="keyword">char</span> *args[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> newfile[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">memset</span>(newfile, <span class="number">0</span>, <span class="keyword">sizeof</span>(newfile));</span><br><span class="line">    <span class="built_in">memcpy</span>(newfile, ret.c_str(), ret.size());</span><br><span class="line">    args[<span class="number">0</span>] = <span class="string">&quot;jiaoben&quot;</span>;</span><br><span class="line">    args[<span class="number">1</span>] = newfile;</span><br><span class="line">    args[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == execv(<span class="string">&quot;jiaoben&quot;</span>, args))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    wait(<span class="number">0</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很自然呀！如果 execv 执行失败，让它退出就行了！但是好像并没那么容易，再次执行 <code>loggerTest</code>，发现连该进程都被阻塞了。当即用 <code>ps aux|grep ./loggerTest</code> 查看后，发现有两个名为<code>loggerTest</code> 的进程处在运行状态，退不出去！那没事，只要你还活着，我就能用 gdb attach 到你~~继续使用 gdb 去查看哪里出错了：</p><p>这一个 gdb 追踪的是原始的 <code>./loggerTest</code> 进程，因为它有 2 个线程，而 fork 只能 fork 出一个线程。</p><p><img src="https://s1.ax1x.com/2022/03/10/b46RAg.png" alt="原始 ./threadTest 进程"></p><p>可以看到测试进程<code>./loggerTest</code> 的主线程一直在 <code>AsyncLogging::stop</code> 上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 _currentBuffer 中有数据是不能让 _running 变成 False 的，不然就丢失数据了</span></span><br><span class="line">    <span class="comment">// 必须是 前端退出后，才能调用后端的 stop</span></span><br><span class="line">    assert(_running);</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexGuard <span class="title">guard</span><span class="params">(_lock)</span></span>;</span><br><span class="line">        size = _currentBuffer-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _cond.wakeup();</span><br><span class="line">        <span class="function">MutexGuard <span class="title">guard</span><span class="params">(_lock)</span></span>;</span><br><span class="line">        size = _currentBuffer-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    _running = <span class="literal">false</span>;</span><br><span class="line">    _cond.wakeup();</span><br><span class="line">    _thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个函数一直停留在 <code>stop</code> 中的唯一理由就是一直在 while 循环内出不去，也就是 wakeup 没作用，日志后端线程根本不鸟这个 wakeup。</p><p>再来看看打包日志的进程，它又是为什么迟迟不肯退出呢？</p><p><img src="https://s1.ax1x.com/2022/03/10/b46Icq.png" alt="打包日志的进程"></p><p>可以看到它也一直停留在 <code>AsyncLogging::stop</code> 上。<strong>并且这个进程只有一个线程，那么这个 wakeup 就很搞笑了呀，因为根本没有接收者，或者说接收这个 wakeup 的人就是你自己，而你此时在 while 循环里永远也接收不到</strong>。再回到 roll file 的代码片段，它是一直阻塞等待着子进程退出才会继续执行下去的，然而此时子进程（打包日志的进程）永远也退不出，这就导致了 <code>./loggerTest</code> 进程的后端日志线程永远被阻塞（可以通过 gdb 查看 thread 2 阻塞的位置就知道了 __GI__wait4），</p><p><img src="https://s1.ax1x.com/2022/03/10/b46LEF.png" alt="./loggerTest 进程的 thread 2"></p><p>进而导致前端日志线程退出时执行 <code>AsyncLogging::stop</code> 的 wakeup 却得不到后端日志线程的响应（因为它一直 wait(0) 等着子进程退出），这一系列连锁反应就导致了现在的尴尬局面~~</p><p>该怎么解决？那就是让 execv 一定要执行成功，在执行前判断脚本文件是否存在，如果不存在则不要在多线的情况下去 fork 了，很容易造成复杂的错误！</p><h1 id="带来的启发"><a href="#带来的启发" class="headerlink" title="带来的启发"></a>带来的启发</h1><ul><li>在多线程环境下，调用 fork 后一定要立马确定 execv 成功，不然的话很容易出现复杂难以诊断的错误。因为 fork 在 linux 环境下只会 fork 出一个线程，这样本质上就和 锁，条件变量 等待同步工具在概念上矛盾了（同步工具用于多线程环境，而 fork 出来的是单线程进程）。</li><li>不要以为调用了 exit 后 os 一定就会帮你释放掉资源，因为在 C++ 中，还存在全局对象析构这么一个环节，很有可能在这个环节 整个进程就阻塞住了，进而导致资源得不到释放，慢慢的把你的内存吃光！！！</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程下-fork-与-exit-引发的连锁错误&quot;&gt;&lt;a href=&quot;#多线程下-fork-与-exit-引发的连锁错误&quot; class=&quot;headerlink&quot; title=&quot;多线程下 fork 与 exit 引发的连锁错误&quot;&gt;&lt;/a&gt;多线程下 fork 与 ex</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cache coherence</title>
    <link href="https://codroc.github.io/2022/03/07/cache_coherence/"/>
    <id>https://codroc.github.io/2022/03/07/cache_coherence/</id>
    <published>2022-03-07T11:57:16.000Z</published>
    <updated>2022-03-07T11:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cache-Coherence"><a href="#Cache-Coherence" class="headerlink" title="Cache Coherence"></a>Cache Coherence</h2><p>​    cache coherence 也就是 cache 一致性问题，首先解释下这个问题为什么会存在。</p><h3 id="Cache-存在的必要性"><a href="#Cache-存在的必要性" class="headerlink" title="Cache 存在的必要性"></a>Cache 存在的必要性</h3><p>​    众所周知，CPU 频率远大于内存频率，那么具体大多少呢？可以看这篇文章哦~~<a href="https://zhuanlan.zhihu.com/p/98560121">《CPU到底有多快？内存：是我的250倍》</a>。我记得是拉跨的 CPU 都能在 1/3 ns 内执行完一条简单指令，而一次访存操作至少要 80 ns。</p><p>​    那么我们听到的什么 DDR4-3200-1600MHZ 是什么意思呢？3200 是指传输速率为 3.2Gbit/s，而 1600MHZ 是指接口总线频率，其工作频率实质只有 400MHZ（接口频率是工作频率的 4 倍了）。如果 2GHZ 的 CPU 算接口频率的话，集成PCI-e 3.0控制器的 CPU，接口频率可是 8 GHz；4.0的则是 16 GHz。除此之外，总线也可能造成瓶颈。</p><p>​    由于 CPU 和内存之间存在着处理能力鸿沟，因此 Cache 就应运而生了（访问 cache 大概在 1ns 吧）。</p><p>写 Cache 的两种策略：</p><ul><li>直写</li><li>写回</li></ul><p><strong>直写的逻辑</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(数据不在 Cacheline 中) &#123;</span><br><span class="line">    直接写到内存中去;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">写 Cacheline;</span><br><span class="line">    写 内存;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写回的逻辑</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(数据在 Cacheline 中) &#123;</span><br><span class="line">    直接写 Cache;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(当前 Cacheline 是脏的) &#123;</span><br><span class="line">        将 Cacheline 中的数据写回到内存;</span><br><span class="line">    &#125;</span><br><span class="line">从内存中加载数据到 Cacheline;</span><br><span class="line">    写 Cacheline;</span><br><span class="line">&#125;</span><br><span class="line">将 Cacheline 标记为脏;</span><br></pre></td></tr></table></figure><h3 id="多核导致的-Cache-不一致现象"><a href="#多核导致的-Cache-不一致现象" class="headerlink" title="多核导致的 Cache 不一致现象"></a>多核导致的 Cache 不一致现象</h3><p>现有两个核心 A,B，每个核心有自己独属的 Cache。它们都读取一个共享变量 i，并用<strong>写回策略</strong>对 i 进行 ++ 操作，整个流程可以用下图表示：</p><p><img src="https://s4.ax1x.com/2022/03/05/b01IMt.png"></p><p>由于它们都在 i = 0 时缓存了 i，并对 i 做 ++ 操作，因此最终将会导致 i = 1 而非 2；原因在于 A 核心执行 i++ 后没有将结果同步到 B 核心缓存的 i 变量上面去，也就是 i 这个共享变量的一致性遭到了破坏。</p><p>那么如何解决这个问题呢？最简单的想法就是，<strong>最好我修改之前看到的变量已经是最新的了，在我修改之后立马让所有核心看到最新的值</strong>。</p><ul><li>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播（<em>Write Propagation</em>）</strong></li><li>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串形化（<em>Transaction Serialization</em>）</strong>。</li></ul><h3 id="MESI-协议-总线嗅探机制-实现-写传播和事务串行化"><a href="#MESI-协议-总线嗅探机制-实现-写传播和事务串行化" class="headerlink" title="MESI 协议 + 总线嗅探机制 实现 写传播和事务串行化"></a>MESI 协议 + 总线嗅探机制 实现 写传播和事务串行化</h3><p>​    下图是 CPU Cache 的概览图，Cache 可以分成多个 Cacheline，每个 Cacheline 里有一个 Tag 和一个数据块。<strong>其实除此之外，还记录了当前 Cacheline 与物理地址之间的映射</strong>。Tag 中有四种标记：</p><ul><li>M: Modified</li><li>E: Exclude</li><li>S: Shared</li><li>I: Invalid</li></ul><p><img src="https://s1.ax1x.com/2022/03/07/b6ABVg.png"></p><p>​    <strong>总线嗅探机制</strong>，wiki 解释：<strong>Bus snooping</strong> or <strong>bus sniffing</strong> is a scheme by which a coherency controller (snooper) in a <a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache</a> (a <strong>snoopy cache</strong>) monitors or snoops the bus transactions, and its goal is to maintain a <a href="https://en.wikipedia.org/wiki/Cache_coherence">cache coherency</a> in <a href="https://en.wikipedia.org/wiki/Distributed_shared_memory">distributed shared memory systems</a>.</p><blockquote><p><strong>How it works?</strong> When specific data is shared by several caches and a processor modifies the value of the shared data, the change must be propagated to all the other caches which have a copy of the data. This change propagation prevents the system from violating <a href="https://en.wikipedia.org/wiki/Cache_coherence">cache coherency</a>. The notification of data change can be done by bus snooping. All the snoopers monitor every transaction on a bus. If a transaction modifying a shared cache block appears on a bus, all the snoopers check whether their caches have the same copy of the shared block. If a cache has a copy of the shared block, the corresponding snooper performs an action to ensure cache coherency. The action can be a <a href="https://forums.xilinx.com/t5/Embedded-Development-Tools/what-is-the-difference-between-cache-invalidate-and-cache-flush/td-p/74654">flush</a> or an <a href="https://en.wikipedia.org/wiki/Cache_invalidation">invalidation</a> of the cache block. It also involves a change of cache block state depending on the cache coherence protocol.</p></blockquote><p>​    其实上面的意思是当<strong>被多个核心中的 Cache 共享的数据</strong>将要发生改变时，这个<strong>即将发生改变的通知</strong>会通过总线广播到所有核心并被 Cache 中的嗅探器捕捉到，随后做出一系列操作来保证 Cache 一致性。所以这里嗅探器其实会查看自己是否拥有这个共享数据，据推断就是通过 Cacheline 与物理地址之间的映射来做判断的。</p><p>​    <strong>MESI 协议</strong>是 cache 一致性协议中的一种，也比较好理解。它借助 Cacheline 中的 Tag 标记以及 总线嗅探机制实现了一个状态机，从而实现<strong>写传播</strong>和<strong>事务串行化</strong>。</p><p>​    MESI 每一个标记都是一种状态，那么就有 4 种状态；每一种状态下，嗅探器都可能从总线上嗅探到 4 种通知：local read，local write，remote read，remote write（其实就是 local，remote 和 read，write 的排列组合）。某个核心中共享的 Cacheline 会根据自己所处的状态以及嗅探到的通知来进行状态之间的转换：</p><p><img src="https://s1.ax1x.com/2022/03/07/b6u1yR.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/98560121">《CPU到底有多快？内存：是我的250倍》</a></li><li><a href="https://www.zhihu.com/question/349982942">内存运行速度</a></li><li><a href="https://blog.csdn.net/qq_34827674/article/details/109317760">10 张图打开 CPU 缓存一致性的大门</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Cache-Coherence&quot;&gt;&lt;a href=&quot;#Cache-Coherence&quot; class=&quot;headerlink&quot; title=&quot;Cache Coherence&quot;&gt;&lt;/a&gt;Cache Coherence&lt;/h2&gt;&lt;p&gt;​    cache coheren</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Fiber 库</title>
    <link href="https://codroc.github.io/2022/02/27/Fiber/"/>
    <id>https://codroc.github.io/2022/02/27/Fiber/</id>
    <published>2022-02-27T13:29:12.000Z</published>
    <updated>2022-02-27T13:29:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于-ucontext-封装的-Fiber-库"><a href="#基于-ucontext-封装的-Fiber-库" class="headerlink" title="基于 ucontext 封装的 Fiber 库"></a>基于 ucontext 封装的 Fiber 库</h1><p>协程优点：</p><ul><li>切换速度快</li><li>切换灵活</li><li>为降低竞争提供另一种思路</li><li>实现异步 epoll</li></ul><p>​    协程是轻量级的线程，由于协程切换属于 用户级别的上下文切换，不会陷入内核，因此切换速度比线程更快自然延迟更低。根据陈海波老师的《<a href="https://www.zhihu.com/search?q=%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2153166653%7D">现代操作系统 原理与实现</a>》一书的105页中： <strong>经过测试，在使用AArch64架构的华为鲲鹏916服务器上，如果使用内核态线程，那么生产者线程切换到消费者线程需要话费约1900ns；而如果使用纤程，该切换时间降低到约500ns。</strong>可以看到差距的巨大。</p><p>​    由于协程切换是在用户级别进行的，因此完全由用户自主操控，想要在哪里切换就在哪里切换，十分灵活。</p><p>​    可以使用多进程（单线程）+协程尽可能的避免race condition，降低各种竞争，从而降低延迟。例如一个线程就可以实现生产者消费者模型，并且不需要加锁。</p><p>​    怎么实现异步 epoll？</p><p>Fiber 库特性：</p><ul><li>非对称协程</li><li>基于 POSIX ucontext.h</li></ul><p>​    我设计的 Fiber 库，每个线程都有一个主协程，并能创建多个子协程；子协程只能把 CPU 控制权交还给主协程，而不能交给其他子协程，故而为非对称协程。</p><p>​    该 Fiber 库基于 ucontext.h 实现</p><hr><p>Fiber 库应该具有的功能：</p><ul><li>隐藏主协程创建的接口，暴露子协程创建接口</li><li>从主协程切换（swapIn）到子协程</li><li>从子协程切换（swapOut）到主协程</li><li>子协程执行代码的入口函数</li><li>协程清理</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fiber</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">// 暴露子协程创建接口</span></span><br><span class="line">     Fiber(<span class="keyword">const</span> Fiber::Callback&amp; cb, <span class="keyword">size_t</span> stackSize);</span><br><span class="line">     <span class="comment">// 获取当前协程 </span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> ptr <span class="title">GetThis</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">// 设置当前协程</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetThis</span><span class="params">(ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 切换到该协程</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">swapIn</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">// 切换到主协程</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">swapOut</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 隐藏主协程创建的接口</span></span><br><span class="line">    Fiber();</span><br><span class="line">     <span class="comment">// 所有协程入口函数</span></span><br><span class="line">     <span class="comment">// 如同所有进程的入口 main 一样</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MainFunc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">ucontext_t</span> _ctx;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的重点在于为每一个线程创建一个 thread_local 用于存储 主协程指针 <code>t_threadFiber</code> 和 当前协程指针 <code>t_curFiber</code>，这样的话就能根据 这两个变量进行 主协程与子协程 间的切换了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber::ptr t_curFiber = <span class="literal">nullptr</span>; <span class="comment">// 当前协程</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber::ptr t_threadFiber = <span class="literal">nullptr</span>; <span class="comment">// 主协程,只有当线程退出时，才会将主协程析构</span></span><br><span class="line"><span class="comment">// 切换到该协程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::swapIn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SetThis(shared_from_this());</span><br><span class="line">    <span class="comment">// 主协程即将切换出去</span></span><br><span class="line">    <span class="comment">// 把上下文保存到 主协程的 ctx 中，并恢复该协程的上下文</span></span><br><span class="line">    ::swapcontext(&amp;t_threadFiber-&gt;_ctx, &amp;_ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 切换到主协程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::swapOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SetThis(t_threadFiber);</span><br><span class="line">    <span class="comment">// 即将从子协程切换出去</span></span><br><span class="line">    <span class="comment">// 把上下文保存到 该协程的 ctx 中，并恢复主协程的上下文</span></span><br><span class="line">    ::swapcontext(&amp;_ctx, &amp;t_threadFiber-&gt;_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>性能测试</strong></p><p>鲲鹏通用计算增强型 2G、1CPU 、1Core：</p><ul><li>协程：切换 100w 次 需要 814ms</li><li>线程：通过生产者消费者队列（队列长度为 1）进行测试（当然有加锁，解锁，条件变量等额外的操作）。切换 100w 次 需要 3300ms（3微秒/切换）</li></ul><p>Inter(R) Core(TM) i7-9700 CPU @ 3.00GHz ，7 Core、4G虚拟机：</p><ul><li>协程：切换 100w 次 需要 430ms</li><li>线程：通过生产者消费者队列（队列长度为 1）进行测试（当然有加锁，解锁，条件变量等额外的操作）。切换 100w 次 需要 32000ms（32微秒/切换）</li></ul><p><strong>分析：</strong></p><p>协程比线程快这是不言而喻的，但是线程上表现出来的数值就很奇怪了，在 1 Core 的鲲鹏虚拟机上 切换一次线程费时 大约 3微秒；但在更快的 i7-9700 CPU 虚拟机上却要 32微秒；这是为什么呢？</p><p>其实这两台实验设备上最大的差别就是<strong>一个是单核一个是多核</strong>。多个核共享一个变量，并把变量保存在 cacheline 中，当某个核要对该变量进行读写操作时，就要保证能看到其他核的 cacheline 中关于该变量的最新的值。这就存在 cacheline 同步的问题，只能等待 CPU 完成<a href="https://en.wikipedia.org/wiki/Cache_coherence">一致性同步</a>之后才能继续用户操作。这就导致速度变得很慢。</p><p><strong>至理名言：</strong>要提高性能，就要避免让CPU频繁同步cacheline。这不单和原子指令本身的性能有关，还会影响到程序的整体性能。最有效的解决方法很直白：<strong>尽量避免共享</strong>。                                                        —–bRPC</p><blockquote><p>一个相关的编程陷阱是false sharing：对那些不怎么被修改甚至只读变量的访问，由于同一个cacheline中的其他变量被频繁修改，而不得不经常等待cacheline同步而显著变慢了。多线程中的变量尽量按访问规律排列，频繁被其他线程修改的变量要放在独立的cacheline中。要让一个变量或结构体按cacheline对齐</p></blockquote><hr><p><strong>存在的问题：</strong></p><p>如果用户调用 swapIn 和 swapOut 的顺序不对，可能会导致 Fiber 对象无法正常释放资源，导致资源泄露。因此要设计一个自动回收永远不会再用到的 Fiber 对象的类。</p><p>当然这一点可以通过再设计一个协程调度器类来解决，把所有的 Fiber 实现都隐藏起来，也就是说用户不能自己去 swapIn、swapOut 了，全权交给调度器去做，仅仅支持用户注册一个协程或想要执行的实例。</p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于-ucontext-封装的-Fiber-库&quot;&gt;&lt;a href=&quot;#基于-ucontext-封装的-Fiber-库&quot; class=&quot;headerlink&quot; title=&quot;基于 ucontext 封装的 Fiber 库&quot;&gt;&lt;/a&gt;基于 ucontext 封装的 F</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MVCC</title>
    <link href="https://codroc.github.io/2021/12/24/MVCC/"/>
    <id>https://codroc.github.io/2021/12/24/MVCC/</id>
    <published>2021-12-23T16:00:00.000Z</published>
    <updated>2021-12-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC 即<strong>多版本并发控制</strong>，是在并发事务场景下用于支持 RC、RR 隔离级别的实现</p><p>四种隔离级别：</p><ul><li>读未提交</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatable Read）</li><li>串行</li></ul><p>事务隔离是怎么实现的？</p><p>在 mysql 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作（undo log），都可以得到前一个状态的值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="https://s4.ax1x.com/2021/12/23/T8oNDg.png"></p><p>这里可以看到一条记录存在多个版本，着就是 MVCC 的 MV 的由来。</p><h4 id="mysql-中存在两个“视图”的概念："><a href="#mysql-中存在两个“视图”的概念：" class="headerlink" title="mysql 中存在两个“视图”的概念："></a>mysql 中存在两个“视图”的概念：</h4><ul><li>一个是 view。它是用一个查询语句定义的虚拟表</li><li>另一个是 Innodb 中实现 MVCC 时用到的<strong>一致性读视图</strong>（consistent <strong>read view</strong>），用于支持 RC、RR 隔离级别的实现</li></ul><p><strong>一致性视图</strong>的创建时机有两种：</p><ul><li>在 begin/start transaction 后的第一条语句开始时创建</li><li>在 执行 start transaction with consistent snapshot 时创建</li></ul><p>这个 <strong>一致性视图</strong> 是什么东西？它其实就是一个“快照”，如果在可重复读隔离级别下的话，是对整个库的快照。它是怎么实现的呢？（即 MVCC 是怎么实现 RC、RR 隔离级别的呢？）</p><p>分四部分讲：</p><ul><li>事务 ID</li><li>行记录隐藏列</li><li>undo log</li><li>ReadView</li></ul><hr><h4 id="事务-ID"><a href="#事务-ID" class="headerlink" title="事务 ID"></a>事务 ID</h4><p>innodb 里面每个事务有一个<strong>唯一的事务 ID</strong>，它是事务开始时向 innodb 的事务系统申请的，是按申请顺序严格递增的。</p><h4 id="行记录的隐藏列"><a href="#行记录的隐藏列" class="headerlink" title="行记录的隐藏列"></a>行记录的隐藏列</h4><ul><li>row_id: 隐藏的行 ID ，用来生成默认的聚集索引。如果创建数据表时没指定聚集索引，这时 innodb 就会用这个隐藏 ID 来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率</li><li>trx_id: 即最后一个对数据插入或者更新的事务 ID，每一次<strong>事务</strong>对索引对应的记录进行改动时，都会把该事务的 ID 赋值给 trx_id</li></ul><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p><img src="https://s4.ax1x.com/2021/12/24/TJ7ttH.png" alt="undo log"></p><p>这里 U1、U2、U3 都是 undo log，如果最新版本的记录 V4 要回到 V3 只要通过 U3 就可以了，同理回到 V2 只要通过 U3、U2 就可以了。</p><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>ReadView 中主要包含4个比较重要的内容：</p><ul><li>m_ids：表示在生成 ReadView 时当前系统中活跃（值事务启动了但还没提交）的读写事务的事务 id 列表</li><li>min_trx_id：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的事务 id，也就是 m_ids 中的最小值</li><li>max_trx_id：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值</li><li>creator_trx_id：表示生成该 ReadView 的事务的事务 id</li></ul><p><img src="https://s4.ax1x.com/2021/12/23/T8OSRs.jpg" alt="ReadView"></p><h4 id="ReadView-是如何工作的？"><a href="#ReadView-是如何工作的？" class="headerlink" title="ReadView 是如何工作的？"></a>ReadView 是如何工作的？</h4><p>有了这些信息，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问</li><li>如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问</li><li>如果被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问</li><li>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问</li></ul><p><strong>innodb 利用了 “所有数据都有多个版本” 的特性，实现了 “秒级创建快照” 的能力。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MVCC&quot;&gt;&lt;a href=&quot;#MVCC&quot; class=&quot;headerlink&quot; title=&quot;MVCC&quot;&gt;&lt;/a&gt;MVCC&lt;/h2&gt;&lt;p&gt;MVCC 即&lt;strong&gt;多版本并发控制&lt;/strong&gt;，是在并发事务场景下用于支持 RC、RR 隔离级别的实现&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMake Template</title>
    <link href="https://codroc.github.io/2021/12/14/cmake_templates/"/>
    <id>https://codroc.github.io/2021/12/14/cmake_templates/</id>
    <published>2021-12-14T08:01:19.233Z</published>
    <updated>2021-12-14T08:01:19.233Z</updated>
    
    <content type="html"><![CDATA[<p>常用 <strong>CMake</strong> 模板，边学边更新</p><span id="more"></span><!-- vim-markdown-toc GitLab --><ul><li><a href="#%E7%8E%AF%E5%A2%83">环境</a></li><li><a href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">简单介绍</a></li><li><a href="#%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%8E%E5%A4%B4%E6%96%87%E4%BB%B6%E9%83%BD%E5%9C%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B">源文件与头文件都在根目录下</a><ul><li><a href="#%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F">内置变量</a></li></ul></li><li><a href="#%E6%BA%90%E6%96%87%E4%BB%B6%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E5%88%86%E5%BC%80%E5%AD%98%E6%94%BE">源文件和头文件分开存放</a></li><li><a href="#%E6%89%BE%E8%B7%AF%E5%BE%84">找路径</a></li><li><a href="#%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%BA%93%E6%88%96%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6">生成静态库或共享库文件</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>我个人使用的是 <strong>Ubuntu18.04</strong>，可以通过 <code>sudo apt install cmake</code> 来安装 <strong>CMake</strong>，在终端输入 <code>cmake --version</code> 可查看版本。</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p><strong>CMake</strong> 是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个库。 它用配置文件控制建构过程 <em>（build process）</em> 的方式和 <strong>Unix 的 make</strong> 相似，只是 <strong>CMake</strong> 的配置文件取名为 <strong>CMakeLists.txt</strong>。<strong>CMake</strong> 并不直接建构出最终的软件，而是产生标准的建构档（如 <strong>Unix的Makefile</strong> 或 <strong>Windows Visual C++的projects/workspaces</strong>），然后再依一般的建构方式使用。</p><p>上面这句话摘自 <a href="https://zh.wikipedia.org/wiki/CMake">Wiki</a>，它说的是什么意思？如果你跟我一样在 <strong>linux</strong> 环境下工作，那么你一定听过 <strong>make</strong>，<strong>make</strong> 能够根据 <strong>makefile</strong> 文件中的说明来一步步地自动构建目标文件；<strong>make</strong> 是一种工具（可执行程序），<strong>makefile</strong> 是文件，里面说明了如何去构建目标文件，<strong>make</strong> 程序会从 <strong>makefile</strong> 中一条条地读出相关的指令去执行。那么 <strong>CMake</strong> 和 <strong>makefile</strong> 有什么关系呢？在没有 <strong>CMake</strong> 之前，我们需要自己动手写 <strong>makefile</strong>，然后去运行 <strong>make</strong>，而这需要你去学习 <strong>makefile</strong> 的语法，十分费时费精力；而现在有了 <strong>CMake</strong>，它可以根据你的指示(都写在 <strong>CMakeLists.txt</strong> 中)自动地去生成 <strong>makefile</strong>，然后你再用 <strong>make</strong> 去构建目标文件即可。写 <strong>CMakeLists.txt</strong> 比写 <strong>makefile</strong> 可容易太多了！</p><h1 id="源文件与头文件都在根目录下"><a href="#源文件与头文件都在根目录下" class="headerlink" title="源文件与头文件都在根目录下"></a>源文件与头文件都在根目录下</h1><p>这种是最简单的情况，例如我的目录下有这些文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── hello.c</span><br><span class="line">├── main.c</span><br><span class="line">├── hello.h</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure><p>如果在 g++ 中执行时命令是这样的：<code>g++ hello.c main.c -o main</code><br>那么我可以在当前目录下编写 <strong>CMakeLists.txt</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8)</span><br><span class="line"></span><br><span class="line">project(main VERSION 1.0)</span><br><span class="line"></span><br><span class="line">add_executable(main hello.c main.c)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>cmake_minimum_required(VERSION)</code> 用来表示可接受的 <strong>CMake</strong> 最低版本</li><li><code>project(name)</code> 用来定义项目名称</li><li><code>add_executable(name sources)</code> 第一个参数是项目名称，第二个参数是源文件名(多个文件名之间用空格隔开)</li></ul><p>编写完 <strong>CMakeLists.txt</strong> 文件后，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>可以看到目标文件已经构建完成！现在的目录层级是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── main</span><br><span class="line">│   └── makefile ...</span><br><span class="line">├── hello.c</span><br><span class="line">├── main.c</span><br><span class="line">├── hello.h</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure><p>这里创建 build 目录是为了更好的层次化管理文件，build 目录内放置所有的二进制文件，而源文件和头文件一般都在项目根目录下</p><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><p><strong>CMake</strong> 定义了相当丰富的变量，然而，我常用的也就那几个。</p><table><thead><tr><th align="left">name</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">PROJECT_BINARY_DIR</td><td align="left">是指包含最近的 project() 命令的 build 目录</td></tr><tr><td align="left">PROJECT_SOURCE_DIR</td><td align="left">是指包含最近的 project() 命令的 CMakeLists.txt 的目录</td></tr><tr><td align="left">CMAKE_CURRENT_BINARY_DIR</td><td align="left">当前处理的 CMakeLists.txt 所在的 build 目录</td></tr><tr><td align="left">CMAKE_CURRENT_SOURCE_DIR</td><td align="left">当前处理的 CMakeLists.txt 所在的目录</td></tr><tr><td align="left">CMAKE_SOURCE_DIC</td><td align="left">指定义了顶级 CMakeLists.txt 的目录</td></tr><tr><td align="left">EXECUTABLE_OUTPUT_PATH</td><td align="left">生成的可执行文件的存储目录</td></tr><tr><td align="left">LIBRARY_OUTPUT_PATH</td><td align="left">生成的库的存储目录</td></tr><tr><td align="left">PROJECT_NAME</td><td align="left">项目名称</td></tr><tr><td align="left">PROJECT_VERSION_MAJOR</td><td align="left">项目主版本号（例如 2.8 的主版本号是 2）</td></tr><tr><td align="left">PROJECT_VERSION_MINOR</td><td align="left">项目次版本号 （例如 2.8 的次版本号是 8）</td></tr><tr><td align="left">PROJECT_VERSION_PATCH</td><td align="left">项目版本的补丁号（例如 2.8.1 的补丁号是 1）</td></tr><tr><td align="left">BUILD_SHARED_LIBS</td><td align="left">用于控制 cmake 的 add_library 指令是否默认生成 动态so（yes if flag=on）还是 静态库.a （if flag=off）。默认是 flag=on</td></tr><tr><td align="left">CMAKE_C_FLAGS</td><td align="left">编译器 gcc 的标志</td></tr><tr><td align="left">CMAKE_CXX_FLAGS</td><td align="left">编译器 g++ 的标志</td></tr></tbody></table><p>记不住变量的值时，可以使用 cmake 的 <strong>message 函数</strong>输出变量值。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(show_vars VERSION <span class="number">1.0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了分行确定输出内容</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;1.PROJECT_BINARY_DIR = $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;2.PROJECT_SOURCE _DIR = $&#123;_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;3.CMAKE_CURRRENT_BINARY_DIR = $&#123;CMAKE_CURRRENT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;4.CMAKE_CURRENT_SOURCE_DIR = $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;5.CMAKE_SOURCE_DIR = $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;6.EXECUTABLE_OUTPUT_PATH = $&#123;EXECUTABLE_OUTPUT_PATH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;7.LIBRARY_OUTPUT_PATH = $&#123;LIBRARY_OUTPUT_PATH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;8.PROJECT_NAME = $&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;9.PROJECT_VERSION_MAJOR = $&#123;PROJECT_VERSION_MAJOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;10.PROJECT_VERSION_MINOR = $&#123;PROJECT_VERSION_MINOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;11.PROJECT_VERSION_PATCH = $&#123;PROJECT_VERSION_PATCH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;12.BUILD_SHARED_LIBS = $&#123;BUILD_SHARED_LIBS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;13.CMAKE_C_FLAGS = $&#123;CMAKE_C_FLAGS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;14.CMAKE_CXX_FLAGS = $&#123;CMAKE_CXX_FLAGS&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="源文件和头文件分开存放"><a href="#源文件和头文件分开存放" class="headerlink" title="源文件和头文件分开存放"></a>源文件和头文件分开存放</h1><p>现在有以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── hello.h</span><br><span class="line">└── source</span><br><span class="line">    ├── hello.cc</span><br><span class="line">    └── main.cc</span><br></pre></td></tr></table></figure><p>这种情况下的 CMakeLists.txt 文件应该这样编写：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/source/*.cc</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(main SOURCES)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(main PRIVATE <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p><strong>set(name value)</strong> 可以自己定义一个变量，<em>name</em> 是变量名，<em>value</em> 是变量值</p><p>这里 <em>PROJECT_SOURCE_DIR</em> 的值就是 <em>./</em> (项目根目录)</p><p><strong>target_include_directories(<target> &lt;PRIVATE|INTERFACE|PUBLIC&gt; [item])</target></strong> 是用来标明头文件路径的，相当于编译器选项的 <strong>-I</strong>, 这里 <em>target</em> 就是项目名称，<em>&lt;PRIVATE|INTERFACE|PUBLIC&gt;</em> 三种属性我现在还没搞懂。。。*[item]* 就是头文件路径。</p><p>你可以在 make 时开启输出模式 <code>make VERBOSE=1</code> 来看看编译器的参数，应该是:<br><code>g++ -I 根目录/include 根目录/hello.cc 根目录/main.cc -o 根目录/build/main </code></p><h1 id="找路径"><a href="#找路径" class="headerlink" title="找路径"></a>找路径</h1><p>cmake find_path 命令用来寻找包含指定文件名称的目录。</p><p>通常，它的签名如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_path</span> (</span><br><span class="line">          &lt;VAR&gt;</span><br><span class="line">          name | NAMES name1 [name2 ...]</span><br><span class="line">          [HINTS path1 [path2 ... ENV var]]</span><br><span class="line">          [PATHS path1 [path2 ... ENV var]]</span><br><span class="line">          [PATH_SUFFIXES suffix1 [suffix2 ...]]</span><br><span class="line">          [DOC <span class="string">&quot;cache documentation string&quot;</span>]</span><br><span class="line">          [REQUIRED]</span><br><span class="line">          [NO_DEFAULT_PATH]</span><br><span class="line">          [NO_PACKAGE_ROOT_PATH]</span><br><span class="line">          [NO_CMAKE_PATH]</span><br><span class="line">          [NO_CMAKE_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_SYSTEM_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_CMAKE_SYSTEM_PATH]</span><br><span class="line">          [CMAKE_FIND_ROOT_PATH_BOTH |</span><br><span class="line">           ONLY_CMAKE_FIND_ROOT_PATH |</span><br><span class="line">           NO_CMAKE_FIND_ROOT_PATH]</span><br><span class="line">         )</span><br></pre></td></tr></table></figure><p><code>&lt;VAR&gt;</code> 是一个变量，用于存放该命令得到的结果。它有点像 find 命令，如果在某个目录下找到了指定的文件名，目录名将会存到 <code>&lt;VAR&gt;</code> 变量中，并且 find 搜索将会停止！如果没有找到，结果将会是<code>&lt;VAR&gt;-NOTFOUND</code>。</p><p>举个栗子就懂了，例如 muduo-tutorial 项目 cmake 目录下的 CMakeLists.txt 文件中有这样两行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set(MUDUO_PATH &quot;/opt/muduo_hdrs_libs&quot;)</span></span><br><span class="line"><span class="keyword">find_path</span>(Muduo_INCLUDE_DIR muduo <span class="string">&quot;$&#123;MUDUO_PATH&#125;/include&quot;</span>)</span><br><span class="line"><span class="keyword">find_path</span>(Muduo_LIBRARY_DIR libmuduo_net.a <span class="string">&quot;$&#123;MUDUO_PATH&#125;/lib&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls /opt/muduo_hdrs_libs</span><br><span class="line">inludelib</span><br><span class="line">$ ls /opt/muduo_hdrs_libs/include</span><br><span class="line">muduo</span><br><span class="line">$ ls /opt/muduo_hdrs_libs/lib</span><br><span class="line">libmuduo_base.a  libmuduo_http.a  libmuduo_inspect.a  libmuduo_net.a  libmuduo_pubsub.a</span><br></pre></td></tr></table></figure><p>因此我这里 Muduo_INCLUDE_DIR 就是 <code>/opt/muduo_hdrs_libs/include</code>，Muduo_LIBRARY_DIR 就是 <code>/opt/muduo_hdrs_libs/lib</code>。</p><h1 id="生成静态库或共享库文件"><a href="#生成静态库或共享库文件" class="headerlink" title="生成静态库或共享库文件"></a>生成静态库或共享库文件</h1><p>可以使用 add_library(libname, srcs) 来生产静态库</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.<a href="https://mlog.club/article/1918025">https://mlog.club/article/1918025</a><br>2. <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html#packaging-debug-and-release-step-12">https://cmake.org/cmake/help/latest/guide/tutorial/index.html#packaging-debug-and-release-step-12</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用 &lt;strong&gt;CMake&lt;/strong&gt; 模板，边学边更新&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Config System</title>
    <link href="https://codroc.github.io/2021/12/14/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/"/>
    <id>https://codroc.github.io/2021/12/14/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-12-14T00:47:18.045Z</published>
    <updated>2021-12-14T00:47:18.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><p><strong>配置系统有什么用？</strong></p><p>我的理解是方便程序的运行和发布。把配置变量都抽离出来放在配置文件中，如果要修改配置变量，就直接在配置文件里修改，然后重新运行程序就可以了。如果没有配置系统的情况下要修改配置变量，一般都是直接改程序源代码，然后重新编译连接，毫无疑问这将会是费时费力的（找对应版本的各种库，对应版本的编译器等等，还要等待漫长的编译连接过程。。。），对于那些非开源软件，想改源代码就更不可能了。。。。</p><p>然而配置系统的存在能够很好地解决这些问题。</p><h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><p>选择一种用于配置文件的语言，我选的是 YAML。它是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。</p><p>YAML 实质上是一种通用的数据串行化格式。它的基本语法规则如下：</p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用 Tab 键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li></ul><p><code>#</code>  表示注释，从这个字符一直到行尾，都会被解析器忽略。</p><p>YAML 支持的数据结构有三种：</p><ul><li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li><li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li><li>纯量（scalars）：单个的、不可再分的值</li></ul><p>YAML 下载与安装：</p><p><code>yaml-cpp: github repo</code></p><p><code>mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make install</code></p><h3 id="基于-YAML-实现-配置系统"><a href="#基于-YAML-实现-配置系统" class="headerlink" title="基于 YAML 实现 配置系统"></a>基于 YAML 实现 配置系统</h3><p>配置系统的原则：</p><ul><li><strong>约定优于配置：</strong>约定即源代码中写死的值，而配置是指在配置文件 (.yaml) 中指定的值。</li><li><strong>不能无中生有：</strong>在源文件中未定义的配置变量，即使在配置文件 (.yaml) 中定义了也不会生效。</li></ul><p>总体的结构是这样的：</p><p>​    由于配置变量一般都由：变量名，变量值，变量描述构成。因此可以抽一个基类出来存放这些共通的属性，必然的，有时候会需要把配置变量输出到控制台给用户看，或根据字符串来重置变量值，因此还需要一个 fromString 和 toString 方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVarBase</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ConfigVarBase&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span>; <span class="comment">// 根据 str 来设置 配置变量值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>;  <span class="comment">// 把配置变量值转成字符串，便于输出</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _description;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    其中变量名和变量描述由于类型固定，可以放在基类中，而变量值则不固定了，它可以是任意类型，因此就可以根据基类派生出一个模板子类来表示具体的配置变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> :</span> <span class="keyword">public</span> ConfigVarBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    现在有配置变量了，缺一个管理这些配置变量的类，我使用 std::map 来进行管理，通过 name-&gt;ConfigVarBase::ptr 的映射来实现管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, ConfigVarBase::ptr&gt; _configVars;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一来 <strong>约定的变量</strong> 就实现了！</p><p>接下来就是怎么实现，从配置文件 (.yaml) 中读取配置变量。yaml-cpp 库提供了 LoadFile 函数，能从 .yaml 文件中读取 YAML::Node。</p><p>由于 .yaml 中的格式和我源代码中变量名字的格式是不一样的：</p><p>yaml 中是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A:</span></span><br><span class="line"><span class="attr">B:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">C:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>源文件中的变量名则为：A.B = 10，A.C = 20</p><p>因此这里需要一个从 YAML 名称格式到 源代码中的变量名称格式的转换。可以借助 yaml-cpp 中的 <code>IsNull, IsScalar, IsSequence, Ismap</code> 对 node 进行递归遍历，然后将变量名进行转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listAllNodes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> YAML::Node&amp; node,  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, YAML::Node&gt;&gt;&amp; allNodes)</span> </span>&#123;</span><br><span class="line">    allNodes.push_back(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(name, node));</span><br><span class="line">    <span class="keyword">if</span> (node.IsNull()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsScalar()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsSequence()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsMap()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = node.begin(); it != node.end(); ++it) &#123;</span><br><span class="line">            listAllNodes(name.empty() ? it-&gt;first.as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;() :</span><br><span class="line">                    name + <span class="string">&quot;.&quot;</span> + it-&gt;first.Scalar(), it-&gt;second, allNodes); <span class="comment">// 这里是名字转换的关键所在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config::loadFromYaml</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    YAML::Node node = YAML::LoadFile(filename);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, YAML::Node&gt;&gt; allNodes;</span><br><span class="line">    listAllNodes(<span class="string">&quot;&quot;</span>, node, allNodes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : allNodes) &#123; <span class="comment">// 对所有的 name、node 进行遍历</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name = i.first;</span><br><span class="line">        <span class="keyword">if</span> (name.empty())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ConfigVarBase::ptr p = Config::find(name);</span><br><span class="line">        <span class="keyword">if</span> (p) &#123; <span class="comment">// 这里保证了不会无中生有的原则</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">            ss &lt;&lt; i.second;</span><br><span class="line">            p-&gt;fromString(ss.str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里使用了 stringstream 把 YAML::Node 字符串化。然后调用 fromString 来对配置变量进行设置。</p><h3 id="fromStr-和-toStr-的实现"><a href="#fromStr-和-toStr-的实现" class="headerlink" title="fromStr 和 toStr 的实现"></a>fromStr 和 toStr 的实现</h3><p>对于普通的内置类型可以用 boost::lexical_cast 来实现，而对于复杂的数据类型，例如：vector,list,set,map,unordered_set,unordered_map, 自定义类型 等，就要自己去实现了。</p><p><strong>STL 类型的支持：</strong></p><p>可以实现一个 LexicalCast 模板类，然后根据具体的 STL 容器对 LexicalCast 进行偏特化就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于普通内置类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> F&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boost::lexical_cast&lt;T&gt;(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cast from std::string to std::vector&lt;T&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        ...<span class="comment">// 利用 yaml-cpp 的 Load 得到 node 然后遍历 node，利用 stringstream 格式化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// cast from std::vector&lt;T&gt; to std::string</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">FromStr</span> =</span> LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, T&gt;, </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToStr</span> =</span> LexicalCast&lt;T, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> :</span> <span class="keyword">public</span> ConfigVarBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _val = FromStr()(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ToStr()(_val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>自定义类型的支持：</strong></p><p>自定义类型，需要实现 LexicalCast 偏特化，实现后，就可以支持 Config 解析自定义类型，自定义类型可以和常规 STL 容器一起使用。</p><p>例如，增加 Person 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">bool</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from std::string to Person</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, Person&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Person <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        YAML::Node node = YAML::Load(str);</span><br><span class="line">        Person p;</span><br><span class="line">        p.name = node[<span class="string">&quot;name&quot;</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        p.age = node[<span class="string">&quot;age&quot;</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        p.sex = node[<span class="string">&quot;sex&quot;</span>].as&lt;<span class="keyword">bool</span>&gt;();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from Person to std::string</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span>Person, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span> </span>&#123;</span><br><span class="line">        YAML::Node node;</span><br><span class="line">        node[<span class="string">&quot;name&quot;</span>] = p.name;</span><br><span class="line">        node[<span class="string">&quot;age&quot;</span>] = p.age;</span><br><span class="line">        node[<span class="string">&quot;sex&quot;</span>] = p.sex;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="配置的事件机制"><a href="#配置的事件机制" class="headerlink" title="配置的事件机制"></a>配置的事件机制</h3><p>当一个配置项发生修改的时候，可以反向通知对应的代码。</p><p>这个其实挺容易实现的，在 ConfigVar 模板类中添加一个 OnChangeCallBack _cb 回调，它是 </p><p>std::function&lt;const T&amp; oldVal, const T&amp; newVal&gt; 类型的，每当要改变 ConfigVar::_val 时，先判断一下，新的值是否与旧值不同，如果是的化则回调 _cb</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> &#123;</span></span><br><span class="line">... </span><br><span class="line"><span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == _val)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (_cb)</span><br><span class="line">            _cb(_val, v);</span><br><span class="line">        _val = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnChangeCallBack</span><span class="params">(OnChangeCallBack cb)</span> </span>&#123; _cb = cb; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delOnChangeCallBack</span><span class="params">()</span> </span>&#123; _cb = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">    OnChangeCallBack _cb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样配置系统基本就完成了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;配置系统&quot;&gt;&lt;a href=&quot;#配置系统&quot; class=&quot;headerlink&quot; title=&quot;配置系统&quot;&gt;&lt;/a&gt;配置系统&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;配置系统有什么用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的理解是方便程序的运行和发布。把配置变量都抽离出来放在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP keep-alive</title>
    <link href="https://codroc.github.io/2021/11/26/tcp_keep-alive/"/>
    <id>https://codroc.github.io/2021/11/26/tcp_keep-alive/</id>
    <published>2021-11-25T16:00:00.000Z</published>
    <updated>2021-11-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-保活机制"><a href="#TCP-保活机制" class="headerlink" title="TCP 保活机制"></a>TCP 保活机制</h2><h4 id="为什么需要-TCP-保活机制"><a href="#为什么需要-TCP-保活机制" class="headerlink" title="为什么需要 TCP 保活机制"></a>为什么需要 TCP 保活机制</h4><p>设想这种情况，TCP连接建立后，在一段时间范围内双发没有互相发送任何数据。思考以下两个问题：</p><ol><li>怎么判断对方是否还在线。这是因为，TCP对于非正常断开的连接系统并不能侦测到（比如网线断掉）。</li><li>长时间没有任何数据发送，连接可能会被中断。这是因为，网络连接中间可能会经过路由器、防火墙等设备，而这些有可能会对长时间没有活动的连接断掉。</li></ol><p>基于上面两点考虑，需要保活机制。</p><p><font color="green">其实 有一部分人认为，keep-alive 的检测应该放在 应用层 而不是 传输层。</font></p><h4 id="TCP保活机制的实现-Linux"><a href="#TCP保活机制的实现-Linux" class="headerlink" title="TCP保活机制的实现 (Linux)"></a>TCP保活机制的实现 (Linux)</h4><p><strong>系统级别：</strong></p><p>具体实现上有以下几个相关的配置：</p><ul><li>保活时间：默认7200秒（2小时）</li><li>保活时间间隔：默认75秒</li><li>保活探测数：默认9次                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </li></ul><p>可以通过 <code>/proc/sys/net/ipv4/</code> 接口查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/net/ipv4/tcp_keepalive_time</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/net/ipv4/tcp_keepalive_probes</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span></span><br></pre></td></tr></table></figure><p>或 通过 sysctl 查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysctl -A | grep keepalive</span></span><br></pre></td></tr></table></figure><h4 id="TCP-保活机制试验："><a href="#TCP-保活机制试验：" class="headerlink" title="TCP 保活机制试验："></a>TCP 保活机制试验：</h4><p>首先将 <strong>tcp_keepalive_time</strong> 设置为 20，即 20s 内 连接上没有数据收发就启动 间隔定时器；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 20 | sudo tee /proc/sys/net/ipv4/tcp_keepalive_time</span></span><br></pre></td></tr></table></figure><p>将 <strong>tcp_keepalive_intvl</strong> 设置为 5，即如果连接不活跃(开启定时器后，发送一个探测报文，但是没收到响应)，则每 5s 发送一个探测报文；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 5 | sudo tee /proc/sys/net/ipv4/tcp_keepalive_intvl</span></span><br></pre></td></tr></table></figure><p>将 <strong>tcp_keepalive_probes</strong> 设置为 2。即如果 发出探测报文后 对端没有回应则重复发送探测报文的次数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 2 | sudo tee /proc/sys/net/ipv4/tcp_keepalive_probes</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：修改 /proc 接口中的内容，不能用 vi/vim 编辑器，因为 vi/vim 的做法是先根据源文件创建一个 .swap 临时文件，而 /proc 中的内容都是 内存中的映像，根本不存在于 磁盘中，如果用 vi/vim 去修改必定得到 E667: Fsync failed 错误。</p></blockquote><p>在两台云服务器上进行实验，监听的一端设置 tcp keep-alive</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip: 124.70.82.205</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nohup sudo nc -l -p443 -k &amp; <span class="comment"># -k 表示开启 tcp keep-alive 机制</span></span></span><br></pre></td></tr></table></figure><p>在另一台服务器上对 124.70.82.205 443 发起连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip: 112.124.36.253</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc 124.70.82.205 443</span></span><br></pre></td></tr></table></figure><p>在 ip: 124.70.82.205 上对 端口 443 进行抓包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tcpdump -i eth0 port 443</span></span><br><span class="line">10:45:09.891760 IP 124.70.82.205.https &gt; 112.124.36.253.44338: Flags [.], ack 2867648125, win 510, options [nop,nop,TS val 956683255 ecr 4136667676], length 0</span><br><span class="line">10:45:09.920708 IP 112.124.36.253.44338 &gt; 124.70.82.205.https: Flags [.], ack 1, win 229, options [nop,nop,TS val 4136687900 ecr 956519734], length 0</span><br><span class="line"></span><br><span class="line">10:45:30.115763 IP 124.70.82.205.https &gt; 112.124.36.253.44338: Flags [.], ack 1, win 510, options [nop,nop,TS val 956703479 ecr 4136687900], length 0</span><br><span class="line">10:45:30.144706 IP 112.124.36.253.44338 &gt; 124.70.82.205.https: Flags [.], ack 1, win 229, options [nop,nop,TS val 4136708124 ecr 956519734], length 0</span><br><span class="line"></span><br><span class="line">10:45:50.339764 IP 124.70.82.205.https &gt; 112.124.36.253.44338: Flags [.], ack 1, win 510, options [nop,nop,TS val 956723703 ecr 4136708124], length 0</span><br><span class="line">10:45:50.368749 IP 112.124.36.253.44338 &gt; 124.70.82.205.https: Flags [.], ack 1, win 229, options [nop,nop,TS val 4136728348 ecr 956519734], length 0</span><br></pre></td></tr></table></figure><p>可以看到 由于连接不活跃，每隔 一个 <strong>tcp_keepalive_time</strong> 都会向对端 发送一个 keep-alive 报文，来探测对端是否还“活着”。</p><p><strong>上述实验的过程描述：</strong></p><p>连接中启动保活功能的一端，在保活时间内连接处于非活动状态，则向对方发送一个保活探测报文，如果收到响应，则重置保活计时器，如果没有收到响应报文，则经过一个保活时间间隔后再次向对方发送一个保活探测报文，如果还没有收到响应报文，则继续，直到发送次数到达保活探测数，此时，对方主机将被确认为不可到达，连接被中断。</p><p>TCP保活功能工作过程中，开启该功能的一端会发现对方处于以下四种状态之一：</p><ol><li>对方主机仍在工作，并且可以到达。此时请求端将保活计时器重置。如果在计时器超时之前应用程序通过该连接传输数据，计时器再次被设定为保活时间值。</li><li>对方主机已经崩溃，包括已经关闭或者正在重新启动。这时对方的TCP将不会响应。请求端不会接收到响应报文，并在经过保活时间间隔指定的时间后超时。超时前，请求端会持续发送探测报文，一共发送保活探测数指定次数的探测报文，如果请求端没有收到任何探测报文的响应，那么它将认为对方主机已经关闭，连接也将被断开。</li><li>客户主机崩溃并且已重启。在这种情况下，请求端会收到一个对其保活探测报文的响应，但这个响应是一个重置报文段 <code>RST</code>，请求端将会断开连接。</li><li>对方主机仍在工作，但是由于某些原因不能到达请求端（例如网络无法传输，而且可能使用ICMP通知也可能不通知对方这一事实）。这种情况与状态2相同，因为TCP不能区分状态2与状态4，结果是都没有收到探测报文的响应。</li></ol><blockquote><p>tcp 保活机制的弊端：保活机制会占用不必要的带宽</p></blockquote><p><strong>保活机制是存在争议的，主要争议之处在于是否应在TCP协议层实现，有两种主要观点：其一，保活机制不必在TCP协议中提供，而应该有应用层实现；其二，认为大多数应用都需要保活机制，应该在TCP协议层实现。</strong></p><p><font color="red">这里修改的 /proc 中的变量会导致 全局（整个系统）的 tcp keep-alive 机制发送变化，那么能不能只针对一个 socket 进行 keep-alive 机制的制定呢？</font></p><h4 id="针对单个-socket-的保活机制"><a href="#针对单个-socket-的保活机制" class="headerlink" title="针对单个 socket 的保活机制"></a>针对单个 socket 的保活机制</h4><p>下面介绍针对单个 socket 连接 细粒度设置 的三个选项参数：</p><p><strong>保活时间：TCP_KEEPIDLE、保活探测时间间隔：TCP_KEEPINTVL、探测循环次数：TCP_KEEPCNT</strong>（可通过 man 7 tcp 中 Socket options 这一节查看细节）</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTEN_PORT 33333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUF 65536</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">echo_data</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">events_handle</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用TCP保活机制的相关代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_keepalive</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> keepalive_time, <span class="keyword">int</span> keepalive_intvl, <span class="keyword">int</span> keepalive_probes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> optval;</span><br><span class="line">    <span class="keyword">socklen_t</span> optlen = <span class="keyword">sizeof</span>(optval);</span><br><span class="line">    optval = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optval = keepalive_probes;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_TCP, TCP_KEEPCNT, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optval = keepalive_intvl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_TCP, TCP_KEEPINTVL, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optval = keepalive_time;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_TCP, TCP_KEEPIDLE, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> _argc, <span class="keyword">char</span>* _argv[])</span> </span>&#123;</span><br><span class="line">    run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == epfd) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create1 failure.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="keyword">int</span> listen_sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bzero(&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    seraddr.sin_port = htons(LISTEN_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bind(listen_sock, (struct sockaddr*)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr))) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind server addr failure.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(listen_sock, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = listen_sock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == epoll_ctl(epfd, EPOLL_CTL_ADD, listen_sock, &amp;ev)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl add listen_sock failure.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nfds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == nfds) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait failure.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> n = <span class="number">0</span>; n &lt; nfds; ++n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[n].data.fd == listen_sock) &#123;</span><br><span class="line">                <span class="keyword">int</span> conn_sock = accept(listen_sock, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == conn_sock) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept failure.&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accept from %s:%d\n&quot;</span>, inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)), ntohs(cliaddr.sin_port));</span><br><span class="line">                set_keepalive(conn_sock, <span class="number">120</span>, <span class="number">20</span>, <span class="number">3</span>);</span><br><span class="line">                setnonblocking(conn_sock);</span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = conn_sock;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == epoll_ctl(epfd, EPOLL_CTL_ADD, conn_sock, &amp;ev)) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl add conn_sock failure.&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                events_handle(epfd, events[n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(listen_sock);</span><br><span class="line">    close(epfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 33333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 65535</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client_handle</span><span class="params">(<span class="keyword">int</span> sock)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input args %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> server_port = SERVER_PORT;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> == argc) &#123;</span><br><span class="line">        server_port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bzero(&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr);</span><br><span class="line">    seraddr.sin_port = htons(server_port);</span><br><span class="line"></span><br><span class="line">    connect(sock, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    client_handle(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/s_lisheng/article/details/87288445">【TCP/IP详解】TCP保活机制</a></li><li><a href="https://zhuanlan.zhihu.com/p/224595048">HTTP keep-alive和TCP keepalive的区别，你了解吗？</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP-保活机制&quot;&gt;&lt;a href=&quot;#TCP-保活机制&quot; class=&quot;headerlink&quot; title=&quot;TCP 保活机制&quot;&gt;&lt;/a&gt;TCP 保活机制&lt;/h2&gt;&lt;h4 id=&quot;为什么需要-TCP-保活机制&quot;&gt;&lt;a href=&quot;#为什么需要-TCP-保活机制&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>只用 EventLoop Poller Channel 实现 Reactor 模式</title>
    <link href="https://codroc.github.io/2021/11/25/reactor_pattern/"/>
    <id>https://codroc.github.io/2021/11/25/reactor_pattern/</id>
    <published>2021-11-24T16:00:00.000Z</published>
    <updated>2021-11-25T01:27:26.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用-C-实现一个简单的-Reactor-模式"><a href="#用-C-实现一个简单的-Reactor-模式" class="headerlink" title="用 C++ 实现一个简单的 Reactor 模式"></a>用 C++ 实现一个简单的 Reactor 模式</h3><p>何谓 Reactor 模式？（请看 Schmidt, D.C. (1995). Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events）</p><p>Reactor 模式的目的：<strong>处理多个客户端的并发服务请求</strong> （以下是论文 Reactor 的原话）</p><blockquote><p>The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. —— Reactor</p></blockquote><p>Reactor 模式的主要结构：</p><ul><li>Handles：标识由 OS 管理的一系列资源。这些资源通常包括：网络连接，打开文件，定时器，同步对象等等。Handle 可以看成是对这些资源的句柄，例如 fd (file description), timerfd。</li><li>Synchronous Event Demultiplexer：这在 Linux 中其实就是 select、poll、epoll。它利用 IO multiplexing 机制，通知用户哪些 Handles 已经 IO ready （即 调用 IO 函数不会导致 阻塞）。在我的实现中，epoll 接口被封装到了 Poller 类中。 </li><li>Initiation Dispatcher：用于注册、移除以及分发事件处理器 (Event Handler) 的接口。在我的实现中就是 Channel 类，它实现了事件分发机制。</li><li>Event Handler：这是一个接口，它实现了根据指定的 IO Event 来进行指定的操作。</li><li>Concrete Event Handler：这是 <strong>事件处理器</strong> 的具体实现。</li></ul><p><img src="https://z3.ax1x.com/2021/11/24/oijO1J.png" alt="reactor 模式"></p><p>让我来解释一下整个流程：</p><ol><li>Concrete Event Handler 不断地监视是否有 IO event 发生</li><li>有 IO event 发生，Concrete Event Handler 立即通知 Handle，并让 Dispatcher 把 IO event 分发给对应的 event handler</li><li>event handler 处理 event</li><li>在处理 event 的过程中，可能又会注册需要 monitor 的 IO event 到 Concrete Event Handler 中去，并把对应的 event handler 注册到 Disapatcher 中去</li><li>回到步骤 1</li></ol><p>​    上述整个流程其实是管理所有文件描述符的所有事件（包括<em>可读</em>，<em>可写</em>，等等），并在适当时机执行指定的回调函数（event handler）。所以，这实际上是一个<strong>事件循环 （event loop）</strong>。因此我用 EventLoop 类来描述这一整个流程。</p><hr><p>一个简单的 Reactor 就仅仅需要以下三个类：</p><ul><li>EventLoop: 实现事件循环</li><li>Channel: 实现事件分发机制</li><li>Poller: 实现监视 IO event 并通知</li></ul><h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p>其核心是实现一个 <strong>事件循环</strong> <strong>loop</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Handle&gt; activeHandles;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        activeHandles.clear();</span><br><span class="line">    <span class="comment">// 执行流程 1：一旦有 IO 事件发生就让 Poller 通知我</span></span><br><span class="line">        <span class="comment">// 并且把 对应 IO 的 Handle 告诉我 </span></span><br><span class="line">        Poller.poll(activeHandles);</span><br><span class="line">        <span class="comment">// 执行流程 2, 3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> handle : activeHandles)</span><br><span class="line">            Dispatcher.handleEvent(handle); <span class="comment">// 在具体 event handler 执行的过程中回去执行流程 4, 5</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里仅仅是伪代码，还有很多细节是需要补全的，例如 Dispatcher 会根据 handle 以及发生的 IO event 去挑选具体的 handler，这些细节可以全部封装到 Channel 中！所有实际的实现就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Channels*&gt; activeChannels;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        activeChannels.clear();</span><br><span class="line">    <span class="comment">// 执行流程 1：一旦有 IO 事件发生就让 Poller 通知我</span></span><br><span class="line">        <span class="comment">// 并且把 对应 IO 的 Handle 告诉我 </span></span><br><span class="line">        Poller.poll(activeChannels);</span><br><span class="line">        <span class="comment">// 执行流程 2, 3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> channel : activeChannels)</span><br><span class="line">            channel-&gt;handleEvent(); <span class="comment">// 在具体 event handler 执行的过程中回去执行流程 4, 5</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h4><p>它就是对 整个 Epoll 机制的封装，即 epoll_create、epoll_wait、epoll_ctl</p><p>它无非就是通过 epoll_create 创建一个 epoll instance，然后 通过 epoll_ctl 注册用户需要让 OS monitor 的 IO event。所以代码整体骨架如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Poller::Poller()</span><br><span class="line">    : _epfd(epoll_create(<span class="number">1</span>))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Poller::~Poller() &#123;</span><br><span class="line">    ::close(_epfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Poller::poll</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;channel*&gt; activeChannel, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_events</span> <span class="title">events</span>[<span class="title">kMaxEvents</span>];</span></span><br><span class="line">    <span class="keyword">int</span> n = epoll_wait(_epfd, events, kMaxEvents, timeout); <span class="comment">// 等待 IO event 发生</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">        Channel* pChannel = <span class="keyword">reinterpret_cast</span>&lt;Channel*&gt;(events[i].data.ptr);</span><br><span class="line">        pChannel-&gt;setOccurEvents(events[i].events); <span class="comment">// 把 epoll 监测到的 IO 事件（可读、可写）记录到对应 Handle 的 channel 中去</span></span><br><span class="line">        activeChannel.push_back(pChannel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poller::update</span><span class="params">(Channel* pChannel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该函数用于注册 IO event 到 epoll instance 中去</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_events</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = pChannel.getWaitEvents(); <span class="comment">// 获取用户想要 OS monitor 的 IO event</span></span><br><span class="line">    ev.data.ptr = pChannel;</span><br><span class="line">    epoll_ctl(); <span class="comment">// 根据具体情况选择 EPOLL_CTL_ADD、EPOLL_CTL_MOD 或 EPOLL_CTL_DEL</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>​    这个类实现了 <strong>IO 事件分发</strong> 机制，也是 Reactor 模式中重要的一环。它记录了用户想要 epoll instance 帮忙 monitor 的 fd 的具体 IO event（例如可读事件），也记录了当 IO event 发生时应该进行的操作（即 event handler）。有时候我们要让 epoll instance 监视多种 IO event，例如 可读、可写，因此一旦 IO 可读，epoll instance 就会通知我们，我们此时需要记录下 具体是哪种 IO event 导致的通知以便做出正确的响应操作，因此也需要记录 已发生的 IO event</p><p>​    当前我的设计是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> EventCallBack = <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个 Channel 独属于 一个 EventLoop</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Channel</span><span class="params">(EventLoop*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 io multi-plexing 检测到的已发生的事件 记录在 _occurEvents 中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOccurEvents</span><span class="params">(<span class="keyword">uint32_t</span> occurEvents)</span> </span>&#123; _occurEvents = occurEvents; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">getWaitEvents</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _waitEvents; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置事件回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setReadEventCallBack</span><span class="params">(EventCallBack cb)</span> </span>&#123; _readEventCallBack = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWriteEventCallBack</span><span class="params">(EventCallBack cb)</span> </span>&#123; _writeEventCallBack = <span class="built_in">std</span>::move(cb);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把事件分发给具体的事件处理函数，它就是一个 Event Handler</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 epoll instance 关注 指定 事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">monitorReading</span><span class="params">()</span> </span>&#123; _waitEvents |= kReadEvent; update(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">monitorWriting</span><span class="params">()</span> </span>&#123; _waitEvents |= kWriteEvent; update(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kNoneEvent; <span class="comment">// 无任何 IO event</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kReadEvent; <span class="comment">// 可读 事件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kWriteEvent;<span class="comment">// 可写 事件</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将事件注册到 epoll instance 中去</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *_pLoop;</span><br><span class="line">    <span class="keyword">int</span> _fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> _waitEvents; <span class="comment">// 等待发生的事件</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _occurEvents; <span class="comment">// 已发生的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Concrete Event Handler</span></span><br><span class="line">    EventCallBack _readEventCallBack;</span><br><span class="line">    EventCallBack _writeEventCallBack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就是一个简单易用的 Reactor 模式的 C++ 实现。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>Schmidt, D.C. (1995). Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events</li><li><a href="https://www.cnblogs.com/coding-diary/archive/2019/09/08/11484473.html">Reactor 模式</a></li><li><a href="https://www.jianshu.com/p/01f3fb1d4cb5">使用C++实现简单的Reactor模式</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;用-C-实现一个简单的-Reactor-模式&quot;&gt;&lt;a href=&quot;#用-C-实现一个简单的-Reactor-模式&quot; class=&quot;headerlink&quot; title=&quot;用 C++ 实现一个简单的 Reactor 模式&quot;&gt;&lt;/a&gt;用 C++ 实现一个简单的 Reac</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>异步日志系统设计</title>
    <link href="https://codroc.github.io/2021/11/17/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://codroc.github.io/2021/11/17/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-16T16:00:00.000Z</published>
    <updated>2021-11-23T11:18:40.514Z</updated>
    
    <content type="html"><![CDATA[<p><strong>日志系统设计：</strong></p><p>为什么要自己写一个日志系统？</p><p>因为，网上的日志系统功能十分丰富，而有许多功能在我的项目或未来的项目中是不必要的。尤其是我试用过 spdlog 之后，更加确定了要自己写一个简单的日志系统，spdlog 的确，使用起来十分方便，只要包含头文件的就能用了，但是由于它的引入，编译时间却大大增加了，这大大降低了我的开发效率。。。</p><p>需要实现哪些功能？</p><ol><li>支持日志级别输出：TRACE, INFO, DEBUG, WARN，ERROR，FATAL</li><li>支持控制台和文件做为输出目标</li><li>支持日志滚动（rolling）</li><li>支持多线程</li><li>高性能（由于设计简单，那么就要把性能做到极致），现在好点的固态硬盘读写一般都在 500 MB/s 上下，<strong>最好</strong>日志系统的性能能够到达瞬时写满这个带宽，现在一般日志系统的瓶颈都不在磁盘这了~~。假设一条日志占 100 字节，那么至少要达到每秒写 200 万 条数据的能力（或每条日志 500 ns）。</li><li>用户友好</li></ol><hr><p><strong>如何设计 Roll File 机制？</strong></p><p>其实本质就是当 日志文件 大小 超过设定阈值时，换一个文件写入。说来简单，但是需要考虑，是否需要对原来的日志文件压缩打包，并重命名呢？对于压缩打包和重命名，可以另写一个脚本，在每次 Roll File 时，通过 c++ 去执行这个脚本。</p><p>经过测试后，<strong>结果不尽人意！</strong></p><p>我的实现是：日志后端线程 在 做落盘动作 之前，检查 文件大小 是否即将超过阈值，如果是，则要去 roll file。而 roll file 是通过 日志后端线程 fork 一个子进程来执行 一个 python 脚本 去做 一系列（解压缩日志包，对旧的日志文件重命名，再重新打包压缩）操作。这会导致 后端线程 阻塞等待 脚本完成所有操作。在这段等待的时间内，如果 前端日志量很大，就会导致 后端 Buffer 不够用，那么就会产生大量的 内存分配（分配新的 Buffer） 操作。<strong>最终的结果就是：日志系统在 开启 多个线程时，性能颠簸（thrashing）很大。（见性能分析）</strong></p><p>除此之外，我通过 <code>strace -c loggerTest</code> 发现竟然 futex 占用了 90%+ 的时间。。。这也不知道是为啥？难道就是单纯的 lock contention 导致的？</p><hr><p><strong>如何达到高性能？需要考虑以下几点：</strong></p><ul><li>使用 <strong>直写</strong> 还是 <strong>写回</strong> ？这是在 日志 落盘时 需要考虑的问题。</li><li>日志格式是否可以在 RUN-TIME 修改？</li><li>是否必须实现 异步日志？</li><li>如何查看 日志系统 瓶颈所在？</li></ul><ol><li><p>对于落盘方式是使用 <strong>直写</strong> 还是 <strong>写回</strong> 是很明显的，直写会大量涉及 磁盘IO，严重降低性能，所以采用写回策略。</p><p>写回策略：</p></li></ol><p>​    为了追求高性能，那就不能每写一条日志就落盘，众所周知 磁盘 IO 的速度是很慢的；也不能为了追求性能而迟迟不将日志落盘，这样一旦 日志系统 crash 就会丢失所有日志。</p><p>​    参考 Redis 中三种写回策略：<strong>Always, Everysec 以及 No（由 OS 决定何时写回）</strong>。为了兼顾性能和减少日志数据丢失问题，可以设计成<strong>每隔 3 s 写回一次</strong>。</p><ol start="2"><li><p>关于日志格式的问题，在其他的 日志库 实现中，一般都是可以在 RUN-TIME 修改 日志格式 的，但是我认为在我 目前使用日志的环境中，无需做这个功能，用统一的格式已经很简洁明了了。如果未来想要换个格式，重写下 日志制作 的相关模块就行了。</p><p>日志格式不变，那么制作日志时，也就具有较好的局部性了，自然不会出现在切换日志格式时的性能 <strong>颠簸</strong> （thrashing）。</p></li><li><p>为了不让 worker 线程阻塞在 磁盘 IO 上，就应该设计成 异步日志，worker 只需要异步调用一个 flush 函数，就会有另一个 专门用于 日志落盘的 线程 来接收 worker 产生的日志，并在合适时机 落盘。</p></li><li><p>异步日志系统的瓶颈，目前只知道用 strace 去查看用了哪些耗时的系统调用。。。。</p></li></ol><hr><p><strong>如何实现对用户友好？</strong></p><ul><li>输出格式友好</li><li>文件命名友好</li><li>接口友好</li></ul><p><strong>输出格式：</strong> 参考 muduo 的日志输出格式，统一为 <code>日期 时间 线程id 日志级别 源文件名:行号 - 正文</code>，例如</p><p><em>20210603 08:02:46.125770Z 23261 INFO Hello - test.cpp:51</em></p><p><em>20210603 08:02:46.126789Z 23261 WARN World - test.cpp:52</em></p><p><strong>文件命名：</strong> 参照 muduo 的格式，统一为 <code>程序名.日期.进程id.log</code></p><p><strong>接口友好：</strong> 按照流的方式进行输出，例如 <code>LOG_INFO &lt;&lt; &quot;TEST\n&quot;</code></p><hr><p><strong>具体实现：</strong></p><p>日志系统分成前后端，前端制作日志并发送给后端，后端把日志写到目的地（可以是控制台或文件）。</p><p><em>前端设计</em></p><p>​    前端制作完一条日志后是否立即发送给后端？最好不要，由于设计成异步发送，因此每一次发送都会 wakeup 一次后端线程，wakeup 频率太高也会降低系统性能。可以按批次 batch 发，给前端设置一个 Buffer 用于缓存已经制作完成的日志，当缓存满的时候再发送给后端。当然你说在后端也存在个 Buffer 就不需要每次 wakeup 后端线程了，但是多个前端线程频繁争用一个 <strong>后端 Buffer</strong> 也会导致性能下降，因此在前端用缓存在理论上是能减少竞争从而提高性能的。</p><p>​    系统向用户展示的接口是使用 <strong>流</strong> 的方式写日志的，每个 <strong>流</strong> 底层实现其实就是 <strong>Buffer</strong>。由于系统支持多线程，假设前端只有一个 Buffer 用于制作日志，那就会导致多个线程争夺一个 Buffer，这里存在 lock contention，考虑到 日志 产生的频率是比较高的，因此 contention 比较大。</p><p>​    可以设计成，每一个前端线程拥有一个独自的 <strong>流</strong>，这就避免了缓冲时的 race condition。<strong>当然这样设计的性能具体如何还需要验证！</strong>因为磁盘只有一个，最终的落盘操作总是串行执行的！（经过测试发现，性能与线程 能够接近于 1:1 线性相关）</p><p>​    相比较于 muduo，**本日志系统的改进 **是使用全局 logger 避免每制作一条日志都需要 产生 logger 临时对象，进而带来构造析构的开销，除此之外，muduo 是每产生一条日志都会被 push 到日志后端 Buffer 中，这会导致前端线程频繁争用 <strong>后端 Buffer</strong> 带来大量的 lock contention。至于全局的 logger 如何析构，可以添加一个 static 函数 release 来释放 logger 资源，让 LoggerWatcher 负责调用 Logger::release，这样在 release 中还能刷新以下缓冲，不至于 丢失日志。</p><blockquote><p>注意：日志后端一定要先于日志前端 构造，这样日志系统退出时，前端先退出，就会把前端 Buffer 中的日志刷新到 后端 Buffer 然后 append 到目的地。反之将会丢失前端的日志数据！</p></blockquote><p><em>后端设计</em></p><p>​    这里的关键就在于，<strong>如何做好日志系统的前后端交互。</strong> </p><p>​    如何把日志前端缓冲的数据传递给日志后端？阻塞队列可以做到，如果实现成，多个前端线程写日志，只有一个阻塞队列，那么就会产生明显的 lock contention 问题，该问题会随着每秒日志量的增大而变得明显起来；当然如果日志量小，自动触发 3 s 一刷新机制，那么 lock contention 占用的时间与 3 s 对比起来可能会不明显。也可以使用共享 Buffer，前端把日志全部往一个缓冲区写，后端读这个缓冲区，一样，lock contention 依然存在。。。。（经过测试，strace 显示的确会产生大量的 futex 调用）</p><p>​    目前设计为，通过前后端 共享一个 Buffer 的方式来实现交互。也就是说，前端产生的日志会 刷新到 后端 Buffer 中，而后端 也会在 合适的时机 将 Buffer 中的内容 落盘，这就需要加锁了！所以必然产生 critical section，而重点便是 让 critical section 执行时间越少越好。因此一些 内存分配或回收 必然不能在这里做了！具体的实现是，提前分配好 Buffer 以及备用的 Buffer，在 critical section 通过 swap 来交换已经占满的 Buffer 与 备用 Buffer，然后快速地走出 critical section，让前端能够及时拿到锁。</p><p>​    目前的实现，roll file 也是通过 日志后端线程 fork 出一个 子进程 去执行脚本实现的，这会使得 后端线程被阻塞而无法及时 分配/回收 内存，而需要前端自己去 分配内存，最终导致 日志系统性能颠簸（thrashing）。</p><hr><p><strong>性能分析：</strong></p><p>在 8 核 （Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz）虚拟机上，进行多线程 日志系统 性能分析；<strong>一个后端线程 + 一个主线程 + 多个前端线程</strong> 的结构，因为只有 8 个核，因此只测试 1~6 个前端线程的情况：</p><p>(1 thread)  Average of throughput: 217.811256 MB/s</p><p>(2 threads) Average of throughput: 425.770968 MB/s</p><p>(3 threads) Average of throughput: 605.174501 MB/s</p><p>(4 threads) Average of throughput: 768.463506 MB/s</p><p>这里展开 看一下，可以看到 性能 颠簸 很大！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">average time: 839.454355 MB/s #</span><br><span class="line">average time: 827.472073 MB/s #</span><br><span class="line">average time: 771.604938 MB/s</span><br><span class="line">average time: 633.713561 MB/s</span><br><span class="line">average time: 806.126562 MB/s #</span><br><span class="line">average time: 803.212851 MB/s #</span><br><span class="line">average time: 782.932081 MB/s</span><br><span class="line">average time: 803.535556 MB/s #</span><br><span class="line">average time: 775.644755 MB/s</span><br><span class="line">average time: 740.740741 MB/s</span><br><span class="line">average time: 812.017864 MB/s #</span><br><span class="line">average time: 811.688312 MB/s #</span><br><span class="line">average time: 834.376304 MB/s #</span><br><span class="line">average time: 794.438928 MB/s</span><br><span class="line">average time: 741.702207 MB/s</span><br><span class="line">average time: 768.935025 MB/s</span><br><span class="line">average time: 768.787238 MB/s</span><br><span class="line">average time: 793.808295 MB/s #</span><br><span class="line">average time: 700.157535 MB/s </span><br><span class="line">average time: 742.528309 MB/s</span><br></pre></td></tr></table></figure><p>(5 threads) Average of throughput: 949.295990 MB/s</p><p>(6 threads) Average of throughput: 1054.405436 MB/s</p><p>可以看到随着线程数的增加，性能增长在变慢，这是因为 <strong>激烈的 lock contention 以及 内存分配开销</strong> 造成的。</p><p><strong>可以改进的地方：</strong></p><ol><li><p>增加一个 emptyBuffers，buffer 被填满时，从中获取空闲 buffer，减少内存分配带来的开销。参考 muduo P120 图5-5；但是我实现了之后还没有原来的快。。。不知道是不是我的问题~~~~</p></li><li><p>改进 前后端交互接口，实现一个 lock contention 较少的方法。也可以参考 muduo P120 的想法。待实现。。。（由于 日志系统 很难成为项目中的瓶颈，所以现在还没必要 去费尽心思 设计一个 接近 无锁 的数据结构，以后有需要再说吧，哎~~~~）</p></li><li><p>由于日志的输出格式是 <code>日期 时间 线程id 日志级别 源文件名:行号 - 正文</code>，而 源文件名:行号 放在正文前将会导致 整个日志看起来不整齐，但是由于日志系统不依赖于临时对象，所以这一点比较难处理。。。</p></li><li><p>LOG_FATAL 的功能还没实现，即输出完后立即 结束进程。</p></li></ol><hr><p><strong>日志系统调用接口说明：</strong></p><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p><strong>Multi-threaded asynchronous log library</strong></p><p>If appender is the stdout:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;flog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If appender is a file:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;flog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncLogInit <span class="built_in">log</span>; <span class="comment">// initial async log.</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;++i)</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">log</span>.destroy(); <span class="comment">// AsyncLogInit::destroy must be called before exit!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;日志系统设计：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么要自己写一个日志系统？&lt;/p&gt;
&lt;p&gt;因为，网上的日志系统功能十分丰富，而有许多功能在我的项目或未来的项目中是不必要的。尤其是我试用过 spdlog 之后，更加确定了要自己写一个简单的日志系统，spdlo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo 博客移植到别的服务器上</title>
    <link href="https://codroc.github.io/2021/11/08/hexo%E5%8D%9A%E5%AE%A2%E7%A7%BB%E6%A4%8D%E5%88%B0%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
    <id>https://codroc.github.io/2021/11/08/hexo%E5%8D%9A%E5%AE%A2%E7%A7%BB%E6%A4%8D%E5%88%B0%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</id>
    <published>2021-11-07T16:00:00.000Z</published>
    <updated>2021-11-09T01:44:22.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hexo-博客移植到别的服务器上"><a href="#hexo-博客移植到别的服务器上" class="headerlink" title="hexo 博客移植到别的服务器上"></a>hexo 博客移植到别的服务器上</h3><p><strong>1. 将你原来电脑上已经配置好并生成的 hexo 目录拷到你的新电脑上</strong></p><p><strong>2. 在你的新电脑上首先配置 hexo 环境：安装 Node.js</strong></p><p><strong>3. 安装 hexo，执行命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p><strong>4. 安装好之后，进入之前拷贝来的 <code>hexo/source_code/blog</code> 目录</strong></p><p><strong>5. 模块安装，执行命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p><strong>6. 部署，执行命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;hexo-博客移植到别的服务器上&quot;&gt;&lt;a href=&quot;#hexo-博客移植到别的服务器上&quot; class=&quot;headerlink&quot; title=&quot;hexo 博客移植到别的服务器上&quot;&gt;&lt;/a&gt;hexo 博客移植到别的服务器上&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1. 将你原</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于 gettimeofday 是否真的不涉及到系统调用进行记录</title>
    <link href="https://codroc.github.io/2021/11/08/%E5%85%B3%E4%BA%8Egettimeofday%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%B6%89%E5%8F%8A%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%9B%E8%A1%8C%E8%AE%B0%E5%BD%95/"/>
    <id>https://codroc.github.io/2021/11/08/%E5%85%B3%E4%BA%8Egettimeofday%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%B6%89%E5%8F%8A%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%9B%E8%A1%8C%E8%AE%B0%E5%BD%95/</id>
    <published>2021-11-07T16:00:00.000Z</published>
    <updated>2021-11-09T01:47:25.373Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于-gettimeofday-是否真的不涉及到系统调用进行记录"><a href="#关于-gettimeofday-是否真的不涉及到系统调用进行记录" class="headerlink" title="关于 gettimeofday 是否真的不涉及到系统调用进行记录"></a>关于 gettimeofday 是否真的不涉及到系统调用进行记录</h4><p>在《Linux多线程服务端编程》一书 5.1 节中提到过，在 x86-64 的 Linux 上，<code>gettimeofday</code> 不是系统调用，不会陷入内核。其实我是对这句话存有疑问的。众所周知想要获得准确的当前时间，就必须要通过内核的全局的计时变量（ticks 或者 jiffies），但是用 strace 查看调用了 <code>gettimeofday</code> 的进程，发现的确没有涉及到系统调用，没有陷入内核。这就奇了怪了，故上网查找，得到以下信息：</p><p>首先， <code>gettimeofday</code> 的确是一个系统调用，因为它所需求的数据是内核所持有的，但它没有走传统的 trap 这条路进入内核，而是利用了 linux 的 vdso（virtual dynamic shared object）机制帮我们做到了在调用这个系统调用时不陷入内核，从而提高了性能。</p><p>这个实现方法其实也是很直觉的（intuitive），在程序装载阶段，装载程序观察到程序有需要 vdso 的相关系统调用，就为其做一下内存映射（将对应的系统调用处理函数所需的指令和数据映射到用户空间中去）。那么用户在调用这些函数时自然就不需要陷入内核啦~~</p><p>如何调用到这些代码呢？直接调用这些系统调用对应的 glibc 包装函数就可以，因为这些 glibc 包装函数默认会使用 vdso。<strong>如果你执意通过 <code>syscall</code> 函数/ <code>syscall</code> 指令/<code>int 0x80</code> 来调用这些系统调用，vdso 是无法生效的，还是会陷入内核。</strong></p><p>当然 vdso 也不保证一定不会陷入内核，有些情况下是会 fallback 的，以 <code>clock_gettime</code> 为例，下面是 linux 4.16 版本中该系统调用在 vdso 中的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">notrace <span class="keyword">int</span> __vdso_clock_gettime(<span class="keyword">clockid_t</span> clock, struct timespec *ts)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">switch</span> (clock) &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">case</span> CLOCK_REALTIME:</span><br><span class="line"><span class="keyword">if</span> (do_realtime(ts) == VCLOCK_NONE)</span><br><span class="line"><span class="keyword">goto</span> fallback;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CLOCK_MONOTONIC:</span><br><span class="line"><span class="keyword">if</span> (do_monotonic(ts) == VCLOCK_NONE)</span><br><span class="line"><span class="keyword">goto</span> fallback;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CLOCK_REALTIME_COARSE:</span><br><span class="line">do_realtime_coarse(ts);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CLOCK_MONOTONIC_COARSE:</span><br><span class="line">do_monotonic_coarse(ts);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">goto</span> fallback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fallback:</span><br><span class="line"><span class="keyword">return</span> vdso_fallback_gettime(clock, ts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>do_realtime</code>和<code>do_monotonic</code>如果返回值为<code>VCLOCK_NONE</code>的话，就会调用<code>vdso_fallback_gettime</code>，而这个函数是会陷入内核的。另外，<code>clock_gettime</code>的<code>clock</code>参数可不止上面代码中switch里面的4个case，如果我们传入的是<code>CLOCK_BOOTTIME</code>/<code>CLOCK_PROCESS_CPUTIME_ID</code>/<code>CLOCK_THREAD_CPUTIME_ID</code>的话，就会走到default分支，还是会调用<code>vdso_fallback_gettime</code>陷入内核。</p><p>综上所诉，<code>gettimeofday</code>和<code>clock_gettime</code>实际上都是系统调用，但是调用得当的话，可以避免陷入内核，从而提高性能。是否陷入了内核，可以利用 strace 来判断。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li><a href="https://www.i4k.xyz/article/imred/100064061">gettimeofday和clock_gettime是不是系统调用?</a></li><li>muduo</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;关于-gettimeofday-是否真的不涉及到系统调用进行记录&quot;&gt;&lt;a href=&quot;#关于-gettimeofday-是否真的不涉及到系统调用进行记录&quot; class=&quot;headerlink&quot; title=&quot;关于 gettimeofday 是否真的不涉及到系统调用</summary>
      
    
    
    
    
  </entry>
  
</feed>
