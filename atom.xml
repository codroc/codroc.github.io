<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Codroc Blog</title>
  
  
  <link href="https://codroc.github.io/atom.xml" rel="self"/>
  
  <link href="https://codroc.github.io/"/>
  <updated>2022-02-27T13:29:12.000Z</updated>
  <id>https://codroc.github.io/</id>
  
  <author>
    <name>Codroc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fiber 库</title>
    <link href="https://codroc.github.io/2022/02/27/Fiber/"/>
    <id>https://codroc.github.io/2022/02/27/Fiber/</id>
    <published>2022-02-27T13:29:12.000Z</published>
    <updated>2022-02-27T13:29:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于-ucontext-封装的-Fiber-库"><a href="#基于-ucontext-封装的-Fiber-库" class="headerlink" title="基于 ucontext 封装的 Fiber 库"></a>基于 ucontext 封装的 Fiber 库</h1><p>协程优点：</p><ul><li>切换速度快</li><li>切换灵活</li><li>为降低竞争提供另一种思路</li><li>实现异步 epoll</li></ul><p>​    协程是轻量级的线程，由于协程切换属于 用户级别的上下文切换，不会陷入内核，因此切换速度比线程更快自然延迟更低。根据陈海波老师的《<a href="https://www.zhihu.com/search?q=%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2153166653%7D">现代操作系统 原理与实现</a>》一书的105页中： <strong>经过测试，在使用AArch64架构的华为鲲鹏916服务器上，如果使用内核态线程，那么生产者线程切换到消费者线程需要话费约1900ns；而如果使用纤程，该切换时间降低到约500ns。</strong>可以看到差距的巨大。</p><p>​    由于协程切换是在用户级别进行的，因此完全由用户自主操控，想要在哪里切换就在哪里切换，十分灵活。</p><p>​    可以使用多进程（单线程）+协程尽可能的避免race condition，降低各种竞争，从而降低延迟。例如一个线程就可以实现生产者消费者模型，并且不需要加锁。</p><p>​    怎么实现异步 epoll？</p><p>Fiber 库特性：</p><ul><li>非对称协程</li><li>基于 POSIX ucontext.h</li></ul><p>​    我设计的 Fiber 库，每个线程都有一个主协程，并能创建多个子协程；子协程只能把 CPU 控制权交还给主协程，而不能交给其他子协程，故而为非对称协程。</p><p>​    该 Fiber 库基于 ucontext.h 实现</p><hr><p>Fiber 库应该具有的功能：</p><ul><li>隐藏主协程创建的接口，暴露子协程创建接口</li><li>从主协程切换（swapIn）到子协程</li><li>从子协程切换（swapOut）到主协程</li><li>子协程执行代码的入口函数</li><li>协程清理</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fiber</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">// 暴露子协程创建接口</span></span><br><span class="line">     Fiber(<span class="keyword">const</span> Fiber::Callback&amp; cb, <span class="keyword">size_t</span> stackSize);</span><br><span class="line">     <span class="comment">// 获取当前协程 </span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> ptr <span class="title">GetThis</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">// 设置当前协程</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetThis</span><span class="params">(ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 切换到该协程</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">swapIn</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">// 切换到主协程</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">swapOut</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 隐藏主协程创建的接口</span></span><br><span class="line">    Fiber();</span><br><span class="line">     <span class="comment">// 所有协程入口函数</span></span><br><span class="line">     <span class="comment">// 如同所有进程的入口 main 一样</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MainFunc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">ucontext_t</span> _ctx;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的重点在于为每一个线程创建一个 thread_local 用于存储 主协程指针 <code>t_threadFiber</code> 和 当前协程指针 <code>t_curFiber</code>，这样的话就能根据 这两个变量进行 主协程与子协程 间的切换了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber::ptr t_curFiber = <span class="literal">nullptr</span>; <span class="comment">// 当前协程</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber::ptr t_threadFiber = <span class="literal">nullptr</span>; <span class="comment">// 主协程,只有当线程退出时，才会将主协程析构</span></span><br><span class="line"><span class="comment">// 切换到该协程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::swapIn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SetThis(shared_from_this());</span><br><span class="line">    <span class="comment">// 主协程即将切换出去</span></span><br><span class="line">    <span class="comment">// 把上下文保存到 主协程的 ctx 中，并恢复该协程的上下文</span></span><br><span class="line">    ::swapcontext(&amp;t_threadFiber-&gt;_ctx, &amp;_ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 切换到主协程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::swapOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SetThis(t_threadFiber);</span><br><span class="line">    <span class="comment">// 即将从子协程切换出去</span></span><br><span class="line">    <span class="comment">// 把上下文保存到 该协程的 ctx 中，并恢复主协程的上下文</span></span><br><span class="line">    ::swapcontext(&amp;_ctx, &amp;t_threadFiber-&gt;_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>性能测试</strong></p><p>鲲鹏通用计算增强型 2G、1CPU 、1Core：</p><ul><li>协程：切换 100w 次 需要 814ms</li><li>线程：通过生产者消费者队列（队列长度为 1）进行测试（当然有加锁，解锁，条件变量等额外的操作）。切换 100w 次 需要 3300ms（3微秒/切换）</li></ul><p>Inter(R) Core(TM) i7-9700 CPU @ 3.00GHz ，7 Core、4G虚拟机：</p><ul><li>协程：切换 100w 次 需要 430ms</li><li>线程：通过生产者消费者队列（队列长度为 1）进行测试（当然有加锁，解锁，条件变量等额外的操作）。切换 100w 次 需要 32000ms（32微秒/切换）</li></ul><p><strong>分析：</strong></p><p>协程比线程快这是不言而喻的，但是线程上表现出来的数值就很奇怪了，在 1 Core 的鲲鹏虚拟机上 切换一次线程费时 大约 3微秒；但在更快的 i7-9700 CPU 虚拟机上却要 32微秒；这是为什么呢？</p><p>其实这两台实验设备上最大的差别就是<strong>一个是单核一个是多核</strong>。多个核共享一个变量，并把变量保存在 cacheline 中，当某个核要对该变量进行读写操作时，就要保证能看到其他核的 cacheline 中关于该变量的最新的值。这就存在 cacheline 同步的问题，只能等待 CPU 完成<a href="https://en.wikipedia.org/wiki/Cache_coherence">一致性同步</a>之后才能继续用户操作。这就导致速度变得很慢。</p><p><strong>至理名言：</strong>要提高性能，就要避免让CPU频繁同步cacheline。这不单和原子指令本身的性能有关，还会影响到程序的整体性能。最有效的解决方法很直白：<strong>尽量避免共享</strong>。                                                        —–bRPC</p><blockquote><p>一个相关的编程陷阱是false sharing：对那些不怎么被修改甚至只读变量的访问，由于同一个cacheline中的其他变量被频繁修改，而不得不经常等待cacheline同步而显著变慢了。多线程中的变量尽量按访问规律排列，频繁被其他线程修改的变量要放在独立的cacheline中。要让一个变量或结构体按cacheline对齐</p></blockquote><hr><p><strong>存在的问题：</strong></p><p>如果用户调用 swapIn 和 swapOut 的顺序不对，可能会导致 Fiber 对象无法正常释放资源，导致资源泄露。因此要设计一个自动回收永远不会再用到的 Fiber 对象的类。</p><p>当然这一点可以通过再设计一个协程调度器类来解决，把所有的 Fiber 实现都隐藏起来，也就是说用户不能自己去 swapIn、swapOut 了，全权交给调度器去做，仅仅支持用户注册一个协程或想要执行的实例。</p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于-ucontext-封装的-Fiber-库&quot;&gt;&lt;a href=&quot;#基于-ucontext-封装的-Fiber-库&quot; class=&quot;headerlink&quot; title=&quot;基于 ucontext 封装的 Fiber 库&quot;&gt;&lt;/a&gt;基于 ucontext 封装的 F</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MVCC</title>
    <link href="https://codroc.github.io/2021/12/24/MVCC/"/>
    <id>https://codroc.github.io/2021/12/24/MVCC/</id>
    <published>2021-12-23T16:00:00.000Z</published>
    <updated>2021-12-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC 即<strong>多版本并发控制</strong>，是在并发事务场景下用于支持 RC、RR 隔离级别的实现</p><p>四种隔离级别：</p><ul><li>读未提交</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatable Read）</li><li>串行</li></ul><p>事务隔离是怎么实现的？</p><p>在 mysql 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作（undo log），都可以得到前一个状态的值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="https://s4.ax1x.com/2021/12/23/T8oNDg.png"></p><p>这里可以看到一条记录存在多个版本，着就是 MVCC 的 MV 的由来。</p><h4 id="mysql-中存在两个“视图”的概念："><a href="#mysql-中存在两个“视图”的概念：" class="headerlink" title="mysql 中存在两个“视图”的概念："></a>mysql 中存在两个“视图”的概念：</h4><ul><li>一个是 view。它是用一个查询语句定义的虚拟表</li><li>另一个是 Innodb 中实现 MVCC 时用到的<strong>一致性读视图</strong>（consistent <strong>read view</strong>），用于支持 RC、RR 隔离级别的实现</li></ul><p><strong>一致性视图</strong>的创建时机有两种：</p><ul><li>在 begin/start transaction 后的第一条语句开始时创建</li><li>在 执行 start transaction with consistent snapshot 时创建</li></ul><p>这个 <strong>一致性视图</strong> 是什么东西？它其实就是一个“快照”，如果在可重复读隔离级别下的话，是对整个库的快照。它是怎么实现的呢？（即 MVCC 是怎么实现 RC、RR 隔离级别的呢？）</p><p>分四部分讲：</p><ul><li>事务 ID</li><li>行记录隐藏列</li><li>undo log</li><li>ReadView</li></ul><hr><h4 id="事务-ID"><a href="#事务-ID" class="headerlink" title="事务 ID"></a>事务 ID</h4><p>innodb 里面每个事务有一个<strong>唯一的事务 ID</strong>，它是事务开始时向 innodb 的事务系统申请的，是按申请顺序严格递增的。</p><h4 id="行记录的隐藏列"><a href="#行记录的隐藏列" class="headerlink" title="行记录的隐藏列"></a>行记录的隐藏列</h4><ul><li>row_id: 隐藏的行 ID ，用来生成默认的聚集索引。如果创建数据表时没指定聚集索引，这时 innodb 就会用这个隐藏 ID 来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率</li><li>trx_id: 即最后一个对数据插入或者更新的事务 ID，每一次<strong>事务</strong>对索引对应的记录进行改动时，都会把该事务的 ID 赋值给 trx_id</li></ul><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p><img src="https://s4.ax1x.com/2021/12/24/TJ7ttH.png" alt="undo log"></p><p>这里 U1、U2、U3 都是 undo log，如果最新版本的记录 V4 要回到 V3 只要通过 U3 就可以了，同理回到 V2 只要通过 U3、U2 就可以了。</p><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>ReadView 中主要包含4个比较重要的内容：</p><ul><li>m_ids：表示在生成 ReadView 时当前系统中活跃（值事务启动了但还没提交）的读写事务的事务 id 列表</li><li>min_trx_id：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的事务 id，也就是 m_ids 中的最小值</li><li>max_trx_id：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值</li><li>creator_trx_id：表示生成该 ReadView 的事务的事务 id</li></ul><p><img src="https://s4.ax1x.com/2021/12/23/T8OSRs.jpg" alt="ReadView"></p><h4 id="ReadView-是如何工作的？"><a href="#ReadView-是如何工作的？" class="headerlink" title="ReadView 是如何工作的？"></a>ReadView 是如何工作的？</h4><p>有了这些信息，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问</li><li>如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问</li><li>如果被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问</li><li>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问</li></ul><p><strong>innodb 利用了 “所有数据都有多个版本” 的特性，实现了 “秒级创建快照” 的能力。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MVCC&quot;&gt;&lt;a href=&quot;#MVCC&quot; class=&quot;headerlink&quot; title=&quot;MVCC&quot;&gt;&lt;/a&gt;MVCC&lt;/h2&gt;&lt;p&gt;MVCC 即&lt;strong&gt;多版本并发控制&lt;/strong&gt;，是在并发事务场景下用于支持 RC、RR 隔离级别的实现&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMake Template</title>
    <link href="https://codroc.github.io/2021/12/14/cmake_templates/"/>
    <id>https://codroc.github.io/2021/12/14/cmake_templates/</id>
    <published>2021-12-14T08:01:19.233Z</published>
    <updated>2021-12-14T08:01:19.233Z</updated>
    
    <content type="html"><![CDATA[<p>常用 <strong>CMake</strong> 模板，边学边更新</p><span id="more"></span><!-- vim-markdown-toc GitLab --><ul><li><a href="#%E7%8E%AF%E5%A2%83">环境</a></li><li><a href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">简单介绍</a></li><li><a href="#%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%8E%E5%A4%B4%E6%96%87%E4%BB%B6%E9%83%BD%E5%9C%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B">源文件与头文件都在根目录下</a><ul><li><a href="#%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F">内置变量</a></li></ul></li><li><a href="#%E6%BA%90%E6%96%87%E4%BB%B6%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E5%88%86%E5%BC%80%E5%AD%98%E6%94%BE">源文件和头文件分开存放</a></li><li><a href="#%E6%89%BE%E8%B7%AF%E5%BE%84">找路径</a></li><li><a href="#%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%BA%93%E6%88%96%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6">生成静态库或共享库文件</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>我个人使用的是 <strong>Ubuntu18.04</strong>，可以通过 <code>sudo apt install cmake</code> 来安装 <strong>CMake</strong>，在终端输入 <code>cmake --version</code> 可查看版本。</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p><strong>CMake</strong> 是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个库。 它用配置文件控制建构过程 <em>（build process）</em> 的方式和 <strong>Unix 的 make</strong> 相似，只是 <strong>CMake</strong> 的配置文件取名为 <strong>CMakeLists.txt</strong>。<strong>CMake</strong> 并不直接建构出最终的软件，而是产生标准的建构档（如 <strong>Unix的Makefile</strong> 或 <strong>Windows Visual C++的projects/workspaces</strong>），然后再依一般的建构方式使用。</p><p>上面这句话摘自 <a href="https://zh.wikipedia.org/wiki/CMake">Wiki</a>，它说的是什么意思？如果你跟我一样在 <strong>linux</strong> 环境下工作，那么你一定听过 <strong>make</strong>，<strong>make</strong> 能够根据 <strong>makefile</strong> 文件中的说明来一步步地自动构建目标文件；<strong>make</strong> 是一种工具（可执行程序），<strong>makefile</strong> 是文件，里面说明了如何去构建目标文件，<strong>make</strong> 程序会从 <strong>makefile</strong> 中一条条地读出相关的指令去执行。那么 <strong>CMake</strong> 和 <strong>makefile</strong> 有什么关系呢？在没有 <strong>CMake</strong> 之前，我们需要自己动手写 <strong>makefile</strong>，然后去运行 <strong>make</strong>，而这需要你去学习 <strong>makefile</strong> 的语法，十分费时费精力；而现在有了 <strong>CMake</strong>，它可以根据你的指示(都写在 <strong>CMakeLists.txt</strong> 中)自动地去生成 <strong>makefile</strong>，然后你再用 <strong>make</strong> 去构建目标文件即可。写 <strong>CMakeLists.txt</strong> 比写 <strong>makefile</strong> 可容易太多了！</p><h1 id="源文件与头文件都在根目录下"><a href="#源文件与头文件都在根目录下" class="headerlink" title="源文件与头文件都在根目录下"></a>源文件与头文件都在根目录下</h1><p>这种是最简单的情况，例如我的目录下有这些文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── hello.c</span><br><span class="line">├── main.c</span><br><span class="line">├── hello.h</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure><p>如果在 g++ 中执行时命令是这样的：<code>g++ hello.c main.c -o main</code><br>那么我可以在当前目录下编写 <strong>CMakeLists.txt</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8)</span><br><span class="line"></span><br><span class="line">project(main VERSION 1.0)</span><br><span class="line"></span><br><span class="line">add_executable(main hello.c main.c)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>cmake_minimum_required(VERSION)</code> 用来表示可接受的 <strong>CMake</strong> 最低版本</li><li><code>project(name)</code> 用来定义项目名称</li><li><code>add_executable(name sources)</code> 第一个参数是项目名称，第二个参数是源文件名(多个文件名之间用空格隔开)</li></ul><p>编写完 <strong>CMakeLists.txt</strong> 文件后，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>可以看到目标文件已经构建完成！现在的目录层级是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── main</span><br><span class="line">│   └── makefile ...</span><br><span class="line">├── hello.c</span><br><span class="line">├── main.c</span><br><span class="line">├── hello.h</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure><p>这里创建 build 目录是为了更好的层次化管理文件，build 目录内放置所有的二进制文件，而源文件和头文件一般都在项目根目录下</p><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><p><strong>CMake</strong> 定义了相当丰富的变量，然而，我常用的也就那几个。</p><table><thead><tr><th align="left">name</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">PROJECT_BINARY_DIR</td><td align="left">是指包含最近的 project() 命令的 build 目录</td></tr><tr><td align="left">PROJECT_SOURCE_DIR</td><td align="left">是指包含最近的 project() 命令的 CMakeLists.txt 的目录</td></tr><tr><td align="left">CMAKE_CURRENT_BINARY_DIR</td><td align="left">当前处理的 CMakeLists.txt 所在的 build 目录</td></tr><tr><td align="left">CMAKE_CURRENT_SOURCE_DIR</td><td align="left">当前处理的 CMakeLists.txt 所在的目录</td></tr><tr><td align="left">CMAKE_SOURCE_DIC</td><td align="left">指定义了顶级 CMakeLists.txt 的目录</td></tr><tr><td align="left">EXECUTABLE_OUTPUT_PATH</td><td align="left">生成的可执行文件的存储目录</td></tr><tr><td align="left">LIBRARY_OUTPUT_PATH</td><td align="left">生成的库的存储目录</td></tr><tr><td align="left">PROJECT_NAME</td><td align="left">项目名称</td></tr><tr><td align="left">PROJECT_VERSION_MAJOR</td><td align="left">项目主版本号（例如 2.8 的主版本号是 2）</td></tr><tr><td align="left">PROJECT_VERSION_MINOR</td><td align="left">项目次版本号 （例如 2.8 的次版本号是 8）</td></tr><tr><td align="left">PROJECT_VERSION_PATCH</td><td align="left">项目版本的补丁号（例如 2.8.1 的补丁号是 1）</td></tr><tr><td align="left">BUILD_SHARED_LIBS</td><td align="left">用于控制 cmake 的 add_library 指令是否默认生成 动态so（yes if flag=on）还是 静态库.a （if flag=off）。默认是 flag=on</td></tr><tr><td align="left">CMAKE_C_FLAGS</td><td align="left">编译器 gcc 的标志</td></tr><tr><td align="left">CMAKE_CXX_FLAGS</td><td align="left">编译器 g++ 的标志</td></tr></tbody></table><p>记不住变量的值时，可以使用 cmake 的 <strong>message 函数</strong>输出变量值。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(show_vars VERSION <span class="number">1.0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了分行确定输出内容</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;1.PROJECT_BINARY_DIR = $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;2.PROJECT_SOURCE _DIR = $&#123;_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;3.CMAKE_CURRRENT_BINARY_DIR = $&#123;CMAKE_CURRRENT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;4.CMAKE_CURRENT_SOURCE_DIR = $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;5.CMAKE_SOURCE_DIR = $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;6.EXECUTABLE_OUTPUT_PATH = $&#123;EXECUTABLE_OUTPUT_PATH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;7.LIBRARY_OUTPUT_PATH = $&#123;LIBRARY_OUTPUT_PATH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;8.PROJECT_NAME = $&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;9.PROJECT_VERSION_MAJOR = $&#123;PROJECT_VERSION_MAJOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;10.PROJECT_VERSION_MINOR = $&#123;PROJECT_VERSION_MINOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;11.PROJECT_VERSION_PATCH = $&#123;PROJECT_VERSION_PATCH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;12.BUILD_SHARED_LIBS = $&#123;BUILD_SHARED_LIBS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;13.CMAKE_C_FLAGS = $&#123;CMAKE_C_FLAGS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;14.CMAKE_CXX_FLAGS = $&#123;CMAKE_CXX_FLAGS&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="源文件和头文件分开存放"><a href="#源文件和头文件分开存放" class="headerlink" title="源文件和头文件分开存放"></a>源文件和头文件分开存放</h1><p>现在有以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── hello.h</span><br><span class="line">└── source</span><br><span class="line">    ├── hello.cc</span><br><span class="line">    └── main.cc</span><br></pre></td></tr></table></figure><p>这种情况下的 CMakeLists.txt 文件应该这样编写：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/source/*.cc</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(main SOURCES)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(main PRIVATE <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p><strong>set(name value)</strong> 可以自己定义一个变量，<em>name</em> 是变量名，<em>value</em> 是变量值</p><p>这里 <em>PROJECT_SOURCE_DIR</em> 的值就是 <em>./</em> (项目根目录)</p><p><strong>target_include_directories(<target> &lt;PRIVATE|INTERFACE|PUBLIC&gt; [item])</target></strong> 是用来标明头文件路径的，相当于编译器选项的 <strong>-I</strong>, 这里 <em>target</em> 就是项目名称，<em>&lt;PRIVATE|INTERFACE|PUBLIC&gt;</em> 三种属性我现在还没搞懂。。。*[item]* 就是头文件路径。</p><p>你可以在 make 时开启输出模式 <code>make VERBOSE=1</code> 来看看编译器的参数，应该是:<br><code>g++ -I 根目录/include 根目录/hello.cc 根目录/main.cc -o 根目录/build/main </code></p><h1 id="找路径"><a href="#找路径" class="headerlink" title="找路径"></a>找路径</h1><p>cmake find_path 命令用来寻找包含指定文件名称的目录。</p><p>通常，它的签名如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_path</span> (</span><br><span class="line">          &lt;VAR&gt;</span><br><span class="line">          name | NAMES name1 [name2 ...]</span><br><span class="line">          [HINTS path1 [path2 ... ENV var]]</span><br><span class="line">          [PATHS path1 [path2 ... ENV var]]</span><br><span class="line">          [PATH_SUFFIXES suffix1 [suffix2 ...]]</span><br><span class="line">          [DOC <span class="string">&quot;cache documentation string&quot;</span>]</span><br><span class="line">          [REQUIRED]</span><br><span class="line">          [NO_DEFAULT_PATH]</span><br><span class="line">          [NO_PACKAGE_ROOT_PATH]</span><br><span class="line">          [NO_CMAKE_PATH]</span><br><span class="line">          [NO_CMAKE_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_SYSTEM_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_CMAKE_SYSTEM_PATH]</span><br><span class="line">          [CMAKE_FIND_ROOT_PATH_BOTH |</span><br><span class="line">           ONLY_CMAKE_FIND_ROOT_PATH |</span><br><span class="line">           NO_CMAKE_FIND_ROOT_PATH]</span><br><span class="line">         )</span><br></pre></td></tr></table></figure><p><code>&lt;VAR&gt;</code> 是一个变量，用于存放该命令得到的结果。它有点像 find 命令，如果在某个目录下找到了指定的文件名，目录名将会存到 <code>&lt;VAR&gt;</code> 变量中，并且 find 搜索将会停止！如果没有找到，结果将会是<code>&lt;VAR&gt;-NOTFOUND</code>。</p><p>举个栗子就懂了，例如 muduo-tutorial 项目 cmake 目录下的 CMakeLists.txt 文件中有这样两行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set(MUDUO_PATH &quot;/opt/muduo_hdrs_libs&quot;)</span></span><br><span class="line"><span class="keyword">find_path</span>(Muduo_INCLUDE_DIR muduo <span class="string">&quot;$&#123;MUDUO_PATH&#125;/include&quot;</span>)</span><br><span class="line"><span class="keyword">find_path</span>(Muduo_LIBRARY_DIR libmuduo_net.a <span class="string">&quot;$&#123;MUDUO_PATH&#125;/lib&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls /opt/muduo_hdrs_libs</span><br><span class="line">inludelib</span><br><span class="line">$ ls /opt/muduo_hdrs_libs/include</span><br><span class="line">muduo</span><br><span class="line">$ ls /opt/muduo_hdrs_libs/lib</span><br><span class="line">libmuduo_base.a  libmuduo_http.a  libmuduo_inspect.a  libmuduo_net.a  libmuduo_pubsub.a</span><br></pre></td></tr></table></figure><p>因此我这里 Muduo_INCLUDE_DIR 就是 <code>/opt/muduo_hdrs_libs/include</code>，Muduo_LIBRARY_DIR 就是 <code>/opt/muduo_hdrs_libs/lib</code>。</p><h1 id="生成静态库或共享库文件"><a href="#生成静态库或共享库文件" class="headerlink" title="生成静态库或共享库文件"></a>生成静态库或共享库文件</h1><p>可以使用 add_library(libname, srcs) 来生产静态库</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.<a href="https://mlog.club/article/1918025">https://mlog.club/article/1918025</a><br>2. <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html#packaging-debug-and-release-step-12">https://cmake.org/cmake/help/latest/guide/tutorial/index.html#packaging-debug-and-release-step-12</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用 &lt;strong&gt;CMake&lt;/strong&gt; 模板，边学边更新&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Config System</title>
    <link href="https://codroc.github.io/2021/12/14/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/"/>
    <id>https://codroc.github.io/2021/12/14/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-12-14T00:47:18.045Z</published>
    <updated>2021-12-14T00:47:18.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><p><strong>配置系统有什么用？</strong></p><p>我的理解是方便程序的运行和发布。把配置变量都抽离出来放在配置文件中，如果要修改配置变量，就直接在配置文件里修改，然后重新运行程序就可以了。如果没有配置系统的情况下要修改配置变量，一般都是直接改程序源代码，然后重新编译连接，毫无疑问这将会是费时费力的（找对应版本的各种库，对应版本的编译器等等，还要等待漫长的编译连接过程。。。），对于那些非开源软件，想改源代码就更不可能了。。。。</p><p>然而配置系统的存在能够很好地解决这些问题。</p><h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><p>选择一种用于配置文件的语言，我选的是 YAML。它是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。</p><p>YAML 实质上是一种通用的数据串行化格式。它的基本语法规则如下：</p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用 Tab 键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li></ul><p><code>#</code>  表示注释，从这个字符一直到行尾，都会被解析器忽略。</p><p>YAML 支持的数据结构有三种：</p><ul><li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li><li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li><li>纯量（scalars）：单个的、不可再分的值</li></ul><p>YAML 下载与安装：</p><p><code>yaml-cpp: github repo</code></p><p><code>mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make install</code></p><h3 id="基于-YAML-实现-配置系统"><a href="#基于-YAML-实现-配置系统" class="headerlink" title="基于 YAML 实现 配置系统"></a>基于 YAML 实现 配置系统</h3><p>配置系统的原则：</p><ul><li><strong>约定优于配置：</strong>约定即源代码中写死的值，而配置是指在配置文件 (.yaml) 中指定的值。</li><li><strong>不能无中生有：</strong>在源文件中未定义的配置变量，即使在配置文件 (.yaml) 中定义了也不会生效。</li></ul><p>总体的结构是这样的：</p><p>​    由于配置变量一般都由：变量名，变量值，变量描述构成。因此可以抽一个基类出来存放这些共通的属性，必然的，有时候会需要把配置变量输出到控制台给用户看，或根据字符串来重置变量值，因此还需要一个 fromString 和 toString 方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVarBase</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ConfigVarBase&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span>; <span class="comment">// 根据 str 来设置 配置变量值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>;  <span class="comment">// 把配置变量值转成字符串，便于输出</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _description;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    其中变量名和变量描述由于类型固定，可以放在基类中，而变量值则不固定了，它可以是任意类型，因此就可以根据基类派生出一个模板子类来表示具体的配置变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> :</span> <span class="keyword">public</span> ConfigVarBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    现在有配置变量了，缺一个管理这些配置变量的类，我使用 std::map 来进行管理，通过 name-&gt;ConfigVarBase::ptr 的映射来实现管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, ConfigVarBase::ptr&gt; _configVars;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一来 <strong>约定的变量</strong> 就实现了！</p><p>接下来就是怎么实现，从配置文件 (.yaml) 中读取配置变量。yaml-cpp 库提供了 LoadFile 函数，能从 .yaml 文件中读取 YAML::Node。</p><p>由于 .yaml 中的格式和我源代码中变量名字的格式是不一样的：</p><p>yaml 中是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A:</span></span><br><span class="line"><span class="attr">B:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">C:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>源文件中的变量名则为：A.B = 10，A.C = 20</p><p>因此这里需要一个从 YAML 名称格式到 源代码中的变量名称格式的转换。可以借助 yaml-cpp 中的 <code>IsNull, IsScalar, IsSequence, Ismap</code> 对 node 进行递归遍历，然后将变量名进行转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listAllNodes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> YAML::Node&amp; node,  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, YAML::Node&gt;&gt;&amp; allNodes)</span> </span>&#123;</span><br><span class="line">    allNodes.push_back(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(name, node));</span><br><span class="line">    <span class="keyword">if</span> (node.IsNull()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsScalar()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsSequence()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsMap()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = node.begin(); it != node.end(); ++it) &#123;</span><br><span class="line">            listAllNodes(name.empty() ? it-&gt;first.as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;() :</span><br><span class="line">                    name + <span class="string">&quot;.&quot;</span> + it-&gt;first.Scalar(), it-&gt;second, allNodes); <span class="comment">// 这里是名字转换的关键所在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config::loadFromYaml</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    YAML::Node node = YAML::LoadFile(filename);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, YAML::Node&gt;&gt; allNodes;</span><br><span class="line">    listAllNodes(<span class="string">&quot;&quot;</span>, node, allNodes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : allNodes) &#123; <span class="comment">// 对所有的 name、node 进行遍历</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name = i.first;</span><br><span class="line">        <span class="keyword">if</span> (name.empty())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ConfigVarBase::ptr p = Config::find(name);</span><br><span class="line">        <span class="keyword">if</span> (p) &#123; <span class="comment">// 这里保证了不会无中生有的原则</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">            ss &lt;&lt; i.second;</span><br><span class="line">            p-&gt;fromString(ss.str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里使用了 stringstream 把 YAML::Node 字符串化。然后调用 fromString 来对配置变量进行设置。</p><h3 id="fromStr-和-toStr-的实现"><a href="#fromStr-和-toStr-的实现" class="headerlink" title="fromStr 和 toStr 的实现"></a>fromStr 和 toStr 的实现</h3><p>对于普通的内置类型可以用 boost::lexical_cast 来实现，而对于复杂的数据类型，例如：vector,list,set,map,unordered_set,unordered_map, 自定义类型 等，就要自己去实现了。</p><p><strong>STL 类型的支持：</strong></p><p>可以实现一个 LexicalCast 模板类，然后根据具体的 STL 容器对 LexicalCast 进行偏特化就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于普通内置类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> F&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boost::lexical_cast&lt;T&gt;(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cast from std::string to std::vector&lt;T&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        ...<span class="comment">// 利用 yaml-cpp 的 Load 得到 node 然后遍历 node，利用 stringstream 格式化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// cast from std::vector&lt;T&gt; to std::string</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">FromStr</span> =</span> LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, T&gt;, </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToStr</span> =</span> LexicalCast&lt;T, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> :</span> <span class="keyword">public</span> ConfigVarBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _val = FromStr()(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ToStr()(_val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>自定义类型的支持：</strong></p><p>自定义类型，需要实现 LexicalCast 偏特化，实现后，就可以支持 Config 解析自定义类型，自定义类型可以和常规 STL 容器一起使用。</p><p>例如，增加 Person 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">bool</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from std::string to Person</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, Person&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Person <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        YAML::Node node = YAML::Load(str);</span><br><span class="line">        Person p;</span><br><span class="line">        p.name = node[<span class="string">&quot;name&quot;</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        p.age = node[<span class="string">&quot;age&quot;</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        p.sex = node[<span class="string">&quot;sex&quot;</span>].as&lt;<span class="keyword">bool</span>&gt;();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from Person to std::string</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span>Person, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span> </span>&#123;</span><br><span class="line">        YAML::Node node;</span><br><span class="line">        node[<span class="string">&quot;name&quot;</span>] = p.name;</span><br><span class="line">        node[<span class="string">&quot;age&quot;</span>] = p.age;</span><br><span class="line">        node[<span class="string">&quot;sex&quot;</span>] = p.sex;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="配置的事件机制"><a href="#配置的事件机制" class="headerlink" title="配置的事件机制"></a>配置的事件机制</h3><p>当一个配置项发生修改的时候，可以反向通知对应的代码。</p><p>这个其实挺容易实现的，在 ConfigVar 模板类中添加一个 OnChangeCallBack _cb 回调，它是 </p><p>std::function&lt;const T&amp; oldVal, const T&amp; newVal&gt; 类型的，每当要改变 ConfigVar::_val 时，先判断一下，新的值是否与旧值不同，如果是的化则回调 _cb</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> &#123;</span></span><br><span class="line">... </span><br><span class="line"><span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == _val)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (_cb)</span><br><span class="line">            _cb(_val, v);</span><br><span class="line">        _val = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnChangeCallBack</span><span class="params">(OnChangeCallBack cb)</span> </span>&#123; _cb = cb; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delOnChangeCallBack</span><span class="params">()</span> </span>&#123; _cb = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">    OnChangeCallBack _cb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样配置系统基本就完成了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;配置系统&quot;&gt;&lt;a href=&quot;#配置系统&quot; class=&quot;headerlink&quot; title=&quot;配置系统&quot;&gt;&lt;/a&gt;配置系统&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;配置系统有什么用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的理解是方便程序的运行和发布。把配置变量都抽离出来放在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP keep-alive</title>
    <link href="https://codroc.github.io/2021/11/26/tcp_keep-alive/"/>
    <id>https://codroc.github.io/2021/11/26/tcp_keep-alive/</id>
    <published>2021-11-25T16:00:00.000Z</published>
    <updated>2021-11-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-保活机制"><a href="#TCP-保活机制" class="headerlink" title="TCP 保活机制"></a>TCP 保活机制</h2><h4 id="为什么需要-TCP-保活机制"><a href="#为什么需要-TCP-保活机制" class="headerlink" title="为什么需要 TCP 保活机制"></a>为什么需要 TCP 保活机制</h4><p>设想这种情况，TCP连接建立后，在一段时间范围内双发没有互相发送任何数据。思考以下两个问题：</p><ol><li>怎么判断对方是否还在线。这是因为，TCP对于非正常断开的连接系统并不能侦测到（比如网线断掉）。</li><li>长时间没有任何数据发送，连接可能会被中断。这是因为，网络连接中间可能会经过路由器、防火墙等设备，而这些有可能会对长时间没有活动的连接断掉。</li></ol><p>基于上面两点考虑，需要保活机制。</p><p><font color="green">其实 有一部分人认为，keep-alive 的检测应该放在 应用层 而不是 传输层。</font></p><h4 id="TCP保活机制的实现-Linux"><a href="#TCP保活机制的实现-Linux" class="headerlink" title="TCP保活机制的实现 (Linux)"></a>TCP保活机制的实现 (Linux)</h4><p><strong>系统级别：</strong></p><p>具体实现上有以下几个相关的配置：</p><ul><li>保活时间：默认7200秒（2小时）</li><li>保活时间间隔：默认75秒</li><li>保活探测数：默认9次                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </li></ul><p>可以通过 <code>/proc/sys/net/ipv4/</code> 接口查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/net/ipv4/tcp_keepalive_time</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/net/ipv4/tcp_keepalive_probes</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span></span><br></pre></td></tr></table></figure><p>或 通过 sysctl 查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysctl -A | grep keepalive</span></span><br></pre></td></tr></table></figure><h4 id="TCP-保活机制试验："><a href="#TCP-保活机制试验：" class="headerlink" title="TCP 保活机制试验："></a>TCP 保活机制试验：</h4><p>首先将 <strong>tcp_keepalive_time</strong> 设置为 20，即 20s 内 连接上没有数据收发就启动 间隔定时器；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 20 | sudo tee /proc/sys/net/ipv4/tcp_keepalive_time</span></span><br></pre></td></tr></table></figure><p>将 <strong>tcp_keepalive_intvl</strong> 设置为 5，即如果连接不活跃(开启定时器后，发送一个探测报文，但是没收到响应)，则每 5s 发送一个探测报文；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 5 | sudo tee /proc/sys/net/ipv4/tcp_keepalive_intvl</span></span><br></pre></td></tr></table></figure><p>将 <strong>tcp_keepalive_probes</strong> 设置为 2。即如果 发出探测报文后 对端没有回应则重复发送探测报文的次数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 2 | sudo tee /proc/sys/net/ipv4/tcp_keepalive_probes</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：修改 /proc 接口中的内容，不能用 vi/vim 编辑器，因为 vi/vim 的做法是先根据源文件创建一个 .swap 临时文件，而 /proc 中的内容都是 内存中的映像，根本不存在于 磁盘中，如果用 vi/vim 去修改必定得到 E667: Fsync failed 错误。</p></blockquote><p>在两台云服务器上进行实验，监听的一端设置 tcp keep-alive</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip: 124.70.82.205</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nohup sudo nc -l -p443 -k &amp; <span class="comment"># -k 表示开启 tcp keep-alive 机制</span></span></span><br></pre></td></tr></table></figure><p>在另一台服务器上对 124.70.82.205 443 发起连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip: 112.124.36.253</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc 124.70.82.205 443</span></span><br></pre></td></tr></table></figure><p>在 ip: 124.70.82.205 上对 端口 443 进行抓包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tcpdump -i eth0 port 443</span></span><br><span class="line">10:45:09.891760 IP 124.70.82.205.https &gt; 112.124.36.253.44338: Flags [.], ack 2867648125, win 510, options [nop,nop,TS val 956683255 ecr 4136667676], length 0</span><br><span class="line">10:45:09.920708 IP 112.124.36.253.44338 &gt; 124.70.82.205.https: Flags [.], ack 1, win 229, options [nop,nop,TS val 4136687900 ecr 956519734], length 0</span><br><span class="line"></span><br><span class="line">10:45:30.115763 IP 124.70.82.205.https &gt; 112.124.36.253.44338: Flags [.], ack 1, win 510, options [nop,nop,TS val 956703479 ecr 4136687900], length 0</span><br><span class="line">10:45:30.144706 IP 112.124.36.253.44338 &gt; 124.70.82.205.https: Flags [.], ack 1, win 229, options [nop,nop,TS val 4136708124 ecr 956519734], length 0</span><br><span class="line"></span><br><span class="line">10:45:50.339764 IP 124.70.82.205.https &gt; 112.124.36.253.44338: Flags [.], ack 1, win 510, options [nop,nop,TS val 956723703 ecr 4136708124], length 0</span><br><span class="line">10:45:50.368749 IP 112.124.36.253.44338 &gt; 124.70.82.205.https: Flags [.], ack 1, win 229, options [nop,nop,TS val 4136728348 ecr 956519734], length 0</span><br></pre></td></tr></table></figure><p>可以看到 由于连接不活跃，每隔 一个 <strong>tcp_keepalive_time</strong> 都会向对端 发送一个 keep-alive 报文，来探测对端是否还“活着”。</p><p><strong>上述实验的过程描述：</strong></p><p>连接中启动保活功能的一端，在保活时间内连接处于非活动状态，则向对方发送一个保活探测报文，如果收到响应，则重置保活计时器，如果没有收到响应报文，则经过一个保活时间间隔后再次向对方发送一个保活探测报文，如果还没有收到响应报文，则继续，直到发送次数到达保活探测数，此时，对方主机将被确认为不可到达，连接被中断。</p><p>TCP保活功能工作过程中，开启该功能的一端会发现对方处于以下四种状态之一：</p><ol><li>对方主机仍在工作，并且可以到达。此时请求端将保活计时器重置。如果在计时器超时之前应用程序通过该连接传输数据，计时器再次被设定为保活时间值。</li><li>对方主机已经崩溃，包括已经关闭或者正在重新启动。这时对方的TCP将不会响应。请求端不会接收到响应报文，并在经过保活时间间隔指定的时间后超时。超时前，请求端会持续发送探测报文，一共发送保活探测数指定次数的探测报文，如果请求端没有收到任何探测报文的响应，那么它将认为对方主机已经关闭，连接也将被断开。</li><li>客户主机崩溃并且已重启。在这种情况下，请求端会收到一个对其保活探测报文的响应，但这个响应是一个重置报文段 <code>RST</code>，请求端将会断开连接。</li><li>对方主机仍在工作，但是由于某些原因不能到达请求端（例如网络无法传输，而且可能使用ICMP通知也可能不通知对方这一事实）。这种情况与状态2相同，因为TCP不能区分状态2与状态4，结果是都没有收到探测报文的响应。</li></ol><blockquote><p>tcp 保活机制的弊端：保活机制会占用不必要的带宽</p></blockquote><p><strong>保活机制是存在争议的，主要争议之处在于是否应在TCP协议层实现，有两种主要观点：其一，保活机制不必在TCP协议中提供，而应该有应用层实现；其二，认为大多数应用都需要保活机制，应该在TCP协议层实现。</strong></p><p><font color="red">这里修改的 /proc 中的变量会导致 全局（整个系统）的 tcp keep-alive 机制发送变化，那么能不能只针对一个 socket 进行 keep-alive 机制的制定呢？</font></p><h4 id="针对单个-socket-的保活机制"><a href="#针对单个-socket-的保活机制" class="headerlink" title="针对单个 socket 的保活机制"></a>针对单个 socket 的保活机制</h4><p>下面介绍针对单个 socket 连接 细粒度设置 的三个选项参数：</p><p><strong>保活时间：TCP_KEEPIDLE、保活探测时间间隔：TCP_KEEPINTVL、探测循环次数：TCP_KEEPCNT</strong>（可通过 man 7 tcp 中 Socket options 这一节查看细节）</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTEN_PORT 33333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUF 65536</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">echo_data</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">events_handle</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用TCP保活机制的相关代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_keepalive</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> keepalive_time, <span class="keyword">int</span> keepalive_intvl, <span class="keyword">int</span> keepalive_probes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> optval;</span><br><span class="line">    <span class="keyword">socklen_t</span> optlen = <span class="keyword">sizeof</span>(optval);</span><br><span class="line">    optval = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optval = keepalive_probes;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_TCP, TCP_KEEPCNT, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optval = keepalive_intvl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_TCP, TCP_KEEPINTVL, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optval = keepalive_time;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_TCP, TCP_KEEPIDLE, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> _argc, <span class="keyword">char</span>* _argv[])</span> </span>&#123;</span><br><span class="line">    run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == epfd) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create1 failure.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="keyword">int</span> listen_sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bzero(&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    seraddr.sin_port = htons(LISTEN_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bind(listen_sock, (struct sockaddr*)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr))) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind server addr failure.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(listen_sock, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = listen_sock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == epoll_ctl(epfd, EPOLL_CTL_ADD, listen_sock, &amp;ev)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl add listen_sock failure.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nfds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == nfds) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait failure.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> n = <span class="number">0</span>; n &lt; nfds; ++n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[n].data.fd == listen_sock) &#123;</span><br><span class="line">                <span class="keyword">int</span> conn_sock = accept(listen_sock, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == conn_sock) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept failure.&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accept from %s:%d\n&quot;</span>, inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)), ntohs(cliaddr.sin_port));</span><br><span class="line">                set_keepalive(conn_sock, <span class="number">120</span>, <span class="number">20</span>, <span class="number">3</span>);</span><br><span class="line">                setnonblocking(conn_sock);</span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = conn_sock;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == epoll_ctl(epfd, EPOLL_CTL_ADD, conn_sock, &amp;ev)) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl add conn_sock failure.&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                events_handle(epfd, events[n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(listen_sock);</span><br><span class="line">    close(epfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 33333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 65535</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client_handle</span><span class="params">(<span class="keyword">int</span> sock)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input args %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> server_port = SERVER_PORT;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> == argc) &#123;</span><br><span class="line">        server_port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bzero(&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr);</span><br><span class="line">    seraddr.sin_port = htons(server_port);</span><br><span class="line"></span><br><span class="line">    connect(sock, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    client_handle(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/s_lisheng/article/details/87288445">【TCP/IP详解】TCP保活机制</a></li><li><a href="https://zhuanlan.zhihu.com/p/224595048">HTTP keep-alive和TCP keepalive的区别，你了解吗？</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP-保活机制&quot;&gt;&lt;a href=&quot;#TCP-保活机制&quot; class=&quot;headerlink&quot; title=&quot;TCP 保活机制&quot;&gt;&lt;/a&gt;TCP 保活机制&lt;/h2&gt;&lt;h4 id=&quot;为什么需要-TCP-保活机制&quot;&gt;&lt;a href=&quot;#为什么需要-TCP-保活机制&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>只用 EventLoop Poller Channel 实现 Reactor 模式</title>
    <link href="https://codroc.github.io/2021/11/25/reactor_pattern/"/>
    <id>https://codroc.github.io/2021/11/25/reactor_pattern/</id>
    <published>2021-11-24T16:00:00.000Z</published>
    <updated>2021-11-25T01:27:26.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用-C-实现一个简单的-Reactor-模式"><a href="#用-C-实现一个简单的-Reactor-模式" class="headerlink" title="用 C++ 实现一个简单的 Reactor 模式"></a>用 C++ 实现一个简单的 Reactor 模式</h3><p>何谓 Reactor 模式？（请看 Schmidt, D.C. (1995). Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events）</p><p>Reactor 模式的目的：<strong>处理多个客户端的并发服务请求</strong> （以下是论文 Reactor 的原话）</p><blockquote><p>The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. —— Reactor</p></blockquote><p>Reactor 模式的主要结构：</p><ul><li>Handles：标识由 OS 管理的一系列资源。这些资源通常包括：网络连接，打开文件，定时器，同步对象等等。Handle 可以看成是对这些资源的句柄，例如 fd (file description), timerfd。</li><li>Synchronous Event Demultiplexer：这在 Linux 中其实就是 select、poll、epoll。它利用 IO multiplexing 机制，通知用户哪些 Handles 已经 IO ready （即 调用 IO 函数不会导致 阻塞）。在我的实现中，epoll 接口被封装到了 Poller 类中。 </li><li>Initiation Dispatcher：用于注册、移除以及分发事件处理器 (Event Handler) 的接口。在我的实现中就是 Channel 类，它实现了事件分发机制。</li><li>Event Handler：这是一个接口，它实现了根据指定的 IO Event 来进行指定的操作。</li><li>Concrete Event Handler：这是 <strong>事件处理器</strong> 的具体实现。</li></ul><p><img src="https://z3.ax1x.com/2021/11/24/oijO1J.png" alt="reactor 模式"></p><p>让我来解释一下整个流程：</p><ol><li>Concrete Event Handler 不断地监视是否有 IO event 发生</li><li>有 IO event 发生，Concrete Event Handler 立即通知 Handle，并让 Dispatcher 把 IO event 分发给对应的 event handler</li><li>event handler 处理 event</li><li>在处理 event 的过程中，可能又会注册需要 monitor 的 IO event 到 Concrete Event Handler 中去，并把对应的 event handler 注册到 Disapatcher 中去</li><li>回到步骤 1</li></ol><p>​    上述整个流程其实是管理所有文件描述符的所有事件（包括<em>可读</em>，<em>可写</em>，等等），并在适当时机执行指定的回调函数（event handler）。所以，这实际上是一个<strong>事件循环 （event loop）</strong>。因此我用 EventLoop 类来描述这一整个流程。</p><hr><p>一个简单的 Reactor 就仅仅需要以下三个类：</p><ul><li>EventLoop: 实现事件循环</li><li>Channel: 实现事件分发机制</li><li>Poller: 实现监视 IO event 并通知</li></ul><h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p>其核心是实现一个 <strong>事件循环</strong> <strong>loop</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Handle&gt; activeHandles;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        activeHandles.clear();</span><br><span class="line">    <span class="comment">// 执行流程 1：一旦有 IO 事件发生就让 Poller 通知我</span></span><br><span class="line">        <span class="comment">// 并且把 对应 IO 的 Handle 告诉我 </span></span><br><span class="line">        Poller.poll(activeHandles);</span><br><span class="line">        <span class="comment">// 执行流程 2, 3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> handle : activeHandles)</span><br><span class="line">            Dispatcher.handleEvent(handle); <span class="comment">// 在具体 event handler 执行的过程中回去执行流程 4, 5</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里仅仅是伪代码，还有很多细节是需要补全的，例如 Dispatcher 会根据 handle 以及发生的 IO event 去挑选具体的 handler，这些细节可以全部封装到 Channel 中！所有实际的实现就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Channels*&gt; activeChannels;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        activeChannels.clear();</span><br><span class="line">    <span class="comment">// 执行流程 1：一旦有 IO 事件发生就让 Poller 通知我</span></span><br><span class="line">        <span class="comment">// 并且把 对应 IO 的 Handle 告诉我 </span></span><br><span class="line">        Poller.poll(activeChannels);</span><br><span class="line">        <span class="comment">// 执行流程 2, 3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> channel : activeChannels)</span><br><span class="line">            channel-&gt;handleEvent(); <span class="comment">// 在具体 event handler 执行的过程中回去执行流程 4, 5</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h4><p>它就是对 整个 Epoll 机制的封装，即 epoll_create、epoll_wait、epoll_ctl</p><p>它无非就是通过 epoll_create 创建一个 epoll instance，然后 通过 epoll_ctl 注册用户需要让 OS monitor 的 IO event。所以代码整体骨架如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Poller::Poller()</span><br><span class="line">    : _epfd(epoll_create(<span class="number">1</span>))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Poller::~Poller() &#123;</span><br><span class="line">    ::close(_epfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Poller::poll</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;channel*&gt; activeChannel, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_events</span> <span class="title">events</span>[<span class="title">kMaxEvents</span>];</span></span><br><span class="line">    <span class="keyword">int</span> n = epoll_wait(_epfd, events, kMaxEvents, timeout); <span class="comment">// 等待 IO event 发生</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">        Channel* pChannel = <span class="keyword">reinterpret_cast</span>&lt;Channel*&gt;(events[i].data.ptr);</span><br><span class="line">        pChannel-&gt;setOccurEvents(events[i].events); <span class="comment">// 把 epoll 监测到的 IO 事件（可读、可写）记录到对应 Handle 的 channel 中去</span></span><br><span class="line">        activeChannel.push_back(pChannel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poller::update</span><span class="params">(Channel* pChannel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该函数用于注册 IO event 到 epoll instance 中去</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_events</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = pChannel.getWaitEvents(); <span class="comment">// 获取用户想要 OS monitor 的 IO event</span></span><br><span class="line">    ev.data.ptr = pChannel;</span><br><span class="line">    epoll_ctl(); <span class="comment">// 根据具体情况选择 EPOLL_CTL_ADD、EPOLL_CTL_MOD 或 EPOLL_CTL_DEL</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>​    这个类实现了 <strong>IO 事件分发</strong> 机制，也是 Reactor 模式中重要的一环。它记录了用户想要 epoll instance 帮忙 monitor 的 fd 的具体 IO event（例如可读事件），也记录了当 IO event 发生时应该进行的操作（即 event handler）。有时候我们要让 epoll instance 监视多种 IO event，例如 可读、可写，因此一旦 IO 可读，epoll instance 就会通知我们，我们此时需要记录下 具体是哪种 IO event 导致的通知以便做出正确的响应操作，因此也需要记录 已发生的 IO event</p><p>​    当前我的设计是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> EventCallBack = <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个 Channel 独属于 一个 EventLoop</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Channel</span><span class="params">(EventLoop*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 io multi-plexing 检测到的已发生的事件 记录在 _occurEvents 中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOccurEvents</span><span class="params">(<span class="keyword">uint32_t</span> occurEvents)</span> </span>&#123; _occurEvents = occurEvents; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">getWaitEvents</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _waitEvents; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置事件回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setReadEventCallBack</span><span class="params">(EventCallBack cb)</span> </span>&#123; _readEventCallBack = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWriteEventCallBack</span><span class="params">(EventCallBack cb)</span> </span>&#123; _writeEventCallBack = <span class="built_in">std</span>::move(cb);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把事件分发给具体的事件处理函数，它就是一个 Event Handler</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 epoll instance 关注 指定 事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">monitorReading</span><span class="params">()</span> </span>&#123; _waitEvents |= kReadEvent; update(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">monitorWriting</span><span class="params">()</span> </span>&#123; _waitEvents |= kWriteEvent; update(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kNoneEvent; <span class="comment">// 无任何 IO event</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kReadEvent; <span class="comment">// 可读 事件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kWriteEvent;<span class="comment">// 可写 事件</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将事件注册到 epoll instance 中去</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *_pLoop;</span><br><span class="line">    <span class="keyword">int</span> _fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> _waitEvents; <span class="comment">// 等待发生的事件</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _occurEvents; <span class="comment">// 已发生的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Concrete Event Handler</span></span><br><span class="line">    EventCallBack _readEventCallBack;</span><br><span class="line">    EventCallBack _writeEventCallBack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就是一个简单易用的 Reactor 模式的 C++ 实现。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>Schmidt, D.C. (1995). Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events</li><li><a href="https://www.cnblogs.com/coding-diary/archive/2019/09/08/11484473.html">Reactor 模式</a></li><li><a href="https://www.jianshu.com/p/01f3fb1d4cb5">使用C++实现简单的Reactor模式</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;用-C-实现一个简单的-Reactor-模式&quot;&gt;&lt;a href=&quot;#用-C-实现一个简单的-Reactor-模式&quot; class=&quot;headerlink&quot; title=&quot;用 C++ 实现一个简单的 Reactor 模式&quot;&gt;&lt;/a&gt;用 C++ 实现一个简单的 Reac</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>异步日志系统设计</title>
    <link href="https://codroc.github.io/2021/11/17/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://codroc.github.io/2021/11/17/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-16T16:00:00.000Z</published>
    <updated>2021-11-23T11:18:40.514Z</updated>
    
    <content type="html"><![CDATA[<p><strong>日志系统设计：</strong></p><p>为什么要自己写一个日志系统？</p><p>因为，网上的日志系统功能十分丰富，而有许多功能在我的项目或未来的项目中是不必要的。尤其是我试用过 spdlog 之后，更加确定了要自己写一个简单的日志系统，spdlog 的确，使用起来十分方便，只要包含头文件的就能用了，但是由于它的引入，编译时间却大大增加了，这大大降低了我的开发效率。。。</p><p>需要实现哪些功能？</p><ol><li>支持日志级别输出：TRACE, INFO, DEBUG, WARN，ERROR，FATAL</li><li>支持控制台和文件做为输出目标</li><li>支持日志滚动（rolling）</li><li>支持多线程</li><li>高性能（由于设计简单，那么就要把性能做到极致），现在好点的固态硬盘读写一般都在 500 MB/s 上下，<strong>最好</strong>日志系统的性能能够到达瞬时写满这个带宽，现在一般日志系统的瓶颈都不在磁盘这了~~。假设一条日志占 100 字节，那么至少要达到每秒写 200 万 条数据的能力（或每条日志 500 ns）。</li><li>用户友好</li></ol><hr><p><strong>如何设计 Roll File 机制？</strong></p><p>其实本质就是当 日志文件 大小 超过设定阈值时，换一个文件写入。说来简单，但是需要考虑，是否需要对原来的日志文件压缩打包，并重命名呢？对于压缩打包和重命名，可以另写一个脚本，在每次 Roll File 时，通过 c++ 去执行这个脚本。</p><p>经过测试后，<strong>结果不尽人意！</strong></p><p>我的实现是：日志后端线程 在 做落盘动作 之前，检查 文件大小 是否即将超过阈值，如果是，则要去 roll file。而 roll file 是通过 日志后端线程 fork 一个子进程来执行 一个 python 脚本 去做 一系列（解压缩日志包，对旧的日志文件重命名，再重新打包压缩）操作。这会导致 后端线程 阻塞等待 脚本完成所有操作。在这段等待的时间内，如果 前端日志量很大，就会导致 后端 Buffer 不够用，那么就会产生大量的 内存分配（分配新的 Buffer） 操作。<strong>最终的结果就是：日志系统在 开启 多个线程时，性能颠簸（thrashing）很大。（见性能分析）</strong></p><p>除此之外，我通过 <code>strace -c loggerTest</code> 发现竟然 futex 占用了 90%+ 的时间。。。这也不知道是为啥？难道就是单纯的 lock contention 导致的？</p><hr><p><strong>如何达到高性能？需要考虑以下几点：</strong></p><ul><li>使用 <strong>直写</strong> 还是 <strong>写回</strong> ？这是在 日志 落盘时 需要考虑的问题。</li><li>日志格式是否可以在 RUN-TIME 修改？</li><li>是否必须实现 异步日志？</li><li>如何查看 日志系统 瓶颈所在？</li></ul><ol><li><p>对于落盘方式是使用 <strong>直写</strong> 还是 <strong>写回</strong> 是很明显的，直写会大量涉及 磁盘IO，严重降低性能，所以采用写回策略。</p><p>写回策略：</p></li></ol><p>​    为了追求高性能，那就不能每写一条日志就落盘，众所周知 磁盘 IO 的速度是很慢的；也不能为了追求性能而迟迟不将日志落盘，这样一旦 日志系统 crash 就会丢失所有日志。</p><p>​    参考 Redis 中三种写回策略：<strong>Always, Everysec 以及 No（由 OS 决定何时写回）</strong>。为了兼顾性能和减少日志数据丢失问题，可以设计成<strong>每隔 3 s 写回一次</strong>。</p><ol start="2"><li><p>关于日志格式的问题，在其他的 日志库 实现中，一般都是可以在 RUN-TIME 修改 日志格式 的，但是我认为在我 目前使用日志的环境中，无需做这个功能，用统一的格式已经很简洁明了了。如果未来想要换个格式，重写下 日志制作 的相关模块就行了。</p><p>日志格式不变，那么制作日志时，也就具有较好的局部性了，自然不会出现在切换日志格式时的性能 <strong>颠簸</strong> （thrashing）。</p></li><li><p>为了不让 worker 线程阻塞在 磁盘 IO 上，就应该设计成 异步日志，worker 只需要异步调用一个 flush 函数，就会有另一个 专门用于 日志落盘的 线程 来接收 worker 产生的日志，并在合适时机 落盘。</p></li><li><p>异步日志系统的瓶颈，目前只知道用 strace 去查看用了哪些耗时的系统调用。。。。</p></li></ol><hr><p><strong>如何实现对用户友好？</strong></p><ul><li>输出格式友好</li><li>文件命名友好</li><li>接口友好</li></ul><p><strong>输出格式：</strong> 参考 muduo 的日志输出格式，统一为 <code>日期 时间 线程id 日志级别 源文件名:行号 - 正文</code>，例如</p><p><em>20210603 08:02:46.125770Z 23261 INFO Hello - test.cpp:51</em></p><p><em>20210603 08:02:46.126789Z 23261 WARN World - test.cpp:52</em></p><p><strong>文件命名：</strong> 参照 muduo 的格式，统一为 <code>程序名.日期.进程id.log</code></p><p><strong>接口友好：</strong> 按照流的方式进行输出，例如 <code>LOG_INFO &lt;&lt; &quot;TEST\n&quot;</code></p><hr><p><strong>具体实现：</strong></p><p>日志系统分成前后端，前端制作日志并发送给后端，后端把日志写到目的地（可以是控制台或文件）。</p><p><em>前端设计</em></p><p>​    前端制作完一条日志后是否立即发送给后端？最好不要，由于设计成异步发送，因此每一次发送都会 wakeup 一次后端线程，wakeup 频率太高也会降低系统性能。可以按批次 batch 发，给前端设置一个 Buffer 用于缓存已经制作完成的日志，当缓存满的时候再发送给后端。当然你说在后端也存在个 Buffer 就不需要每次 wakeup 后端线程了，但是多个前端线程频繁争用一个 <strong>后端 Buffer</strong> 也会导致性能下降，因此在前端用缓存在理论上是能减少竞争从而提高性能的。</p><p>​    系统向用户展示的接口是使用 <strong>流</strong> 的方式写日志的，每个 <strong>流</strong> 底层实现其实就是 <strong>Buffer</strong>。由于系统支持多线程，假设前端只有一个 Buffer 用于制作日志，那就会导致多个线程争夺一个 Buffer，这里存在 lock contention，考虑到 日志 产生的频率是比较高的，因此 contention 比较大。</p><p>​    可以设计成，每一个前端线程拥有一个独自的 <strong>流</strong>，这就避免了缓冲时的 race condition。<strong>当然这样设计的性能具体如何还需要验证！</strong>因为磁盘只有一个，最终的落盘操作总是串行执行的！（经过测试发现，性能与线程 能够接近于 1:1 线性相关）</p><p>​    相比较于 muduo，**本日志系统的改进 **是使用全局 logger 避免每制作一条日志都需要 产生 logger 临时对象，进而带来构造析构的开销，除此之外，muduo 是每产生一条日志都会被 push 到日志后端 Buffer 中，这会导致前端线程频繁争用 <strong>后端 Buffer</strong> 带来大量的 lock contention。至于全局的 logger 如何析构，可以添加一个 static 函数 release 来释放 logger 资源，让 LoggerWatcher 负责调用 Logger::release，这样在 release 中还能刷新以下缓冲，不至于 丢失日志。</p><blockquote><p>注意：日志后端一定要先于日志前端 构造，这样日志系统退出时，前端先退出，就会把前端 Buffer 中的日志刷新到 后端 Buffer 然后 append 到目的地。反之将会丢失前端的日志数据！</p></blockquote><p><em>后端设计</em></p><p>​    这里的关键就在于，<strong>如何做好日志系统的前后端交互。</strong> </p><p>​    如何把日志前端缓冲的数据传递给日志后端？阻塞队列可以做到，如果实现成，多个前端线程写日志，只有一个阻塞队列，那么就会产生明显的 lock contention 问题，该问题会随着每秒日志量的增大而变得明显起来；当然如果日志量小，自动触发 3 s 一刷新机制，那么 lock contention 占用的时间与 3 s 对比起来可能会不明显。也可以使用共享 Buffer，前端把日志全部往一个缓冲区写，后端读这个缓冲区，一样，lock contention 依然存在。。。。（经过测试，strace 显示的确会产生大量的 futex 调用）</p><p>​    目前设计为，通过前后端 共享一个 Buffer 的方式来实现交互。也就是说，前端产生的日志会 刷新到 后端 Buffer 中，而后端 也会在 合适的时机 将 Buffer 中的内容 落盘，这就需要加锁了！所以必然产生 critical section，而重点便是 让 critical section 执行时间越少越好。因此一些 内存分配或回收 必然不能在这里做了！具体的实现是，提前分配好 Buffer 以及备用的 Buffer，在 critical section 通过 swap 来交换已经占满的 Buffer 与 备用 Buffer，然后快速地走出 critical section，让前端能够及时拿到锁。</p><p>​    目前的实现，roll file 也是通过 日志后端线程 fork 出一个 子进程 去执行脚本实现的，这会使得 后端线程被阻塞而无法及时 分配/回收 内存，而需要前端自己去 分配内存，最终导致 日志系统性能颠簸（thrashing）。</p><hr><p><strong>性能分析：</strong></p><p>在 8 核 （Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz）虚拟机上，进行多线程 日志系统 性能分析；<strong>一个后端线程 + 一个主线程 + 多个前端线程</strong> 的结构，因为只有 8 个核，因此只测试 1~6 个前端线程的情况：</p><p>(1 thread)  Average of throughput: 217.811256 MB/s</p><p>(2 threads) Average of throughput: 425.770968 MB/s</p><p>(3 threads) Average of throughput: 605.174501 MB/s</p><p>(4 threads) Average of throughput: 768.463506 MB/s</p><p>这里展开 看一下，可以看到 性能 颠簸 很大！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">average time: 839.454355 MB/s #</span><br><span class="line">average time: 827.472073 MB/s #</span><br><span class="line">average time: 771.604938 MB/s</span><br><span class="line">average time: 633.713561 MB/s</span><br><span class="line">average time: 806.126562 MB/s #</span><br><span class="line">average time: 803.212851 MB/s #</span><br><span class="line">average time: 782.932081 MB/s</span><br><span class="line">average time: 803.535556 MB/s #</span><br><span class="line">average time: 775.644755 MB/s</span><br><span class="line">average time: 740.740741 MB/s</span><br><span class="line">average time: 812.017864 MB/s #</span><br><span class="line">average time: 811.688312 MB/s #</span><br><span class="line">average time: 834.376304 MB/s #</span><br><span class="line">average time: 794.438928 MB/s</span><br><span class="line">average time: 741.702207 MB/s</span><br><span class="line">average time: 768.935025 MB/s</span><br><span class="line">average time: 768.787238 MB/s</span><br><span class="line">average time: 793.808295 MB/s #</span><br><span class="line">average time: 700.157535 MB/s </span><br><span class="line">average time: 742.528309 MB/s</span><br></pre></td></tr></table></figure><p>(5 threads) Average of throughput: 949.295990 MB/s</p><p>(6 threads) Average of throughput: 1054.405436 MB/s</p><p>可以看到随着线程数的增加，性能增长在变慢，这是因为 <strong>激烈的 lock contention 以及 内存分配开销</strong> 造成的。</p><p><strong>可以改进的地方：</strong></p><ol><li><p>增加一个 emptyBuffers，buffer 被填满时，从中获取空闲 buffer，减少内存分配带来的开销。参考 muduo P120 图5-5；但是我实现了之后还没有原来的快。。。不知道是不是我的问题~~~~</p></li><li><p>改进 前后端交互接口，实现一个 lock contention 较少的方法。也可以参考 muduo P120 的想法。待实现。。。（由于 日志系统 很难成为项目中的瓶颈，所以现在还没必要 去费尽心思 设计一个 接近 无锁 的数据结构，以后有需要再说吧，哎~~~~）</p></li><li><p>由于日志的输出格式是 <code>日期 时间 线程id 日志级别 源文件名:行号 - 正文</code>，而 源文件名:行号 放在正文前将会导致 整个日志看起来不整齐，但是由于日志系统不依赖于临时对象，所以这一点比较难处理。。。</p></li><li><p>LOG_FATAL 的功能还没实现，即输出完后立即 结束进程。</p></li></ol><hr><p><strong>日志系统调用接口说明：</strong></p><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p><strong>Multi-threaded asynchronous log library</strong></p><p>If appender is the stdout:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;flog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If appender is a file:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;flog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncLogInit <span class="built_in">log</span>; <span class="comment">// initial async log.</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;++i)</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">log</span>.destroy(); <span class="comment">// AsyncLogInit::destroy must be called before exit!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;日志系统设计：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么要自己写一个日志系统？&lt;/p&gt;
&lt;p&gt;因为，网上的日志系统功能十分丰富，而有许多功能在我的项目或未来的项目中是不必要的。尤其是我试用过 spdlog 之后，更加确定了要自己写一个简单的日志系统，spdlo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于 gettimeofday 是否真的不涉及到系统调用进行记录</title>
    <link href="https://codroc.github.io/2021/11/08/%E5%85%B3%E4%BA%8Egettimeofday%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%B6%89%E5%8F%8A%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%9B%E8%A1%8C%E8%AE%B0%E5%BD%95/"/>
    <id>https://codroc.github.io/2021/11/08/%E5%85%B3%E4%BA%8Egettimeofday%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%B6%89%E5%8F%8A%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%9B%E8%A1%8C%E8%AE%B0%E5%BD%95/</id>
    <published>2021-11-07T16:00:00.000Z</published>
    <updated>2021-11-09T01:47:25.373Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于-gettimeofday-是否真的不涉及到系统调用进行记录"><a href="#关于-gettimeofday-是否真的不涉及到系统调用进行记录" class="headerlink" title="关于 gettimeofday 是否真的不涉及到系统调用进行记录"></a>关于 gettimeofday 是否真的不涉及到系统调用进行记录</h4><p>在《Linux多线程服务端编程》一书 5.1 节中提到过，在 x86-64 的 Linux 上，<code>gettimeofday</code> 不是系统调用，不会陷入内核。其实我是对这句话存有疑问的。众所周知想要获得准确的当前时间，就必须要通过内核的全局的计时变量（ticks 或者 jiffies），但是用 strace 查看调用了 <code>gettimeofday</code> 的进程，发现的确没有涉及到系统调用，没有陷入内核。这就奇了怪了，故上网查找，得到以下信息：</p><p>首先， <code>gettimeofday</code> 的确是一个系统调用，因为它所需求的数据是内核所持有的，但它没有走传统的 trap 这条路进入内核，而是利用了 linux 的 vdso（virtual dynamic shared object）机制帮我们做到了在调用这个系统调用时不陷入内核，从而提高了性能。</p><p>这个实现方法其实也是很直觉的（intuitive），在程序装载阶段，装载程序观察到程序有需要 vdso 的相关系统调用，就为其做一下内存映射（将对应的系统调用处理函数所需的指令和数据映射到用户空间中去）。那么用户在调用这些函数时自然就不需要陷入内核啦~~</p><p>如何调用到这些代码呢？直接调用这些系统调用对应的 glibc 包装函数就可以，因为这些 glibc 包装函数默认会使用 vdso。<strong>如果你执意通过 <code>syscall</code> 函数/ <code>syscall</code> 指令/<code>int 0x80</code> 来调用这些系统调用，vdso 是无法生效的，还是会陷入内核。</strong></p><p>当然 vdso 也不保证一定不会陷入内核，有些情况下是会 fallback 的，以 <code>clock_gettime</code> 为例，下面是 linux 4.16 版本中该系统调用在 vdso 中的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">notrace <span class="keyword">int</span> __vdso_clock_gettime(<span class="keyword">clockid_t</span> clock, struct timespec *ts)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">switch</span> (clock) &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">case</span> CLOCK_REALTIME:</span><br><span class="line"><span class="keyword">if</span> (do_realtime(ts) == VCLOCK_NONE)</span><br><span class="line"><span class="keyword">goto</span> fallback;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CLOCK_MONOTONIC:</span><br><span class="line"><span class="keyword">if</span> (do_monotonic(ts) == VCLOCK_NONE)</span><br><span class="line"><span class="keyword">goto</span> fallback;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CLOCK_REALTIME_COARSE:</span><br><span class="line">do_realtime_coarse(ts);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CLOCK_MONOTONIC_COARSE:</span><br><span class="line">do_monotonic_coarse(ts);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">goto</span> fallback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fallback:</span><br><span class="line"><span class="keyword">return</span> vdso_fallback_gettime(clock, ts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>do_realtime</code>和<code>do_monotonic</code>如果返回值为<code>VCLOCK_NONE</code>的话，就会调用<code>vdso_fallback_gettime</code>，而这个函数是会陷入内核的。另外，<code>clock_gettime</code>的<code>clock</code>参数可不止上面代码中switch里面的4个case，如果我们传入的是<code>CLOCK_BOOTTIME</code>/<code>CLOCK_PROCESS_CPUTIME_ID</code>/<code>CLOCK_THREAD_CPUTIME_ID</code>的话，就会走到default分支，还是会调用<code>vdso_fallback_gettime</code>陷入内核。</p><p>综上所诉，<code>gettimeofday</code>和<code>clock_gettime</code>实际上都是系统调用，但是调用得当的话，可以避免陷入内核，从而提高性能。是否陷入了内核，可以利用 strace 来判断。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li><a href="https://www.i4k.xyz/article/imred/100064061">gettimeofday和clock_gettime是不是系统调用?</a></li><li>muduo</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;关于-gettimeofday-是否真的不涉及到系统调用进行记录&quot;&gt;&lt;a href=&quot;#关于-gettimeofday-是否真的不涉及到系统调用进行记录&quot; class=&quot;headerlink&quot; title=&quot;关于 gettimeofday 是否真的不涉及到系统调用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo 博客移植到别的服务器上</title>
    <link href="https://codroc.github.io/2021/11/08/hexo%E5%8D%9A%E5%AE%A2%E7%A7%BB%E6%A4%8D%E5%88%B0%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
    <id>https://codroc.github.io/2021/11/08/hexo%E5%8D%9A%E5%AE%A2%E7%A7%BB%E6%A4%8D%E5%88%B0%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</id>
    <published>2021-11-07T16:00:00.000Z</published>
    <updated>2021-11-09T01:44:22.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hexo-博客移植到别的服务器上"><a href="#hexo-博客移植到别的服务器上" class="headerlink" title="hexo 博客移植到别的服务器上"></a>hexo 博客移植到别的服务器上</h3><p><strong>1. 将你原来电脑上已经配置好并生成的 hexo 目录拷到你的新电脑上</strong></p><p><strong>2. 在你的新电脑上首先配置 hexo 环境：安装 Node.js</strong></p><p><strong>3. 安装 hexo，执行命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p><strong>4. 安装好之后，进入之前拷贝来的 <code>hexo/source_code/blog</code> 目录</strong></p><p><strong>5. 模块安装，执行命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p><strong>6. 部署，执行命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;hexo-博客移植到别的服务器上&quot;&gt;&lt;a href=&quot;#hexo-博客移植到别的服务器上&quot; class=&quot;headerlink&quot; title=&quot;hexo 博客移植到别的服务器上&quot;&gt;&lt;/a&gt;hexo 博客移植到别的服务器上&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1. 将你原</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为什么 诊断日志（diagnostic log）需要 滚动（rolling） ？</title>
    <link href="https://codroc.github.io/2021/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%8A%E6%96%AD%E6%97%A5%E5%BF%97%E9%9C%80%E8%A6%81%E6%BB%9A%E5%8A%A8/"/>
    <id>https://codroc.github.io/2021/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%8A%E6%96%AD%E6%97%A5%E5%BF%97%E9%9C%80%E8%A6%81%E6%BB%9A%E5%8A%A8/</id>
    <published>2021-11-07T16:00:00.000Z</published>
    <updated>2021-11-09T01:50:10.786Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么-诊断日志（diagnostic-log）需要-滚动（rolling）-？"><a href="#为什么-诊断日志（diagnostic-log）需要-滚动（rolling）-？" class="headerlink" title="为什么 诊断日志（diagnostic log）需要 滚动（rolling） ？"></a>为什么 诊断日志（diagnostic log）需要 滚动（rolling） ？</h4><p>日志分为 诊断日志（diagnostic log）和交易日志或事务日志（transaction log）</p><p>前者用于系统软件的信息输出，告知维护人员系统目前的状态等等；后者用于维护数据一致性，常用于文件系统和数据库系统中。</p><p><strong>不滚动带来的影响：</strong></p><p>​    1. 最直接的影响就是，日志文件不断增大，对其操作（例如 append）所花费的时间也会线性增加。文件越大，通过 inode 索引到具体的 disk block 就需要更久的时间，因为后面需要多次索引（多级索引）才能找到那个具体的 disk block，而多次索引则意味着多次读盘。</p><p>​    2. 文件越来越大，占用大量磁盘空间，最终导致无磁盘空间可用。</p><p>​    3. 想要找到具体某一天的所有日志将会十分麻烦。</p><p><strong>滚动带来的好处：</strong></p><p>​    假设 日志文件 每超过 1G 或 每过一天 则进行滚动，那么它将会</p><ol><li><p>最直接的好处就是，方便你查找具体某一天所记录的所有日志。因为我可以按日期来为日志文件命名。</p></li><li><p>由于文件不大，索引起来也会相对快许多。</p></li><li><p>当日志文件超过一定数目时，自动丢弃过旧的日志。在日志滚动的过程中，活动日志会以一个新名称命名，例如 log.1，之前被命名为 log.1 的文件则会被重命名为 log.2，依此类推。在这一组文件中，最旧的日志文件（假如名为 log.7）会从系统中删除。</p></li><li><p>由于日志文件之间进行了分离，那么对那些旧的日志可以进行统一归档处理。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls  /var/log/</span><br><span class="line">log.1</span><br><span class="line">log.2.gz # 经过 tar 归档压缩后的文件</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;为什么-诊断日志（diagnostic-log）需要-滚动（rolling）-？&quot;&gt;&lt;a href=&quot;#为什么-诊断日志（diagnostic-log）需要-滚动（rolling）-？&quot; class=&quot;headerlink&quot; title=&quot;为什么 诊断日志（dia</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为什么采用线程池方案？</title>
    <link href="https://codroc.github.io/2021/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%96%B9%E6%A1%88%EF%BC%9F/"/>
    <id>https://codroc.github.io/2021/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%96%B9%E6%A1%88%EF%BC%9F/</id>
    <published>2021-11-07T16:00:00.000Z</published>
    <updated>2021-11-09T01:46:31.444Z</updated>
    
    <content type="html"><![CDATA[<h5 id="为什么采用线程池方案？"><a href="#为什么采用线程池方案？" class="headerlink" title="为什么采用线程池方案？"></a>为什么采用线程池方案？</h5><ol><li>采用线程池方案其实就是采用 <strong>单进程多线程</strong> 模式。它能有效利用 <strong>多核资源</strong> 提高吞吐量（qps）。</li><li>能有效降低 <strong>优先级反转</strong> 出现的概率。比如有两个计算任务，task1 需要花 1 ms，task2 需要花 20 ms，根据 <strong>短任务优先原则</strong> 应该先让 task1 使用 CPU；如果是在单线程情况下，task2 事件先到，那么它就会占用 CPU，直到计算完毕才会让出给 task1，这样 task1 的响应时间为 21 ms（有人会说那可以多个单线程进程呀，利用 OS 调度进程来让 task1 得到执行。如果这两个任务是需要共享一些数据的话，IPC 将会十分麻烦，而多线程则在共享数据方面比较简单），task2 的响应时间为 20 ms；如果采用多线程，就算 task1 事件后发生，它也会被分配到空闲的计算线程中去，这样，task1 的响应时间为 1 ms，task2 的响应时间为 20 ms，平均则为 10.5 ms，大大降低了平均响应时间。</li><li>当然，决定了使用多线程，那么自然就可以用线程池来减少线程重复创建销毁所带来的开销。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;为什么采用线程池方案？&quot;&gt;&lt;a href=&quot;#为什么采用线程池方案？&quot; class=&quot;headerlink&quot; title=&quot;为什么采用线程池方案？&quot;&gt;&lt;/a&gt;为什么采用线程池方案？&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;采用线程池方案其实就是采用 &lt;strong&gt;单进程多线程</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT 6.s081 2020 Lab8 Parallelism/locking</title>
    <link href="https://codroc.github.io/2021/11/01/lab8locks/"/>
    <id>https://codroc.github.io/2021/11/01/lab8locks/</id>
    <published>2021-10-31T16:00:00.000Z</published>
    <updated>2021-11-09T03:50:52.179Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lab-8-locks"><a href="#Lab-8-locks" class="headerlink" title="Lab 8: locks"></a>Lab 8: locks</h3><p>这一章实验虽然简单，但是要想真正将锁运用自如那是非常难的。</p><blockquote><p>并行与并发：这两个术语是针对任务推进或者进程执行而言的。并行是指在某一<strong>时刻</strong>多个任务得到推进；而并发是指在<strong>某一时间段内</strong>多个任务得到推进；并行需要物理多核，而并发是通过时间片轮转的方式在单核上实现的</p></blockquote><blockquote><p>race condition 的定义：一块内存地址被并行地访问，且至少有一个访问是写操作，此时 race condition 成立</p></blockquote><blockquote><p>concurrency 的定义：指多条指令流交织的情况。多处理器并行执行，线程切换，中断都可以导致 concurrency</p></blockquote><blockquote><p>数据结构的不变性（invariants）条件：Data structure invariants are properties that the data structures in a program must satisfy in valid states</p></blockquote><p>​    concurrency 会带来 race condition，导致程序无法正确执行或共享数据结构遭到破坏，因此需要并发控制技术（Concurrency Control Techniques，CCT）来 avoid race condition</p><p>​    使用的最广泛的 CCT 自然就是锁了。锁是容易理解的，锁的作用其实就是保证了 invariants of data struct，但是如果使用不当会导致程序性能下降。</p><h3 id="spinlock-与-sleeplock"><a href="#spinlock-与-sleeplock" class="headerlink" title="spinlock 与 sleeplock"></a>spinlock 与 sleeplock</h3><h3 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h3><p>​    本质上，锁的竞争会导致程序性能的下降，而本实验的第一部分就是对 freelist 进行重新设计来避免大量的锁竞争。这一部分实验也启示我们可以根据 lock contention 的情况来判断自己的多线程程序是否在锁的这一方面设计不当。</p><p>​    原来的 xv6 在 freelist 的设计上是这样的：只有一个 freelist 全局数据结构，通过一把锁来实现线程安全，由于 xv6 是 multi-processor 的，在分配内存和释放内存时每个 CPU 都会去尝试获得锁，这就导致了锁的竞争。</p><p>​    我们可以将 freelist 设计成，每一个 CPU 都持有一个 freelist，这样当 CPU 去分配获释放内存时，只需要持有自己的锁而不需要去竞争其他 CPU 的锁，这就大大降低了 lock contention，提高了程序的并发性。但是这里需要考虑一个问题，那就是当某一个 CPU 的 freelist 空了，但其他 CPU 的 freelist 中还是有空闲页的，此时就应该从其他 CPU 的 freelist 中 steal 一个空闲页，这里就要涉及到其他 CPU 的锁了！</p><p>​    由于这一部分代码实现很简单就不做过多介绍了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kernel/kalloc.c:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="keyword">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="keyword">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kmem</span> *<span class="title">kmem</span>;</span><span class="comment">// 增加一个 kmem 字段，指向 CPU 自己的空闲链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">kernel/kalloc.c:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU]; <span class="comment">// 为每一个 CPU 都分配一个 空闲列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kinit()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NCPU;++i) &#123;<span class="comment">// 为每一把锁都进行初始化</span></span><br><span class="line">      <span class="keyword">char</span> lockname[] = <span class="string">&quot;kmem_i&quot;</span>;</span><br><span class="line">      lockname[<span class="number">5</span>] = <span class="string">&#x27;0&#x27;</span> + i;</span><br><span class="line">      cpus[i].kmem = kmem + i;</span><br><span class="line">      initlock(&amp;(cpus[i].kmem-&gt;lock), lockname);</span><br><span class="line">  &#125;</span><br><span class="line">  freerange(end, (<span class="keyword">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kfree(<span class="keyword">void</span> *pa)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// my code:// 根据当前 CPU 来对自己的 freelist 进行操作</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  acquire(&amp;c-&gt;kmem-&gt;lock);</span><br><span class="line">  r-&gt;next = c-&gt;kmem-&gt;freelist;</span><br><span class="line">  c-&gt;kmem-&gt;freelist = r;</span><br><span class="line">  release(&amp;c-&gt;kmem-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">kalloc(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  acquire(&amp;c-&gt;kmem-&gt;lock);</span><br><span class="line">  r = c-&gt;kmem-&gt;freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    c-&gt;kmem-&gt;freelist = r-&gt;next;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">// 去别的 cpu 的freelist上 steal</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NCPU;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;cpus[i] == c)   <span class="keyword">continue</span>;<span class="comment">// 跳过自己</span></span><br><span class="line">        acquire(&amp;cpus[i].kmem-&gt;lock);</span><br><span class="line">        r = cpus[i].kmem-&gt;freelist;</span><br><span class="line">        <span class="keyword">if</span> (r) &#123;<span class="comment">// 找到空闲的页</span></span><br><span class="line">            cpus[i].kmem-&gt;freelist = r-&gt;next;</span><br><span class="line">            release(&amp;cpus[i].kmem-&gt;lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;cpus[i].kmem-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;c-&gt;kmem-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h3><p>​    这一部分也是为了减少锁的竞争，但是是对 Buffer cache 的锁而言的。它就不能像前面对于 freelist 而言只需要为每一个 CPU 都维护一个 freelist 那么简单了。</p><p>​    其实是存在优化空间的，原来的实现是不管对哪一个 Buffer 进行操作，都要进行加锁，我们可以改成 为每一个 Buffer 都有自己对应的锁，具体操作哪一个 Buffer 时对其对应的锁进行加锁。</p><p>​    我们可以使用 哈希表 来做 <strong>逻辑块号</strong> 到 <strong>Buffer 对应锁</strong> 之间的映射。因此我们初始化哈希表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel/bio.c:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">bcache_locks</span>[31];</span> <span class="comment">// 最好用质数来减少 hash 冲突。</span></span><br></pre></td></tr></table></figure><p>​    由于在原来的设计中，LRU 策略是通过双向链表来实现的，对链表的操作相当于要在全局加一把锁来实现原子性以保证 invariants，这样的话又会带来巨大的 lock contention，因此我们将 LRU 策略的实现改一下：在 buf 结构体中增加一个 ticks 变量来记录最近一次 Buffer 使用的时间，在 brelse 中更新这个时间，用于 LRU 策略，因此在缓存替换时，我们只要遍历一遍未使用的 Buffer 中 ticks 最小的那个缓存，将其替换即可。因此我们就不需要双向链表了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kernel/bio.c:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="comment">// struct buf head;</span></span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line">kernel/buf.h:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">···</span><br><span class="line">  <span class="comment">// struct buf *prev; // LRU cache list</span></span><br><span class="line">  <span class="comment">// struct buf *next;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">  uint64 ticks;<span class="comment">// 用 ticks 来实现 LRU</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    有了这么多锁，自然要初始化他们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">kernel/bio.c:</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">binit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">31</span>;++i) &#123;</span><br><span class="line">      <span class="keyword">char</span> lock_name[] = <span class="string">&quot;bcache0&quot;</span>;</span><br><span class="line">      lock_name[<span class="number">6</span>] = <span class="string">&#x27;0&#x27;</span> + i;</span><br><span class="line">      initlock(&amp;bcache_locks[i], lock_name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  <span class="comment">// bcache.head.prev = &amp;bcache.head;</span></span><br><span class="line">  <span class="comment">// bcache.head.next = &amp;bcache.head;</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">  <span class="comment">//   b-&gt;next = bcache.head.next;</span></span><br><span class="line">  <span class="comment">//   b-&gt;prev = &amp;bcache.head;</span></span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">  <span class="comment">//   bcache.head.next-&gt;prev = b;</span></span><br><span class="line">  <span class="comment">//   bcache.head.next = b;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    对 bget 和 brelse 进行相应的改动：注意在 LRU 进行缓存替换的时候，一定要持有 bcache 的锁，因为这里只持有 对应逻辑块号的锁是无法保证线程安全的。假设 CPU0 和 CPU1 同时执行到 缓存替换这一行，都看到 Buffer1 是最近最久未使用的 Buffer，它们同时对其进行替换并返回，这就导致了两个文件对应一个 Buffer 的情况了，这肯定是会发生问题的！因此在做 缓存替换时，一定要加上 对 bcache 的锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">kernel/bio.c:</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>*</span></span><br><span class="line"><span class="class"><span class="title">bget</span>(<span class="title">uint</span> <span class="title">dev</span>, <span class="title">uint</span> <span class="title">blockno</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> *<span class="title">l</span> =</span> &amp;bcache_locks[blockno % <span class="number">31</span>];</span><br><span class="line">  acquire(l);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NBUF;++i) &#123;</span><br><span class="line">    b = &amp;bcache.buf[i];</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class="line">        b-&gt;refcnt++;</span><br><span class="line">        release(l);</span><br><span class="line">        acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  uint min_ticks = <span class="number">0x0fffffff</span>;</span><br><span class="line">  uint idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">  acquire(&amp;bcache.lock);<span class="comment">// 这里一定要持有一个 bcache 的锁，因为如果此时另一个 CPU 也执行到 缓存替换这一步，就会导致程序执行错误！</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NBUF;++i)&#123;</span><br><span class="line">    b = &amp;bcache.buf[i];</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;ticks &lt; min_ticks) &#123;</span><br><span class="line">      idx = i;</span><br><span class="line">      min_ticks = b-&gt;ticks;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">      b = &amp;bcache.buf[idx];</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      release(l);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Lab-8-locks&quot;&gt;&lt;a href=&quot;#Lab-8-locks&quot; class=&quot;headerlink&quot; title=&quot;Lab 8: locks&quot;&gt;&lt;/a&gt;Lab 8: locks&lt;/h3&gt;&lt;p&gt;这一章实验虽然简单，但是要想真正将锁运用自如那是非常难的。&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT 6.s081 2020 Lab6 Copy-on-write fork</title>
    <link href="https://codroc.github.io/2021/10/21/lab6cow/"/>
    <id>https://codroc.github.io/2021/10/21/lab6cow/</id>
    <published>2021-10-20T16:00:00.000Z</published>
    <updated>2021-11-09T03:50:46.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="copy-on-write"><a href="#copy-on-write" class="headerlink" title="copy-on-write"></a>copy-on-write</h3><p>​        COW 在我看 <strong>深入理解计算机系统</strong> 这本书的时候就已经接触过了，可惜那时后理解不深，现在做完 VM 相关的 3 个 lab 后，算是彻彻底底明白了。其实理解后感觉很自然很简单。</p><p>​        Fork 可以创建出一个子进程，并与父进程有一致的内存映像。在之前的实现中，xv6 是通过 uvmcopy 为子进程分配物理内存并作映射，然后将对应的父进程中的内存映像 memmove 到子进程对应内存中。</p><p>​        所以这里每次 Fork 的时候都是实实在在分配了物理内存的！所以这就引出了一个问题了？有必要实实在在得给子进程分配物理内存吗？</p><p>​        我觉得，没必要！</p><p>​        因为很多 Fork 后面接着是调用 exec 系统调用来装载新的可执行文件的 Section 进入内存中，那么在装载前，我们就需要先释放用户进程空间映射到的物理内存，这样一来，之前 fork 时分配的动作相当于做了无用功；</p><p>​        除此之外，由于 text section 是存放代码的节，在 fork 后，父子进程是可以共享同的，这样还能节省物理内存。data section 也可以被用来共享，在发生写操作时才有必要为写的那个进程去分配物理页。</p><p>​        由于我们不做物理内存的实际分配以及 memmove 而是仅仅建立了映射，整个的 Fork 的执行速度将会大大提升。</p><p>​        在真正需要某一物理页的时候（写某一页物理页时）再分配也不迟呀！</p><p>COW 很好地利用了异常机制，在 Fork 中将父子进程对应用户空间的 PTEs 中的写权限位（PTE_W）置 0，这样任意进程在写 PTE 对应的物理页时都会发生一个页异常，紧接着我们只要在 usertrap 中添加一个由 <strong>写权限为0</strong> 导致的页异常处理逻辑即可！</p><p>由于现在一个物理页可能由多个进程进行共享，因此在进程结束释放资源的时候，需要查看它所释放的物理页是否有别的进程在引用。我们的实现方法是增加一个为每一个物理页设置一个 reference count 来表明有多少进程引用了这个物理页。</p><p>现在整理一下实现 lab 的思路：</p><ul><li>定义一个全局数组来记录物理页引用计数：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rc[<span class="number">128</span>*<span class="number">1024</span>*<span class="number">1024</span> / PGSIZE]; <span class="comment">// 由于 virtio 板子可用的最大物理内存是 128M，所以最多 128M / 4K 页</span></span><br></pre></td></tr></table></figure><p>当一个物理页的 reference count = 0 时才进行真正的释放。</p><ul><li><p>在 <code>kalloc</code>中，被分配空闲页面的引用计数设为1。在 <code>kfree</code> 中，物理页的引用计数先减一，如果减一后 &lt;= 0（为什么是 &lt;= 而不是 = ？这是为初始化内存的时候准备的， <code>freerange</code> 会最新调用 <code>kfree</code> 一次），才会被加入空闲链表，减1和判&lt;=0必须整个是原子操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一段代码 加锁和解锁 是比较难理解的地方。</span></span><br><span class="line">kernel/kalloc.c:</span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kfree(<span class="keyword">void</span> *pa)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem.lock); <span class="comment">// 加锁</span></span><br><span class="line">  uint64 idx = ((uint64)pa - (uint64)PGROUNDUP((uint64)end)) / PGSIZE;</span><br><span class="line">  rc[idx]--;</span><br><span class="line">  <span class="keyword">if</span> (rc[idx] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      release(&amp;kmem.lock);<span class="comment">// 解锁</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  </span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>uvmcopy</code> 中不再实际分配内存而仅仅做映射，并对父进程的各个物理页的引用计数加一，同时父子两者的 PTEs 都要清除 Write 位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">uvmcopy(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="comment">// char *mem;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte) &amp; (~PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// set PTE_W to 0</span></span><br><span class="line">    *pte &amp;= ~PTE_W;</span><br><span class="line">    <span class="comment">// increament rc</span></span><br><span class="line">    uint64 idx = ((uint64)pa - (uint64)PGROUNDUP((uint64)end)) / PGSIZE;</span><br><span class="line">    acquire(&amp;kmem.lock); <span class="comment">// 这里一定要在修改共享资源之前加锁</span></span><br><span class="line">    rc[idx]++;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br></pre></td></tr></table></figure></li><li><p>改动 <code>usertrap</code> ，在一个 va 发生缺页异常时，尝试对它进行分配新的物理页并作映射和内容 copy，打开 PTE_W ，对原来所引用的物理页的引用计数 -1，如果失败了就走原来把它 kill 掉的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> kernel/trap.c:</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span></span><br><span class="line"> usertrap(<span class="keyword">void</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    ···</span><br><span class="line">syscall();</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// ok</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     uint64 cause = r_scause();</span><br><span class="line">     <span class="keyword">if</span> (cause == <span class="number">13</span> || cause == <span class="number">15</span>) &#123; <span class="comment">// 13 和 15 表示页异常，具体见 riscv 特权指令手册</span></span><br><span class="line">         uint64 va = r_stval(); <span class="comment">// 读取导致异常的那个虚拟地址</span></span><br><span class="line">         <span class="keyword">pte_t</span> *pte = walk(p-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">if</span> (pte == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span>) <span class="comment">// 如果是因为访问 stack guard page 导致的异常，就把进程 killed 掉</span></span><br><span class="line">             p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>) &#123; <span class="comment">// 如果是缺页异常；这个 lab 不会发生</span></span><br><span class="line">             <span class="comment">// lazy allocation, for now just kill it</span></span><br><span class="line">             p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_W) == <span class="number">0</span>) &#123; <span class="comment">// 如果是写物理页导致的页异常</span></span><br><span class="line">             <span class="keyword">char</span> *pa = (<span class="keyword">char</span> *)PTE2PA(*pte);</span><br><span class="line">             uint64 idx = ((uint64)pa - (uint64)PGROUNDUP((uint64)end)) / PGSIZE;</span><br><span class="line">             *pte |= PTE_W;</span><br><span class="line">             <span class="keyword">if</span> (rc[idx] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                 <span class="comment">// cow</span></span><br><span class="line">                 <span class="keyword">char</span> *mem = kalloc();</span><br><span class="line">                 <span class="keyword">if</span> (mem) &#123;</span><br><span class="line">                     memmove(mem, pa, PGSIZE);</span><br><span class="line">                     <span class="keyword">int</span> flags = PTE_FLAGS(*pte);</span><br><span class="line">                     *pte = PA2PTE(mem)|flags;</span><br><span class="line">                     <span class="comment">// decreament rc</span></span><br><span class="line">                     kfree((<span class="keyword">void</span>*)pa);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                     p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>copyout</code> 同 <code>usetrap</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">copyout(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">    uint64 idx = ((uint64)pa0 - (uint64)PGROUNDUP((uint64)end)) / PGSIZE;</span><br><span class="line">    <span class="keyword">if</span> (rc[idx] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 这一页是共享的，要重新分配一页进行修改</span></span><br><span class="line">        <span class="keyword">char</span> *mem = kalloc();</span><br><span class="line">        <span class="keyword">if</span> (mem) &#123;</span><br><span class="line">            <span class="keyword">pte_t</span> *pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">            *pte |= PTE_W;</span><br><span class="line">            memmove(mem, (<span class="keyword">void</span>*)pa0, PGSIZE);</span><br><span class="line">            <span class="keyword">int</span> flags = PTE_FLAGS(*pte);</span><br><span class="line">            *pte = PA2PTE(mem)|flags;</span><br><span class="line">            <span class="comment">// decreament rc</span></span><br><span class="line">            kfree((<span class="keyword">void</span>*)pa0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        n = PGSIZE - (dstva - va0);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">            n = len;</span><br><span class="line">        memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">  </span><br><span class="line">        len -= n;</span><br><span class="line">        src += n;</span><br><span class="line">        dstva = va0 + PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">err:</span><br><span class="line">  uvmunmap(pagetable, <span class="number">0</span>, (uint64)PGROUNDUP(p-&gt;sz) / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;copy-on-write&quot;&gt;&lt;a href=&quot;#copy-on-write&quot; class=&quot;headerlink&quot; title=&quot;copy-on-write&quot;&gt;&lt;/a&gt;copy-on-write&lt;/h3&gt;&lt;p&gt;​        COW 在我看 &lt;strong&gt;深</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT 6.s081 2020 Lab5 Lazy allocation</title>
    <link href="https://codroc.github.io/2021/10/19/lab5lazyAllocation/"/>
    <id>https://codroc.github.io/2021/10/19/lab5lazyAllocation/</id>
    <published>2021-10-18T16:00:00.000Z</published>
    <updated>2021-11-09T03:50:40.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lazy-Allocation"><a href="#Lazy-Allocation" class="headerlink" title="Lazy Allocation"></a>Lazy Allocation</h3><p>这一章讲的是<strong>懒分配</strong>。什么是懒分配呢？就是在用户通过 sbrk 向 OS 申请内存的时候，操作系统仅仅增加 p-&gt;sz （即虚拟内存大小）而不实际分配物理内存，直到用户访问那块未分配的物理内存导致<strong>页错误</strong>时，由异常处理程序来做实际的分配与映射，相当于<strong>把分配物理内存这件事推迟了！</strong></p><p>Lazy allocation 的好处：程序员过量申请内存，而实际使用的内存却很少的情况是十分常见的，使用懒分配就能很好的减少因这种情况导致的物理内存的浪费。</p><p>Lazy allocation 依赖于：缺页异常机制。这个异常是由硬件发现的！当 CPU 将虚拟地址 va 传递给 MMU 进行地址转换的时候，MMU 就会发现 va 对于的 PTE 的有效位为 0，则触发一个缺页异常。</p><p><strong>实现思路：</strong></p><ol><li>修改 sys_sbrk 系统调用函数，每次用户申请内存时就仅仅增加虚拟内存大小（即 p-&gt;sz）而不做实际物理内存分配。在用户释放内存的时候，去做释放物理内存以及解除映射的逻辑。</li><li>在 usertrap 中添加缺页异常处理逻辑。</li><li>在 fork 中会调用 uvmcopy 时，父进程的有些内存可能还没有做映射呢，所以也要对 uvmcopy 就行修改。</li><li>在进行 uvmunmap 的时候遇到无效页则跳过。</li></ol><p>这一章还是很简单的，没什么需要重点记录的。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Lazy-Allocation&quot;&gt;&lt;a href=&quot;#Lazy-Allocation&quot; class=&quot;headerlink&quot; title=&quot;Lazy Allocation&quot;&gt;&lt;/a&gt;Lazy Allocation&lt;/h3&gt;&lt;p&gt;这一章讲的是&lt;strong&gt;懒分配&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT 6.s081 2020 Lab4 Trap</title>
    <link href="https://codroc.github.io/2021/10/18/lab4interruptHandler/"/>
    <id>https://codroc.github.io/2021/10/18/lab4interruptHandler/</id>
    <published>2021-10-17T16:00:00.000Z</published>
    <updated>2021-11-09T03:50:32.231Z</updated>
    
    <content type="html"><![CDATA[<p>lab4 是 traps 相关</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>系统调用的时候发生了什么？例如 write()？</p><ol><li>保存 32 个用户寄存器以及 pc</li><li>切换到 supervisor 模式</li><li>切换到内核页表</li><li>切换到内核栈</li><li>跳到 C 代码处</li></ol><p><strong>不要在 supervisor 模式执行用户代码！</strong>我之前就是这个思路（如何在内核空间中执行用户代码），想了很久都没有答案，然后看了别人的解析才发现，原来思路错了！</p><p>在 supervisor 模式，多了哪些特权？</p><ol><li>supervisor 模式下能够使用 CPU 的控制状态寄存器：<ol><li>satp       – 保存了页表物理地址</li><li>stvec      – ecall 会跳转到该寄存器保存的地址处，即 TRAMPOLINE</li><li>sepc       – ecall 会将用户 pc 保存到 sepc 中</li><li>sscratch – 保存 trapframe 的地址</li></ol></li><li>supervisor 模式下能够使用没有 PTE_U 标志的 PTEs</li></ol><p>除此之外，supervisor 模式没有什么特别的了！它也不能访问不在其页表中的内容！</p><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p>添加一个 backtrace 函数，sys_sleep 调用这个函数后可以打印出函数调用栈</p><p><strong>实现思路：</strong></p><p>根据 RISCV ABI，ra 寄存器存放返回地址，sp 寄存器存放<strong>栈顶指针</strong>，s0 寄存器存放<strong>栈基指针</strong>。在 RISCV 上的汇编语言 ABI 规定，在开辟新的函数调用栈的时候，将上一个栈的 <strong>栈基指针</strong> 存到新的 <strong>栈基-16</strong> 处；将 ra 存放到新的 <strong>栈基-8</strong> 处。因此我们可以根据栈基指针遍历整个函数调用过程，直到 栈基指针 的值超过了内核栈。</p><p><strong>实现：</strong></p><p>这个实现还是很简单的。</p><p>首先我们要获取 <strong>栈基指针 s0：</strong>用 C 代码封装汇编指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel/riscv.h:</span><br><span class="line"></span><br><span class="line"><span class="comment">// my code:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line">r_fp()</span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span></span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后不断根据 栈基指针 来遍历内核栈即可，结束条件就是遍历超过一页时停止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kernel/<span class="built_in">printf</span>.c:</span><br><span class="line"></span><br><span class="line"><span class="comment">// my code:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">    uint64 fp = r_fp();</span><br><span class="line">    uint64 bottom = PGROUNDUP(fp), top = PGROUNDDOWN(fp);</span><br><span class="line">    <span class="keyword">while</span> (fp &lt; bottom &amp;&amp; fp &gt;= top) &#123; <span class="comment">// 只要 fp 超过了一页就结束</span></span><br><span class="line">        uint64 ra = *(uint64*)(fp - <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ra);</span><br><span class="line">        fp = *(uint64*)(fp - <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 sys_sleep 中调用就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kernel/sysproc.c:</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line">sys_sleep(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  backtrace();</span><br><span class="line">  <span class="comment">//////////////</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line">····</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>这个实验要我们实现一个定时器中断处理。</p><p>定时器中断是软中断，每过一个 ticks 都会触发定时器中断，即会从用户态陷入内核态处理定时器中断相关逻辑。</p><p>通过 sigalarm 系统调用来注册一个定时器中断（每隔多久执行以此中断处理函数）。添加系统调用的方式和 lab2 一样。这个注册是对应于某个具体进程的，因此需要在 struct proc 结构体中新添加几个字段来保存 <strong>间隔时间</strong> 和 <strong>中断处理函数虚拟地址</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">···</span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  uint64 alarm_interval; <span class="comment">// 中断时间间隔</span></span><br><span class="line">  fn handler;  <span class="comment">// 中断处理函数</span></span><br><span class="line">  uint64 ticks_left;  <span class="comment">// 还剩几个 ticks 就要触发中断</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，在 sys_sigalarm 中对当前申请注册中断处理的进程的结构体字段进行相应的填写，然后修改 trap.c/usertrap 中处理定时器中断的逻辑即可。</p><p>由于 系统调用、中断、异常都会将 TRAMPOLINE 作为内核的进入点，因此执行的是同一套逻辑，只是会根据 陷入内核的原因（scause 中的值）来区分到底是三类中的哪一类导致的 trap:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">···</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;···&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 scause == 8 则是系统调用，其他的则为中断或异常，可以根据 devintr() 的返回值来判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 if timer device,</span></span><br><span class="line"><span class="comment">// 1 if other device,</span></span><br><span class="line"><span class="comment">// 0 if not recognized.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">devintr()</span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// 外部中断</span></span><br><span class="line">    <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line">···</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// 定时器中断</span></span><br><span class="line">    <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">    <span class="comment">// forwarded by timervec in kernelvec.S.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们只要添加一个处理定时器中断的逻辑即可。</p><p>这里这个逻辑该怎么实现呢？我刚开始一直琢磨着如何在内核态去执行用户空间的代码，想到了建立进程内核页表（即 lab3 的内容），但是一想这实验应该不会涉及到前面的内容呀。。。然后实在没办法才看了下解析，看到别人的思路后恍然大悟。</p><p><strong>思路：</strong>用户陷入内核时把 pc 值存在了 sepc 中，然后在 TRAMPOLINE 中做了进程状态的保存（将 sepc 保存到 p-&gt;trapframe-&gt;sepc 中）进入 usertrap；随后必定要按原路返回，通过 usertrapret 进入 userret 恢复进程的寄存器状态，最后依赖  sepc 回到下一条地址处或原地址处。我们只要在定时器中断处理中，将 中断函数的地址赋值给 p-&gt;trapframe-&gt;sepc，然后一切就水到渠成了！</p><p>当然这样的话相当于打乱了原来用户空间栈中的执行顺序，因此在 中断处理函数 结尾处要调用相应的 sigreturn 系统调用来回到原来的状态。而这个 sigreturn 的功能也就明了了，无非就是在 定时器中断处理中 在修改 p-&gt;trapframe-&gt;sepc 之前对整个 trapframe 做个备份保存起来，在 sigreturn 中用备份恢复 trapframe 就可以了。</p><p>在 struct proc 中新增一个 trapframe 备份字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">···</span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  uint64 alarm_interval; <span class="comment">// 中断时间间隔</span></span><br><span class="line">  fn handler;  <span class="comment">// 中断处理函数</span></span><br><span class="line">  uint64 ticks_left;  <span class="comment">// 还剩几个 ticks 就要触发中断</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tmp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> inHandler;  <span class="comment">// 表示是否有进程正在进行中断函数处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 usertrap 的定时器中断中保存 trapframe 备份：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (which_dev == <span class="number">2</span>) <span class="comment">// 定时器中断</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (p-&gt;alarm_interval != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (p-&gt;ticks_left == <span class="number">1</span> &amp;&amp; p-&gt;inHandler == <span class="number">0</span>) &#123;</span><br><span class="line">                   p-&gt;inHandler = <span class="number">1</span>;</span><br><span class="line">                   *(p-&gt;tmp) = *(p-&gt;trapframe); <span class="comment">// copy saved user registers.</span></span><br><span class="line">                     p-&gt;ticks_left = p-&gt;alarm_interval;</span><br><span class="line">                     p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;</span><br><span class="line">               &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> (p-&gt;ticks_left == <span class="number">1</span>) <span class="comment">// it means p-&gt;inHandler == 1</span></span><br><span class="line">p-&gt;ticks_left = <span class="number">1</span>; <span class="comment">// 等着另一个进程从中断处理函数中出来</span></span><br><span class="line">                <span class="keyword">else</span> p-&gt;ticks_left--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;···&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 sigreturn 中恢复 trapframe：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel/sysproc.c:</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line">sys_sigreturn(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    *(p-&gt;trapframe) = *(p-&gt;tmp);</span><br><span class="line">    p-&gt;inHandler = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;lab4 是 traps 相关&lt;/p&gt;
&lt;h2 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h2&gt;&lt;p&gt;系统调用的时候发生了什么？例如 write()？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT 6.s081 2020 Lab3 Page tables</title>
    <link href="https://codroc.github.io/2021/10/11/lab3vm/"/>
    <id>https://codroc.github.io/2021/10/11/lab3vm/</id>
    <published>2021-10-10T16:00:00.000Z</published>
    <updated>2021-11-09T03:50:21.391Z</updated>
    
    <content type="html"><![CDATA[<p>这个实验是至今为止做的最难的一个了，做了估计有一礼拜。。。。主要的坑有两个，也是重要的知识点，下面会详细记录。</p><h4 id="为了方便在虚拟地址与物理地址之间的转换操作，做出以下宏定义："><a href="#为了方便在虚拟地址与物理地址之间的转换操作，做出以下宏定义：" class="headerlink" title="为了方便在虚拟地址与物理地址之间的转换操作，做出以下宏定义："></a>为了方便在虚拟地址与物理地址之间的转换操作，做出以下宏定义：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_U (1L <span class="meta-string">&lt;&lt; 4) // 1 -&gt; user can access</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF) <span class="comment">// PTE 前 10 位为标志位</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK) <span class="comment">// 找 PPN （level）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> uint64 <span class="keyword">pte_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="keyword">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p>现在的 OS 都有页表机制。因为这是解决进程间独立，提高安全性和可维护性的高效做法。</p><p><strong>页表机制是由软硬件共同实现的，</strong>这句话在之前就听说过，做了实验之后得到了深刻的理解。<strong>satp</strong> 这个寄存器就是实现分页机制最重要的一个寄存器。具体要去看 <a href="https://riscv.org/technical/specifications/">The RISC-V Instruction Set Manual<br>Volume II: Privileged Architecture</a> 对应章节。总之对于 Sv39 地址空间的 riscv64 实现，给出一个虚拟地址，硬件会根据 satp 来将其映射成物理地址，可以用公式 PA = F(satp, VA) 来表示：</p><p><img src="https://s3.bmp.ovh/imgs/2021/10/a1fa6276b549f90b.png" alt="分页机制过程"></p><p>这一步从虚拟地址到物理地址的地址转换是硬件帮我们完成的，那软件要做什么事呢？想一想，页表是需要人工创建出来的呀，所以软件就是在做创建页表并建立映射的工作。</p><h3 id="1-Print-a-page-table"><a href="#1-Print-a-page-table" class="headerlink" title="1. Print a page table"></a>1. Print a page table</h3><p>实验说明：写一个函数，实现打印页表的功能。</p><p>函数签名：void vmprint(pagetable_t pagetable);</p><p>只要仔细查看 39 位虚拟地址的结构以及 PTE（页表条目）的结构，再对根页表做遍历就行了。</p><p>因为一个 PTE 占用 8 字节，所以一页页表只能存放 512 个 PTE，虚拟地址前 27 位的每 9 位来索引页表中的 PTE。经过三级索引后就能得到物理地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">    <span class="keyword">int</span> ptes_per_table = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ptes_per_table;++i) &#123;</span><br><span class="line">        uint64 *va = (uint64 *)(pagetable + i);</span><br><span class="line">        <span class="keyword">pte_t</span> l2pte = (<span class="keyword">pte_t</span>)*va;</span><br><span class="line">        <span class="comment">// if pte is invalid</span></span><br><span class="line">        <span class="keyword">if</span> ((l2pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">pagetable_t</span> l2pagetable = (<span class="keyword">pagetable_t</span>) PTE2PA(l2pte);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, l2pte, l2pagetable);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; ptes_per_table;++j) &#123;</span><br><span class="line">            uint64 *va = (uint64 *)(l2pagetable + j);</span><br><span class="line">            <span class="keyword">pte_t</span> l1pte = (<span class="keyword">pte_t</span>) *va;</span><br><span class="line">            <span class="keyword">if</span> ((l1pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">pagetable_t</span> l1pagetable = (<span class="keyword">pagetable_t</span>) PTE2PA(l1pte);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>, j, l1pte, l1pagetable);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; ptes_per_table;++k) &#123;</span><br><span class="line">                uint64 *va = (uint64 *)(l1pagetable + k);</span><br><span class="line">                <span class="keyword">pte_t</span> l0pte = (<span class="keyword">pte_t</span>) *va;</span><br><span class="line">                <span class="keyword">if</span> ((l0pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>, k, l0pte,</span><br><span class="line">                        PTE2PA(l0pte));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-A-kernel-page-table-per-process"><a href="#2-A-kernel-page-table-per-process" class="headerlink" title="2. A kernel page table per process"></a>2. A kernel page table per process</h3><p>实验说明：为每一个进程都分配一个内核页表。</p><p>这个实验是为 lab 3 做铺垫的。所以也不是很难。</p><p>总共分两个步骤</p><ol><li>分配一个进程时进行页表的分配和映射</li><li>结束一个进程时进行页表的解映射和销毁</li></ol><p>一个进程内核页表，包括以下映射：</p><ul><li>UART0，VIRTIO0，PLIC</li><li>内核代码段</li><li>内核数据段以及 RAM</li><li>TRAMPOLINE</li><li>内核栈</li></ul><p>不做 CLINT 的映射是因为，xv6 OS 限制了用户进程的最大虚拟地址必须小于内核最低处虚拟地址（0xC000000），而 CLINT 在虚拟地址 （0x2000000）处，因此会与用户进程虚拟地址冲突，因此不能对 CLINT 进行映射。</p><hr><p>首先在 struct proc 中添加一个<strong>进程内核页</strong>字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.h:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">···</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> proc_kern_pt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后学着 kvminit 函数实现一个 proc_kvminit 为 proc_kern_pt 创建内核映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line"><span class="comment">//my code:</span></span><br><span class="line"><span class="keyword">pagetable_t</span></span><br><span class="line">proc_kvminit()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> pkpt = (<span class="keyword">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>((<span class="keyword">char</span> *)pkpt, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  mappages(pkpt, UART0, PGSIZE, UART0, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  mappages(pkpt, VIRTIO0, PGSIZE, VIRTIO0, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  <span class="comment">// mappages(pkpt, CLINT, 0x10000, CLINT, PTE_R | PTE_W);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  mappages(pkpt, PLIC, <span class="number">0x400000</span>, PLIC, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  mappages(pkpt, KERNBASE, (uint64)etext-KERNBASE, KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  mappages(pkpt, (uint64)etext, PHYSTOP-(uint64)etext, (uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  mappages(pkpt, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> pkpt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在只剩下内核栈还没有完成映射了。</p><p>OS 为每一个进程都分配了一页内核栈，用于该进程陷入内核后执行内核函数。</p><p>阅读 procinit 函数来理解内核是如何给每个进程分配内核栈并做映射的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line"></span><br><span class="line"> <span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"> <span class="keyword">void</span></span><br><span class="line"> procinit(<span class="keyword">void</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">   initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">       initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">       <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">       <span class="comment">// guard page.</span></span><br><span class="line">       <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">       <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">         panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">       uint64 va = KSTACK((<span class="keyword">int</span>) (p - proc));</span><br><span class="line">       kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">       p-&gt;kstack = va;</span><br><span class="line">   &#125;</span><br><span class="line">   kvminithart();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>由于我们会在每个进程的地址空间中（由 proc_kern_pt 确定）做内核栈的映射，因此这里就不需要为内核页表做映射了。所以对以上代码进行修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">procinit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// my code:</span></span><br><span class="line">      <span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">      <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">      <span class="comment">// guard page.</span></span><br><span class="line"><span class="comment">//      char *pa = kalloc();</span></span><br><span class="line"><span class="comment">//      if(pa == 0)</span></span><br><span class="line"><span class="comment">//        panic(&quot;kalloc&quot;);</span></span><br><span class="line"><span class="comment">//      uint64 va = KSTACK((int) (p - proc));</span></span><br><span class="line"><span class="comment">//      kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span></span><br><span class="line"><span class="comment">//      p-&gt;kstack = va;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  kvminithart();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 procalloc 函数中添加分配内核栈并做映射的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>*</span></span><br><span class="line"><span class="class"> <span class="title">allocproc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">···</span><br><span class="line"> found:</span><br><span class="line">   p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// my code:</span></span><br><span class="line">   p-&gt;proc_kern_pt = proc_kvminit();</span><br><span class="line">   <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">   <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">   uint64 va = TRAMPOLINE - <span class="number">2</span> * PGSIZE;</span><br><span class="line">   mappages(p-&gt;proc_kern_pt, va, PGSIZE, (uint64)pa, PTE_R | PTE_W);</span><br><span class="line">   p-&gt;kstack = va;</span><br><span class="line">   <span class="comment">///////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里把内核栈映射到 va = TRAMPOLINE - 2 * PGSIZE 还有一个好处，那就是如果栈溢出了，由于 va 以下的虚拟地址未作映射，会导致一个异常，以此来防止栈溢出而不自知。</p><p>然后实现在进程结束时解除映射并释放进程内核页表的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line"></span><br><span class="line"> <span class="comment">// my code:</span></span><br><span class="line"> <span class="keyword">extern</span> <span class="keyword">char</span> etext[];</span><br><span class="line"> <span class="keyword">void</span></span><br><span class="line"> proc_freekpagetable(<span class="keyword">pagetable_t</span> pagetable, uint64 kstack, uint64 sz) &#123;</span><br><span class="line">   uvmunmap(pagetable, UART0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   uvmunmap(pagetable, VIRTIO0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="comment">// uvmunmap(pagetable, CLINT, 0x10000 / PGSIZE, 0);</span></span><br><span class="line">   uvmunmap(pagetable, PLIC, <span class="number">0x400000</span> / PGSIZE, <span class="number">0</span>);</span><br><span class="line">   uvmunmap(pagetable, KERNBASE, ((uint64)etext - KERNBASE) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">   uvmunmap(pagetable, (uint64)etext, (PHYSTOP - (uint64)etext) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">   uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="comment">// uvmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 0);</span></span><br><span class="line">   uvmunmap(pagetable, kstack, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">   freewalk(pagetable);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在 freeproc 函数中进行页表的释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">freeproc(struct proc *p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="keyword">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;proc_kern_pt)</span><br><span class="line">      proc_freekpagetable(p-&gt;proc_kern_pt, p-&gt;kstack, p-&gt;sz);</span><br><span class="line">  p-&gt;proc_kern_pt = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">///////////////////////////////////////////////////////////</span></span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是在 scheduler 函数中在切换进程前切换 进程内核页表，在没有进程运行时要切换回 内核页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">scheduler(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        <span class="comment">// my code:</span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;proc_kern_pt)); <span class="comment">// 切换进程前，先切换进程内核页表</span></span><br><span class="line">        sfence_vma();</span><br><span class="line">        <span class="comment">/////////////////////////////////////</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">        <span class="comment">// my code:</span></span><br><span class="line">        kvminithart(); <span class="comment">// 切换回内核页表</span></span><br><span class="line">        <span class="comment">/////////////////////////////////////</span></span><br><span class="line">···</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Simplify-copyin-copyinstr"><a href="#3-Simplify-copyin-copyinstr" class="headerlink" title="3. Simplify copyin/copyinstr"></a>3. Simplify <em>copyin/copyinstr</em></h3><p>实验说明：原本用户空间的内容 copy 到内核空间时需要对用户空间的地址进行代码上的转换（人工查页表进行转换），变成物理地址（由于内核数据段的虚拟地址就是物理地址）；lab 3 就想实现省去代码上的地址转换，让用户空间中的内容能直接 copy 到内核空间。</p><p>解析：其实就是在 lab 2 的基础上，将用户空间的映射添加到进程内核页表中去。</p><p>总共三个地方涉及到了<strong>用户申请内存并做映射</strong>的操作：</p><ul><li>fork</li><li>exec</li><li>sbrk</li></ul><p>仔细阅读 uvmalloc 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line">uvmalloc(<span class="keyword">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数是做了物理内存分配和映射的。但是我们不需要做真正的分配内存的事，只需要做个映射就足够了。因此自己实现一个 proc_uvmalloc:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line"><span class="comment">// my code:</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">proc_uvmalloc(<span class="keyword">pagetable_t</span> pt, <span class="keyword">pagetable_t</span> npt, uint64 oldsz, uint64 newsz) &#123;</span><br><span class="line">    oldsz = PGROUNDUP(oldsz);</span><br><span class="line">    <span class="keyword">for</span> (uint64 a = oldsz; a &lt; newsz; a += PGSIZE) &#123;</span><br><span class="line">        uint64 pa = walkaddr(pt, a); <span class="comment">// 根据 进程页表 和 虚拟地址 来获得对于的物理地址</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != mappages(npt, a, PGSIZE, pa, PTE_W|PTE_X|PTE_R)) <span class="comment">// 做映射</span></span><br><span class="line">            panic(<span class="string">&quot;proc_uvmalloc\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>uvmcopy 这个函数是 fork 中需要用到的，因为要复制父进程的页表以及内存镜像。由于它也是做了内存的分配和映射，而我们仅仅需要映射，因此也自己实现一个 proc_uvmcopy：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">uvmcopy(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    memmove(mem, (<span class="keyword">char</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// my code:</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">proc_uvmcopy(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz) &#123;</span><br><span class="line">    uint64 a;</span><br><span class="line">    <span class="keyword">for</span> (a = <span class="number">0</span>;a &lt; sz;a += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *pte = walk(old, a, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        <span class="keyword">int</span> flags = PTE_FLAGS(*pte) &amp; (~PTE_U);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != mappages(<span class="keyword">new</span>, a, PGSIZE, pa, flags))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fork 中需要改动的地方：由于 fork 函数的作用是，分配一个新进程并复制父进程的内存镜像，所以 uvmcopy 函数会被调用，在它被调用完后我们只需要调用自己实现的 proc_uvmcopy，为 进程内核页表 添加映射即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    panic(<span class="string">&quot;fork:uvmcopy\n&quot;</span>);</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != proc_uvmcopy(np-&gt;pagetable, np-&gt;proc_kern_pt, p-&gt;sz))</span><br><span class="line">      panic(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">  <span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br></pre></td></tr></table></figure><p> exec ：一般在 fork 被调用完之后再调用，并根据可执行文件镜像，来加载内容到内存中。也就是说进程页表要重新分配过，同理 进程内核页表 也需要重新分配过。</p><p>这里就是那两个重要的坑出现的地方了：</p><ol><li><font color="red">进程内核页表 不能重新分配，而是在原来的基础上进行修改</font>，把用户地址映射部分全部清除掉，根据可执行文件镜像来重新做映射。为什么不能重新分配呢？因为从 用户态 执行到内核态的 exec 函数的整个函数调用过程都记录在内核栈中，如果重新分配进程内核页表，也就会重新分配内核栈，但这个新的内核栈无法跟原来的匹配起来（即使将原来内核栈中的内容 memmove 到新的，也会出错），会出现意想不到的错误。 </li><li><font color="red">解除 进程内核页表 中用户空间的映射这个过程需要在确保 exec 执行成功的前提下进行</font>，因为如果不这样的话，你提前解除了映射，在后面进程退出时会再解除以此从而导致 <strong>panic: uvmunmap: not map</strong> 错误。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">kernel/exec.c:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span></span><br><span class="line">  exec(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv) &#123;</span><br><span class="line">      ···</span><br><span class="line">          </span><br><span class="line">      <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">       sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">       sp -= sp % <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">         <span class="keyword">goto</span> bad;</span><br><span class="line">       <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="keyword">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// my code: 要在保证代码不会去到 bad 时，做 uvmunmap 并做用户空间的映射</span></span><br><span class="line">       uvmunmap(p-&gt;proc_kern_pt, <span class="number">0</span>, PGROUNDUP(p-&gt;sz) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">       proc_uvmalloc(pagetable, p-&gt;proc_kern_pt, <span class="number">0</span>, sz);</span><br><span class="line">       <span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">       <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">       <span class="comment">// value, which goes in a0.</span></span><br><span class="line">       p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Save program name for debugging.</span></span><br><span class="line">       <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">         <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">           last = s+<span class="number">1</span>;</span><br><span class="line">       safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Commit to the user image.</span></span><br><span class="line">       oldpagetable = p-&gt;pagetable;</span><br><span class="line">       p-&gt;pagetable = pagetable;</span><br><span class="line">       p-&gt;sz = sz;</span><br><span class="line">       p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">       p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">       proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// my code:</span></span><br><span class="line">       <span class="keyword">if</span> (p-&gt;pid == <span class="number">1</span>)</span><br><span class="line">           vmprint(p-&gt;pagetable);</span><br><span class="line">       <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line">       </span><br><span class="line">       bad:</span><br><span class="line">      ···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个实验是至今为止做的最难的一个了，做了估计有一礼拜。。。。主要的坑有两个，也是重要的知识点，下面会详细记录。&lt;/p&gt;
&lt;h4 id=&quot;为了方便在虚拟地址与物理地址之间的转换操作，做出以下宏定义：&quot;&gt;&lt;a href=&quot;#为了方便在虚拟地址与物理地址之间的转换操作，做出以下宏</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT 6.s081 2020 Lab2 System calls</title>
    <link href="https://codroc.github.io/2021/09/18/lab2trap%E7%9A%84%E6%97%85%E9%80%94/"/>
    <id>https://codroc.github.io/2021/09/18/lab2trap%E7%9A%84%E6%97%85%E9%80%94/</id>
    <published>2021-09-17T16:00:00.000Z</published>
    <updated>2021-11-09T03:50:11.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Trap-的旅途"><a href="#Trap-的旅途" class="headerlink" title="Trap 的旅途"></a>Trap 的旅途</h3><p>这一个 lab 实验反而是其次，我觉得更重要的是熟读并理解 <code>book-riscv-rev1</code> 第 4 章中的内容。以下内容尤其重要。</p><h4 id="进程数据结构体"><a href="#进程数据结构体" class="headerlink" title="进程数据结构体"></a>进程数据结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">   <span class="keyword">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">   <span class="keyword">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">   <span class="keyword">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">   <span class="keyword">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">   uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">   uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">   <span class="keyword">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h4 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h4><p>trampoline.S 中的 uservec</p><ul><li>系统已经设置好 uservec 是内核进入点<ul><li>也就是说此时的 stvec 的值是 uservec 的地址</li></ul></li><li>trap （ecall）使得进程陷入内核 （对所有的 trap 类型（除了定时器中段）RISC-V 硬件会做出以下步骤）<ul><li>如果 trap 是一个设备中段，并且 sstatus 的 SIE 位为 0，则跳过以下所有步骤</li><li>通过对 sstatus 的 SIE 位置零来关闭中断</li><li>将 pc 的值拷贝到 sepc</li><li>将当前的处理模式（user mode 或 supervisor mode）保存到 sstatus 的 SPP 位中</li><li>设置 scause 来反应导致 trap 的原因</li><li>将 mode 切换到 supervisor mode</li><li>将 stvec 中的值拷贝到 pc</li><li>开始执行新的 pc 处的指令</li></ul></li><li>将陷入内核的进程的所有寄存器状态保存到内存 proc 结构体的 trapframe 字段中 （用户进程空间）</li><li>将 trapframe 字段中的内核栈指针，hartid， usertrap 地址， 内核页表加载到对呀的寄存器中 （用户进程空间）</li><li>切换到内核页表 （从此进入内核空间）</li><li>跳转到 usertrap 函数入口处</li></ul><p>这里需要注意几点：</p><ol><li>每个进程都是一座孤岛，都有自己独立的虚拟地址空间。</li><li>uservec 这段代码存储在 TRAMPOLINE 这一物理页中。</li><li>TRAMPOLINE  会被映射到每一个进程的同一处虚拟地址空间中（包括内核）（相当于共享这一物理页的同时，虚拟地址都一样）。</li><li>内核在创建进程时会为每一个进程分配 proc 结构体保存进程的状态并存储在内核空间中；除此之外还会为每个进程创建一页 TRAPFRAME 页（它将被映射到进程虚拟地址空间的 TRAMPOLINE 页的下面一页，即 TRAPFRAME + 4096 == TRAMPOLINE）用于进程陷入内核时保存 user mode 的寄存器状态。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">.globl uservec</span><br><span class="line">uservec:</span><br><span class="line">    #</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process&#39;s p-&gt;trapframe is</span><br><span class="line">        # mapped into user space, at TRAPFRAME.</span><br><span class="line">        #</span><br><span class="line"></span><br><span class="line">    # swap a0 and sscratch</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">    # save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure><h4 id="usertrap-（以下皆在内核空间）"><a href="#usertrap-（以下皆在内核空间）" class="headerlink" title="usertrap （以下皆在内核空间）"></a>usertrap （以下皆在内核空间）</h4><p>trap.c 中的 usertrap 函数</p><ul><li>判断是否从 user mode 进到该函数的 （因为还有个 kerneltrap）</li><li>获取当前进程的 proc 结构体指针 p</li><li>将陷入内核的进程的 pc 保存到 p-&gt;trapframe-&gt;epc 中</li><li>判断系统调用还是中断还是异常，根据不同的情况做不同的操作 （我们这里只考虑系统调用）</li><li>调用 syscall 函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">usertrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到在 usertrap 中关于此次 trap 的原因分为三类：系统调用、中断和异常。根据不同的情况做出不同的操作。我们这里只考虑系统调用，那么就是为了执行 syscall 函数。</p><h4 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h4><p>这个函数是调用所有内核中的系统调用例程的总入口，也就是说所有的系统调用都要经过它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= &#123;</span><br><span class="line"> [SYS_fork]    sys_fork,</span><br><span class="line"> [SYS_exit]    sys_exit,</span><br><span class="line"> [SYS_wait]    sys_wait,</span><br><span class="line"> [SYS_pipe]    sys_pipe,</span><br><span class="line"> [SYS_read]    sys_read,</span><br><span class="line"> [SYS_kill]    sys_kill,</span><br><span class="line"> [SYS_exec]    sys_exec,</span><br><span class="line"> [SYS_fstat]   sys_fstat,</span><br><span class="line"> [SYS_chdir]   sys_chdir,</span><br><span class="line"> [SYS_dup]     sys_dup,</span><br><span class="line"> [SYS_getpid]  sys_getpid,</span><br><span class="line"> [SYS_sbrk]    sys_sbrk,</span><br><span class="line"> [SYS_sleep]   sys_sleep,</span><br><span class="line"> [SYS_uptime]  sys_uptime,</span><br><span class="line"> [SYS_open]    sys_open,</span><br><span class="line"> [SYS_write]   sys_write,</span><br><span class="line"> [SYS_mknod]   sys_mknod,</span><br><span class="line"> [SYS_unlink]  sys_unlink,</span><br><span class="line"> [SYS_link]    sys_link,</span><br><span class="line"> [SYS_mkdir]   sys_mkdir,</span><br><span class="line"> [SYS_close]   sys_close,</span><br><span class="line"> [SYS_trace]   sys_trace,</span><br><span class="line"> [SYS_sysinfo]   sys_sysinfo,</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"> syscall(<span class="keyword">void</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">int</span> num;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">   num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">   <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">     p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">             p-&gt;pid, p-&gt;name, num);</span><br><span class="line">     p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到所有的系统调用例程都被注册成了函数指针的形式。</p><p>syscall 函数就是根据进程陷入内核时传入的系统调用号来判断具体要去执行哪个函数指针。系统调用号会存储在 <code>proc::trapframe::a7</code> 中。返回值会保存在<code>proc::trapframe::a0</code> 中。</p><p>为什么存在 a7 中呢？这是因为在调用 ecall 前我们自己存放到 a7 寄存器的，在进入 uservec 后被 save 到 <code>proc::trapframe::a7</code> 中的。具体可以看 <code>user/usys.S</code>，这个函数编写了系统调用 wrapper：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel&#x2F;syscall.h&quot;</span><br><span class="line">···</span><br><span class="line">.global sleep</span><br><span class="line">  li a7, SYS_sleep</span><br><span class="line">  ecall</span><br><span class="line">  ret</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h4 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h4><p>这一函数在 <code>kernel/trap.c</code> 中。它要做的就是还原一些状态，为下次进程再次陷入内核做准备。</p><p>首先必要做的就是重新设置 stvec 控制状态寄存器的值为 uservec，为下次再次陷入内核做准备。其次将 内核页表、内核栈地址、usertrap 地址、core num 存入 TRAPFRAME 页中，供 userret 加载到寄存器中。重新设置 sstatus 控制状态寄存器。因为 sret 的时候，硬件会把 sepc 中的值拷贝到 pc 中，因此也要设置 sepc。并且获取到用户页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">usertrapret(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which</span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="keyword">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h4><p>这函数在 trampoline.S 中，它可以看成是 uservec 的镜像（对着干，uservec 是将寄存器的值 save 到内存，而它是将内存中的值 load 到寄存器）。这也是为了下次进程陷入内核做准备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">    # restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看完第三章的内容并彻底理解后，lab 就随便做做啦，洒洒水啦~~~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Trap-的旅途&quot;&gt;&lt;a href=&quot;#Trap-的旅途&quot; class=&quot;headerlink&quot; title=&quot;Trap 的旅途&quot;&gt;&lt;/a&gt;Trap 的旅途&lt;/h3&gt;&lt;p&gt;这一个 lab 实验反而是其次，我觉得更重要的是熟读并理解 &lt;code&gt;book-riscv</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MIT 6.s081 2020 Lab1 Unix utilities</title>
    <link href="https://codroc.github.io/2021/09/07/lab1find/"/>
    <id>https://codroc.github.io/2021/09/07/lab1find/</id>
    <published>2021-09-06T16:00:00.000Z</published>
    <updated>2021-11-09T03:49:59.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab 1"></a>Lab 1</h2><h3 id="find-实现"><a href="#find-实现" class="headerlink" title="find 实现"></a>find 实现</h3><p>这个小节的重点在于读懂 <code>user/ls.c</code> ，读懂之后，实现就很简单了。</p><h3 id="ls-阅读"><a href="#ls-阅读" class="headerlink" title="ls 阅读"></a>ls 阅读</h3><p>总共三部分</p><ul><li>main</li><li>fmtname</li><li>ls</li></ul><p>main 用来读取命令行输入以及做一些判断（这里我才发现原来 ls 可以带多个参数。。。）</p><p>fmtname 函数用于截取路径名中的最后一个 ‘/‘ 后的内容。</p><p>ls 则是逻辑核心，它涉及到两个结构体：</p><ul><li><p>dirent</p><ul><li><p>```C<br>#define DIRSIZ 14<br>struct dirent {</p><pre><code>ushort inum; // inode numchar name[DIRSIZ]; // directory entry name</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">文件夹是一种文件，它其实是 dirent 数组。而每一个 dirent 又代表一个文件或一个文件夹。可以从这一段代码中看出来：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;C</span><br><span class="line">while(read(fd, &amp;de, sizeof(de)) &#x3D;&#x3D; sizeof(de)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 fd 是指向文件夹的文件描述符，ls 代码中直接用读文件的方式，以 dirent 为单位，一个一个地读取，可见文件夹中的数据就是一个一个的 dirent 。结束的条件是，当读出的数据大小不等于 dirent 结构体大小。</p></li><li><p>该结构体由 inode 节点号与文件夹条目名字构成。</p></li></ul></li><li><p>stat</p><ul><li><p>stat 就是文件状态结构体，里面存储了文件的一些基本信息。例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">               <span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">               <span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">               <span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* File type and mode */</span></span><br><span class="line">               <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">               <span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">               <span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">               <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">               <span class="keyword">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">               <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">               <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line">    ...</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以用 c 库函数 fstat 来直接获取 stat 结构体信息。</p><p>ls 用 stat 结构体和 fstat 函数来判断某个 fd 是对应文件还是文件夹一次做出不同的操作。</p><p>实现 find 的过程中需要注意的地方</p></li></ul></li></ul><h3 id="实现-find-的过程中需要注意的地方"><a href="#实现-find-的过程中需要注意的地方" class="headerlink" title="实现 find 的过程中需要注意的地方"></a>实现 find 的过程中需要注意的地方</h3><ul><li><p>使用递归的方式去遍历所有的文件夹，出口条件就是 <code>st.type == T_FILE</code></p></li><li><p>因为一个文件夹下有 <code>.</code> 和 <code>..</code> 文件，注意不能对这两个文件进行递归，不然就会一直递归下去直到文件描述符耗尽</p></li><li><p>在出口返回的时候记得 <code>close(fd)</code> 来交还文件描述符资源。</p></li></ul><h4 id="find-代码如下："><a href="#find-代码如下：" class="headerlink" title="find 代码如下："></a>find 代码如下：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">     <span class="keyword">int</span> fd;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find, cannot open %s\n&quot;</span>, path);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">         close(fd);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (st.type != T_DIR) &#123;</span><br><span class="line">         close(fd);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">     p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">     <span class="keyword">if</span> (*(p<span class="number">-1</span>) != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">         *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">     <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, filename) != <span class="number">0</span>) &#123;</span><br><span class="line">             memmove(p, de.name, DIRSIZ);</span><br><span class="line">             p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">             find(buf, filename);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             memmove(p, de.name, DIRSIZ);</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     close(fd);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: %s path filename&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h3><p>这道题目是想通过多进程的方式并发筛选质数。算法的思想可以看这个<a href="http://swtch.com/~rsc/thread/">concurrent primes sieve</a>。问题是如何去实现呢？</p><p>首先遇到的问题就是，<strong>如何创建一个子进程之后再让该子进程创建自己的子进程，不断递归下去</strong>。这个其实稍微思考下就能想到，可以用以下伪代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == fork()) <span class="comment">// a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// b</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以看到，子进程经过一次循环并执行 fork 后就变成父进程了，就好像有儿子之后就变成老子了。。。而作为父进程，完成了自己的使命（传宗接代）就 break 掉等待着退出。</p><p>仔细对照算法，发现只有第一个进程仅仅有父进程身份（看作类型1），最后一个进程仅仅有子进程身份（看作类型3），夹在中间的进程既是父进程又是子进程（看作类型2）。因此我们只需要把类型2的进程作为子进程时需要实现的逻辑替换 a 中的 do something，它作为父进程时需要实现的逻辑替 b 中的 do something。</p><p>然后就是加判定条件，当遇到类型1或类型3的进程时该做的逻辑放到对应的地方就可以了。</p><h3 id="类型2-进程的逻辑"><a href="#类型2-进程的逻辑" class="headerlink" title="类型2 进程的逻辑"></a>类型2 进程的逻辑</h3><ul><li><p>作为父进程时</p><p>此时该进程必定有自己子进程，并且已经有管道连接自己的子进程了。它需要读取它的父进程传给它的数据并做相应的处理后传给它的子进程。</p></li><li><p>作为子进程时</p><p>此时该进程还没有调用 fork。它从它的父进程读取第一个数据（即质数）并把它打印出来，如果读取失败表示父进程关闭了管道的写端，此时说明整个逻辑都已经结束了</p></li></ul><p>对<strong>输入管道</strong>和<strong>输出管道</strong>定义如下：</p><blockquote><p>对于一个进程来说，它读取数据对应的管道叫输入管道，它往外写数据对应的管道叫输出管道。</p></blockquote><p>可以用以下伪代码表示上面的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> prime;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == fork()) <span class="comment">// 子进程身份时</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == read(输入管道读端, &amp;num, <span class="keyword">sizeof</span> <span class="keyword">int</span>)) &#123;</span><br><span class="line">        close(输入管道读端);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    prime = num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 父进程身份时</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> != read(输入管道读端, &amp;num, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % prime != <span class="number">0</span>)write(输出管道写端, &amp;num, <span class="keyword">sizeof</span> <span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(输入管道读端);</span><br><span class="line">    close(输出管道写端);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型3-进程的逻辑"><a href="#类型3-进程的逻辑" class="headerlink" title="类型3 进程的逻辑"></a>类型3 进程的逻辑</h3><p>类型3 进程只有子进程身份，因此类型2 逻辑中的子进程身份时的代码也是符合的。</p><h3 id="类型1-进程的逻辑"><a href="#类型1-进程的逻辑" class="headerlink" title="类型1 进程的逻辑"></a>类型1 进程的逻辑</h3><p>类型1 进程只有父进程身份，它无法从它的父进程中读取数据，因此要在上面代码的基础上加一些判断条件。第一个进程是吧 2~35 的数字传入子进程，因此便有以下伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 父进程身份时</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasFather) <span class="comment">// 如果该进程没有父进程,即类型1 进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">34</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            num = i + <span class="number">2</span>;</span><br><span class="line">            write(输出管道写端, &amp;num, <span class="keyword">sizeof</span> <span class="keyword">int</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(输出管道写端);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span> != read(输入管道读端, &amp;num, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % prime != <span class="number">0</span>)write(输出管道写端, &amp;num, <span class="keyword">sizeof</span> <span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        close(输入管道读端);</span><br><span class="line">    &#125;</span><br><span class="line">    close(输出管道写端);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用管道串起来"><a href="#用管道串起来" class="headerlink" title="用管道串起来"></a>用管道串起来</h3><p>最后一步就是在上面的基础上，要用管道把所有进程串起来，样子就像数据结构里的链表一样。。。。每一个进程应该要记住两个管道，一个是输入管道，一个是输出管道。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> inpipefd[<span class="number">2</span>]; <span class="comment">// 输入管道</span></span><br><span class="line"><span class="keyword">int</span> outpipefd[<span class="number">2</span>]; <span class="comment">// 输出管道</span></span><br><span class="line">inpipefd[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 用于区分类型1 进程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    pipe(outpipefd); <span class="comment">// 父进程创建输出管道</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == fork()) <span class="comment">// fork 之后子进程要关闭 2 个没用的文件描述符，各自在 outpipefd[1] 和 inpipefd[0] 内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inpipefd[<span class="number">0</span>] != <span class="number">0</span>) <span class="comment">// 关闭父进程输入管道的读端（除类型1 进程外）</span></span><br><span class="line">            close(inpipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 父进程的输出管道是子进程的输入管道</span></span><br><span class="line">        inpipefd[<span class="number">0</span>] = outpipefd[<span class="number">0</span>];</span><br><span class="line">        inpipefd[<span class="number">1</span>] = outpipefd[<span class="number">1</span>];</span><br><span class="line">        close(inpipefd[<span class="number">1</span>]); <span class="comment">// 关闭输入管道的写端</span></span><br><span class="line">        <span class="comment">// do something ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// b</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(outpipefd[<span class="number">0</span>]); <span class="comment">// 关闭输出管道读端</span></span><br><span class="line">        <span class="comment">// do something ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h5 id="最后代码如下："><a href="#最后代码如下：" class="headerlink" title="最后代码如下："></a>最后代码如下：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hasFather = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prime;</span><br><span class="line">    <span class="keyword">int</span> inpipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> outpipefd[<span class="number">2</span>];</span><br><span class="line">    inpipefd[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        pipe(outpipefd);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == fork()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inpipefd[<span class="number">0</span>] != <span class="number">-1</span>)</span><br><span class="line">                close(inpipefd[<span class="number">0</span>]);</span><br><span class="line">            inpipefd[<span class="number">0</span>] = outpipefd[<span class="number">0</span>];</span><br><span class="line">            inpipefd[<span class="number">1</span>] = outpipefd[<span class="number">1</span>];</span><br><span class="line">            close(inpipefd[<span class="number">1</span>]);</span><br><span class="line">            hasFather = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == read(inpipefd[<span class="number">0</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) &#123;</span><br><span class="line">                close(inpipefd[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            prime = num;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            close(outpipefd[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!hasFather) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">34</span>;++i) &#123;</span><br><span class="line">                    num = i + <span class="number">2</span>;</span><br><span class="line">                    write(outpipefd[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">0</span> != read(inpipefd[<span class="number">0</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % prime != <span class="number">0</span>) write(outpipefd[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                close(inpipefd[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            close(outpipefd[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="xargs-实现"><a href="#xargs-实现" class="headerlink" title="xargs 实现"></a>xargs 实现</h3><p>lab 1 实现只要求我们实现一个简单版的 xargs，它包含基本功能和一个 [-n] 选项功能：</p><ul><li><p>基本功能：从标准输入读取数据，并以 <code>&#39; &#39;</code> 和 <code>&#39;\n&#39;</code> 为分隔符，得到参数元素列表，用伪代码表示就是：</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputChar = read(stdin)</span><br><span class="line">argvs = inputChar.split([<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\n&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="built_in">test</span></span><br><span class="line">a b c</span><br><span class="line">d e f g</span><br><span class="line">$ cat <span class="built_in">test</span> | xargs</span><br><span class="line">a b c d e f g</span><br><span class="line">$</span><br></pre></td></tr></table></figure></li></ul></li><li><p>[-n num] 选项功能就是在基本功能的基础上，xargs 限定每行 num 个元素：</p><ul><li><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat <span class="built_in">test</span></span></span><br><span class="line">a b c</span><br><span class="line">d e f g</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat <span class="built_in">test</span> | xargs -n 1</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">g</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="xargs-处理逻辑"><a href="#xargs-处理逻辑" class="headerlink" title="xargs 处理逻辑"></a>xargs 处理逻辑</h3><ol><li>判断自身选项是否含有 [-n] 选项</li><li>获取要执行的 cmd 以及对应的 argv</li><li>获取从标准输入读取的参数 inargv</li><li>根据是否含有 [-n] 选项进行一次或多次调用 fork 与 exec</li></ol><h5 id="具体代码如下："><a href="#具体代码如下：" class="headerlink" title="具体代码如下："></a>具体代码如下：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">char</span>* <span class="title">ignoreSpaceAndNewline</span><span class="params">(<span class="keyword">char</span>* p)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(*p != <span class="number">0</span> &amp;&amp; (*p == <span class="string">&#x27; &#x27;</span> || *p == <span class="string">&#x27;\n&#x27;</span>)) &#123;++p;&#125;</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">char</span>* <span class="title">findNextSpaceOrNewline</span><span class="params">(<span class="keyword">char</span>* p)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(*p != <span class="number">0</span> &amp;&amp; *p != <span class="string">&#x27; &#x27;</span> &amp;&amp; *p != <span class="string">&#x27;\n&#x27;</span>) &#123;++p;&#125;</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">0</span> == fork())</span><br><span class="line">         exec(argv[<span class="number">0</span>], argv);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         wait(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getALine</span><span class="params">(<span class="keyword">char</span> *buf)</span> </span>&#123; <span class="comment">// 以\n\0结尾</span></span><br><span class="line">     <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(ch != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="number">0</span> == read(<span class="number">0</span>, &amp;ch, <span class="number">1</span>))</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         buf[i++] = ch;</span><br><span class="line">     &#125;</span><br><span class="line">     buf[i] = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getArgsFromStdin</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> num;</span><br><span class="line">     <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">0</span> != (num = getALine(buf))) &#123;</span><br><span class="line">         buf[num - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 用 0 把 \n 替换掉</span></span><br><span class="line">         <span class="keyword">char</span>* p;</span><br><span class="line">         p = buf;</span><br><span class="line">         <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">             p = ignoreSpaceAndNewline(p);</span><br><span class="line">             <span class="keyword">if</span> (*p == <span class="number">0</span>)    <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">char</span> *n = findNextSpaceOrNewline(p);</span><br><span class="line">             *n = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">char</span>* tmp = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(p) + <span class="number">1</span>);</span><br><span class="line">             argv[cnt++] = tmp;</span><br><span class="line">             <span class="built_in">memcpy</span>(tmp, p, <span class="built_in">strlen</span>(p) + <span class="number">1</span>);</span><br><span class="line">             p = n + <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> cnt;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> oneCol = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (argc &gt; <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-n&quot;</span>) == <span class="number">0</span> &amp;&amp; <span class="number">0</span> == <span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;1&quot;</span>))</span><br><span class="line">         oneCol = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> i = (oneCol == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">3</span>);</span><br><span class="line">     <span class="keyword">char</span> *cargv[MAXARG]; <span class="comment">// cmd args</span></span><br><span class="line">     <span class="built_in">memset</span>(cargv, <span class="number">0</span>, MAXARG);</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (;i &lt; argc;++i)</span><br><span class="line">         cargv[j++] = argv[i];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span>* inargv[MAXARG];<span class="comment">// args from stdin</span></span><br><span class="line">     <span class="built_in">memset</span>(inargv, <span class="number">0</span>, MAXARG);</span><br><span class="line">     <span class="keyword">int</span> cnt = getArgsFromStdin(inargv);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (oneCol == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; cnt;++k)</span><br><span class="line">             cargv[j++] = inargv[k];</span><br><span class="line">         doit(j, cargv);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; cnt;++k) &#123;</span><br><span class="line">             cargv[j] = inargv[k];</span><br><span class="line">             doit(j + <span class="number">1</span>, cargv);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cnt;++i)</span><br><span class="line">         <span class="built_in">free</span>(inargv[i]);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab-1&quot;&gt;&lt;a href=&quot;#Lab-1&quot; class=&quot;headerlink&quot; title=&quot;Lab 1&quot;&gt;&lt;/a&gt;Lab 1&lt;/h2&gt;&lt;h3 id=&quot;find-实现&quot;&gt;&lt;a href=&quot;#find-实现&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++ Memory Order</title>
    <link href="https://codroc.github.io/2021/04/26/C++_Memory_Order/"/>
    <id>https://codroc.github.io/2021/04/26/C++_Memory_Order/</id>
    <published>2021-04-26T13:29:12.000Z</published>
    <updated>2021-04-27T13:14:33.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Memory-Order"><a href="#C-Memory-Order" class="headerlink" title="C++ Memory Order"></a>C++ Memory Order</h1><h1 id="reordering-现象"><a href="#reordering-现象" class="headerlink" title="reordering 现象"></a>reordering 现象</h1><p>首先简要介绍下编译器和 CPU 的 reordering 现象。这也被叫做程序的乱序执行。</p><p>乱序是指代码的执行过程和代码的书写过程不一样，其中一些指令的顺序会被<strong>编译器或 CPU</strong> 调整。目的是为了提高程序的运行效率。</p><h2 id="编译器的-reordering-优化"><a href="#编译器的-reordering-优化" class="headerlink" title="编译器的 reordering 优化"></a>编译器的 reordering 优化</h2><p><strong>典型的就是通过调整指令顺序，在不改变程序语义的前提下，尽可能地减少寄存器的读取、存储次数，充分复用寄存器的存储值</strong></p><p>我们知道 C/C++ 源代码会通过编译汇编变成机器码。这里就可能产生 reordering 现象。例如：</p><p>假设有 3 条指令：</p><ol><li>计算变量 A 和 B 的值，并把结果 C 保存到寄存器 ax 中</li><li>指令需要用到 ax 寄存器，因此把 C 从 ax 中取出另存</li><li>指令使用 C 的值且与第二条指令无关</li></ol><p>按照上面描述的，如果不进行 reordering 优化，程序的执行顺序是这样：C 在第一条指令被执行过后存入寄存器 ax；在第二条指令执行时 C 不再存在于 ax 中；第三条指令执行时 C 被重新读入寄存器 ax 中。</p><p>而如果按照乱序执行呢？就可以出现这样的情况：C 在第一条指令被执行过后存入寄存器 ax；由于第二条指令与第三条指令不想关，因此先执行第三条指令，再执行第二条指令，这样就少了一次寄存器 ax 的读写操作，降低了重复读取的开销。</p><h2 id="CPU-的乱序执行优化"><a href="#CPU-的乱序执行优化" class="headerlink" title="CPU 的乱序执行优化"></a>CPU 的乱序执行优化</h2><p>当 C/C++ 源码编译汇编成机器码后，CPU 取机器码的顺序也可能是乱序的！也就是说，如果有两个线程 A 和 B，这两个线程执行同一份代码的指令顺序都可能不同，甚至于同一个线程，多次运行同一段代码，每次执行的指令顺序都可能不同，这就是 CPU 层面的 reordering 导致的。为什么呢？</p><p><strong>CPU 的执行原理</strong></p><p>现在的 CPU 采用流水线来执行指令。一条指令的执行被分为：取指、译码、访存、执行、写回等若干个阶段（具体可以看 [CSAPP]）。<strong>多条指令可以同时存在于流水线中，同时被执行</strong>。特别是，当代 CPU 的 IPC （每时钟执行指令数）一般都远大于 1，也就是所谓的多发射，很多命令都是并行执行的。比如，当代 CPU 当中（一个核心）一般会有 2 套以上的整数 ALU（加法器），2 套以上的浮点 ALU（加法器），往往还有独立的乘法器，以及，独立的 Load 和 Store 执行器。Load 和 Store 模块往往还有 8 个以上的队列，也就是可以同时进行 8 个以上内存地址（cache line）的读写交换。</p><p>例如现在有 3 条指令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a++;</span><br><span class="line">b = f(a); <span class="comment">//不是指函数，而仅仅是指 b 依赖于 a；函数要更加复杂，函数会由更多条指令构成；</span></span><br><span class="line">c++</span><br></pre></td></tr></table></figure><p>那么可以画出它们的流水线：</p><img src="/2021/04/26/C++_Memory_Order/pipeline.PNG" class title="Pipeline"><p>由于 b = f(a) 这条指令依赖于前面 a++ 这条指令的执行结果，所以 b = f(a) 将在执行阶段被阻塞，直到 a++ 写回阶段结束才能继续，这样就多出了<strong>空等时间</strong>。但是 c++ 是不依赖于前面两天指令的，如果把 c++ 移到第二条指令处，是不是可以先去执行 c++ 而不用阻塞 b = f(a) 指令了，这提高了程序的执行效率。</p><p>除此之外，由于现在是多核时代，每个核一般都有自己独立的 L1 Cache 和 L2 Cache 以及多核共享的 L3 Cache。一个线程在代码中对多个变量的一次修改，可能会以不同的次序同步到另一个线程所在的核心上。不同线程对数据的需求不同，按需同步也会导致 CacheLine 的读序和写序不同。</p><p>如果其中第一个变量扮演了开关的作用，控制对后续变量的访问。那么当这些变量被一起同步到其他核心时，更新顺序可能变了，第一个变量未必是第一个更新的，然而其他线程还认为它代表着其他变量有效，去访问了实际已被删除的变量，从而导致未定义的行为。比如下面的代码片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line"><span class="comment">// ready was initialized to false</span></span><br><span class="line">p.init();</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread2</span></span><br><span class="line"><span class="keyword">if</span> (ready) &#123;</span><br><span class="line">    p.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从人的角度，这是对的，因为线程 2 在 ready 为 true 时才会访问 p，按线程 1 的逻辑，此时 p 应该初始化好了。但对多核机器而言，这段代码可能难以正常运行： </p><ul><li>线程 1 中的 ready = true 可能会被编译器或 cpu 重排到 p.init() 之前，从而使线程 2 看到 ready 为 true 时，p 仍然未初始化。这种情况同样也会在线程 2 中发生，p.bar() 中的一些代码可能被重排到检查 ready 之前</li><li>即使没有重排，ready 和 p 的值也会独立地同步到线程 2 所在核心的 cache，线程 2 仍然可能在看到 ready 为 true 时看到未初始化的 p</li></ul><h1 id="六种内存序"><a href="#六种内存序" class="headerlink" title="六种内存序"></a>六种内存序</h1><p>C++ 有六种内存序：</p><p>std::memory_order 定义于头文件 <atomic></atomic></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">memory_order</span> &#123;</span></span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><p>可以分为四大类：</p><ol><li>宽松顺序</li><li>释放获得顺序</li><li>释放消费顺序</li><li>序列一致顺序</li></ol><p>下面详细介绍下这四大类。</p><hr><h2 id="宽松顺序-Relaxed-Ordering"><a href="#宽松顺序-Relaxed-Ordering" class="headerlink" title="宽松顺序 (Relaxed Ordering)"></a>宽松顺序 (Relaxed Ordering)</h2><p>带标签 <code>memory_order_relaxed</code> 的原子操作无同步操作；它们不会在共时的内存访问间强加顺序。它们只保证原子性和修改顺序一致性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; x = <span class="number">0</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; y = <span class="number">0</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="comment">// thread 1:</span></span><br><span class="line">r1 = y.load(<span class="built_in">std</span>::memory_order_relaxed); <span class="comment">// A</span></span><br><span class="line">x.store(r1, <span class="built_in">std</span>::memory_order_relaxed); <span class="comment">// B</span></span><br><span class="line"><span class="comment">// thread 2:</span></span><br><span class="line">r2 = x.load(<span class="built_in">std</span>::memory_order_relaxed); <span class="comment">// C </span></span><br><span class="line">y.store(<span class="number">42</span>, <span class="built_in">std</span>::memory_order_relaxed); <span class="comment">// D</span></span><br></pre></td></tr></table></figure><p>之前在对 reordering 现象的介绍中已经说了，那些没有相互依赖的指令可能会被编译器或（和）CPU reorder。那么看上面的代码，thread 1 中 A 和 B 相互依赖并且是原子的，对的，有时候load和store都需要原子地进行，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> i = <span class="number">0</span>; <span class="comment">// global variable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread-1:</span></span><br><span class="line">i = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//Thread-2:</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br></pre></td></tr></table></figure><p>C++ 并不保证 <code>i = 100</code> 是原子操作，因为在某些 CPU Architecture 中，写入 <code>int64_t</code> 需要两个 CPU 指令，所以 Thread-2 可能会读取到 <code>i</code> 在赋值过程的中间状态。</p><p>继续话题。因此 A 和 B 必定按照代码书写的顺序执行。再看 C 和 D，它们是原子的但是并不相互依赖，所以编译器或 CPU 可能对它们进行 reorder，这里加的标签是 <code>memory_order_relaxed</code>，它只保证原子性和修改顺序一致性，不保证同步操作。因此执行完上面的程序，可能出现<code>r1 == r2 == 42</code>。理解这一点并不难，因为编译器允许调整 C 和 D 的执行顺序。如果程序的执行顺序是 D -&gt; A -&gt; B -&gt; C，那么就会出现<code>r1 == r2 == 42</code>。</p><p>总结：对于 <code>memory_order_relaxed</code> 来说，无关系依赖的指令仍旧有可能被编译器或 CPU reorder！</p><hr><h2 id="释放获得顺序-Release-Acquire-Ordering"><a href="#释放获得顺序-Release-Acquire-Ordering" class="headerlink" title="释放获得顺序 (Release-Acquire Ordering)"></a>释放获得顺序 (Release-Acquire Ordering)</h2><p>若线程 A 中的一个原子存储带标签 <code>memory_order_release</code> ，而线程 B 中来自同一变量的原子加载带标签 <code>memory_order_acquire</code> ，则从线程 A 的视角<em>先发生于</em>原子存储的所有内存写入（非原子及宽松原子的），在线程 B 中成为<em>可见副效应</em>，即一旦原子加载完成，则保证线程 B 能观察到线程 A 写入内存的所有内容。</p><p>什么意思呢？</p><ol><li>首先 <code>store()</code> 是使用标签 <code>memory_order_release</code> 的，而 <code>load()</code> 是使用标签 <code>memory_order_acquire</code> 的，这其实是遵循先 release 再 acquire（即先写再读）的规则</li><li><em>可见副效应</em>是指，在 B 线程中原子加载后面的指令，它们能看到 A 线程在执行完原子存储后对内存产生的所有变化，这是什么意思？难道原来不加 <code>release-acquire</code> 标签就看不到吗？是的，可能由于 reorder 导致原先在 A 线程原子存储前的指令被换到了原子存储后，这样线程 B 就看不到本应看到的内存变化了。</li><li>注意第 2 条说的<em>B 线程中原子加载后面的指令</em>，也就是说 B 线程原子加载后面的指令也不能被 reorder 到原子加载前面，因为如果有指令被移到了前面，那该条指令就看不到 A 线程对内存产生的变化了。</li></ol><p>总结：在这种模型下，<code>store()</code> 使用 <code>memory_order_release</code>，而 <code>load()</code> 使用 <code>memory_order_acquire</code>。这种模型有两种效果，第一种是可以限制 CPU 指令的重排:</p><ul><li>在 <code>store()</code> 之前的所有读写操作，不允许被移动到这个 <code>store()</code> 的后面。</li><li>在 <code>load()</code> 之后的所有读写操作，不允许被移动到这个 <code>load()</code> 的前面。</li></ul><p>看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt; ptr;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p  = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);             <span class="comment">// A</span></span><br><span class="line">    data = <span class="number">42</span>;                                              <span class="comment">// B</span></span><br><span class="line">    ptr.store(p, <span class="built_in">std</span>::memory_order_release);                <span class="comment">// C</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p2;</span><br><span class="line">    <span class="keyword">while</span> (!(p2 = ptr.load(<span class="built_in">std</span>::memory_order_acquire)))     <span class="comment">// D</span></span><br><span class="line">        ;</span><br><span class="line">    assert(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// 绝无问题                      // E</span></span><br><span class="line">    assert(data == <span class="number">42</span>); <span class="comment">// 绝无问题                          // F</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们分析下整个过程：</p><ul><li>这是 Release-Acquire Ordering</li><li>A B 不允许移到 C 后面，E F 不允许被移到 D 前面</li><li>while 循环直到 C 执行完后才会出循环，而一旦 C 执行完了，那么 data = 42，*ptr = “Hello” 是肯定的了</li><li>因此 E 和 F 的 assert 必定为真</li></ul><blockquote><p>注意：虽然 Release-Acquire Ordering 规定 store 前的指令不能移到 store 后面，但是 store 前的可以被 reorder！也就是 A 和 B 可能会乱序执行（虽然在这里好像没什么必要这么做）</p></blockquote><hr><h2 id="释放消费顺序-Release-Consume-Ordering"><a href="#释放消费顺序-Release-Consume-Ordering" class="headerlink" title="释放消费顺序 (Release-Consume Ordering)"></a>释放消费顺序 (Release-Consume Ordering)</h2><p>若线程 A 中的原子存储带标签 <code>memory_order_release</code> 而线程 B 中来自同一对象的读取存储值的原子加载带标签 <code>memory_order_consume</code> ，则线程 A 视角中<em>先发生于</em>原子存储的所有内存写入（非原子和宽松原子的），会在线程 B 中该加载操作所<em>携带依赖</em>进入的操作中变成<em>可见副效应</em>，即一旦完成原子加载，则保证线程B中，使用从该加载获得的值的运算符和函数，能见到线程 A 写入内存的内容。</p><p>这个内存序只是在上面 Release-Acquire Ordering 的内存序的基础上放开了一点约束：<strong>携带依赖</strong></p><p>也就是说保证那些跟原子加载操作相依赖的指令不会被 reorder 到原子加载前面。</p><p>看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt; ptr;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p  = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);                     <span class="comment">// A</span></span><br><span class="line">    data = <span class="number">42</span>;                                                      <span class="comment">// B</span></span><br><span class="line">    ptr.store(p, <span class="built_in">std</span>::memory_order_release);                        <span class="comment">// C</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p2;</span><br><span class="line">    <span class="keyword">while</span> (!(p2 = ptr.load(<span class="built_in">std</span>::memory_order_consume)))             <span class="comment">// D</span></span><br><span class="line">        ;</span><br><span class="line">    assert(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// 绝无出错： *p2 从 ptr 携带依赖         // E</span></span><br><span class="line">    assert(data == <span class="number">42</span>); <span class="comment">// 可能也可能不会出错： data 不从 ptr 携带依赖 // F</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们分析一下：</p><ul><li>这是 Release-Consume Ordering</li><li>store 前面的保证不会出现在 store 后面，因此 A B 必定在 C 前面（但 A B 还是 B A 就不知道了）</li><li>load 后面与 ptr 相依赖的指令不会出现在 load 前面，因此 E（*p2 依赖 ptr） 必定在 store 后面，而 F 可能出现在 D 前面</li></ul><hr><h2 id="序列一致顺序-Sequential-Consistency-Ordering"><a href="#序列一致顺序-Sequential-Consistency-Ordering" class="headerlink" title="序列一致顺序 (Sequential Consistency Ordering)"></a>序列一致顺序 (Sequential Consistency Ordering)</h2><p>带标签 <code>memory_order_seq_cst</code> 的原子操作不仅以与 Release-Acquire Ordering 相同的方式排序内存（在一个线程中<em>先发生于</em>存储的任何结果都变成进行加载的线程中的<em>可见副效应</em>），还对所有带此标签的内存操作建立<em>单独全序</em>。</p><p>这句话的前半句只要理解了 Release-Acquire Ordering 就明白了，就是说的 store 前的指令不允许出现在 store 后，load 后的指令不允许出现在 load 前；而后半句表示所有使用 seq_cst 的指令有严格的全序关系</p><p><font color="red"><a href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/atomic_instructions.md">brpc</a> 对这个也做了不错的介绍！</font></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/-citywall123/p/13336477.html">乱序执行 cnblog</a></li><li><a href="https://zh.cppreference.com/w/cpp/atomic/memory_order">cppreference</a></li><li><a href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/atomic_instructions.md">brpc</a></li><li><a href="https://www.zhihu.com/question/24301047/answer/1193956492">知乎</a></li><li><a href="http://senlinzhan.github.io/2017/12/04/cpp-memory-order/">http://senlinzhan.github.io/2017/12/04/cpp-memory-order/</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-Memory-Order&quot;&gt;&lt;a href=&quot;#C-Memory-Order&quot; class=&quot;headerlink&quot; title=&quot;C++ Memory Order&quot;&gt;&lt;/a&gt;C++ Memory Order&lt;/h1&gt;&lt;h1 id=&quot;reordering-现象</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>不同编译单元 nonlocal-static 初始化次序的问题</title>
    <link href="https://codroc.github.io/2021/03/27/non-local_static_object_initialization/"/>
    <id>https://codroc.github.io/2021/03/27/non-local_static_object_initialization/</id>
    <published>2021-03-26T16:00:00.000Z</published>
    <updated>2021-03-27T12:02:32.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不同编译单元内定义之-non-local-static-对象的初始化次序"><a href="#不同编译单元内定义之-non-local-static-对象的初始化次序" class="headerlink" title="不同编译单元内定义之 non-local static 对象的初始化次序"></a>不同编译单元内定义之 non-local static 对象的初始化次序</h1><p>这个概念我最早在 《Effective C++》碰到，想要用具体代码来做个实验，记录下实验过程。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>不同编译单元：指的是不同的 ELF 文件。包括可连接的目标文件，库文件（静态库，共享库），可执行文件。其实就是用编译器经过预处理，编译，汇编得到的二进制文件。</li><li>static 对象：就是数据内容存储在 data段或 bss段的对象。也就是说在生成二进制文件后已经有空间留出来给 static 对象了！如果被初始化的则存入 data段，未被初始化的则存入 bss段，证明可以看下面的实验。</li><li>non-local：static 又分 local static 和 non-local static，只要记住除了函数内申明的 static 是 local static，其他地方的都是 non-local static。</li></ul><h2 id="POD-类型"><a href="#POD-类型" class="headerlink" title="POD 类型"></a>POD 类型</h2><p>所谓的 POD 类型就是 Plain Of Data，即朴素的数据，也就是 C 语言中的原始类型。</p><p>首先证明一下 static 对象（不管是 local 还是 non-local）在源文件编译成 ELF 文件后已经在二进制文件中占有一席之地了（被分配空间）！并且被初始化的对象存放在 data段，而未初始化的对象存放在 bss段。</p><p>hello.cc：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;              <span class="comment">// 未初始化</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;          <span class="comment">// 已初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> c;       <span class="comment">// 未初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> d = <span class="number">2</span>;   <span class="comment">// 已初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> __bss_start;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> _end;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> __data_start;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> _edata;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bss start:  %p\n&quot;</span>, &amp;__bss_start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bss end:    %p\n&quot;</span>, &amp;_end);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data start: %p\n&quot;</span>, &amp;__data_start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data end:   %p\n&quot;</span>, &amp;_edata);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a address:  %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b address:  %p\n&quot;</span>, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c address:  %p\n&quot;</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d address:  %p\n&quot;</span>, &amp;d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解释一下：</p><p><strong>__data_start，_edata， __bss_start， _end</strong> 符号是链接器脚本定义的符号。分别表示 data段开始，data段结束，bss段开始，bss段结束。</p><p>那么我是怎么知道这些符号的名字的呢？</p><p>刚开始我也不知道所以废了好长的时间，哎~~~后面才发现可以用 <code>$ ld -verbose</code> 命令可以把 gcc 的默认链接脚本打印出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">  &#125;</span><br><span class="line">  .jcr            : &#123; KEEP (*(.jcr)) &#125;</span><br><span class="line">  .data.rel.ro : &#123; *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) &#125;</span><br><span class="line">  .dynamic        : &#123; *(.dynamic) &#125;</span><br><span class="line">  .got            : &#123; *(.got) *(.igot) &#125;</span><br><span class="line">  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) &gt;= 24 ? 24 : 0, .);</span><br><span class="line">  .got.plt        : &#123; *(.got.plt)  *(.igot.plt) &#125;</span><br><span class="line">  .data           :</span><br><span class="line">  &#123;</span><br><span class="line">    *(.data .data.* .gnu.linkonce.d.*)</span><br><span class="line">    SORT(CONSTRUCTORS)</span><br><span class="line">  &#125;</span><br><span class="line">  .data1          : &#123; *(.data1) &#125;</span><br><span class="line">  _edata = .; PROVIDE (edata = .);</span><br><span class="line">  . = .;</span><br><span class="line">  __bss_start = .;</span><br><span class="line">  .bss            :</span><br><span class="line">  &#123;</span><br><span class="line">   *(.dynbss)</span><br><span class="line">   *(.bss .bss.* .gnu.linkonce.b.*)</span><br><span class="line">   *(COMMON)</span><br><span class="line">   /* Align here to ensure that the .bss section occupies space up to</span><br><span class="line">      _end.  Align after .bss to ensure correct alignment even <span class="keyword">if</span> the</span><br><span class="line">      .bss section disappears because there are no input sections.</span><br><span class="line">      FIXME: Why <span class="keyword">do</span> we need it? When there is no .bss section, we don<span class="string">&#x27;t</span></span><br><span class="line"><span class="string">      pad the .data section.  */</span></span><br><span class="line"><span class="string">   . = ALIGN(. != 0 ? 64 / 8 : 1);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  .lbss   :</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    *(.dynlbss)</span></span><br><span class="line"><span class="string">    *(.lbss .lbss.* .gnu.linkonce.lb.*)</span></span><br><span class="line"><span class="string">    *(LARGE_COMMON)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  . = ALIGN(64 / 8);</span></span><br><span class="line"><span class="string">  . = SEGMENT_START(&quot;ldata-segment&quot;, .);</span></span><br><span class="line"><span class="string">  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)) :</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)) :</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    *(.ldata .ldata.* .gnu.linkonce.l.*)</span></span><br><span class="line"><span class="string">    . = ALIGN(. != 0 ? 64 / 8 : 1);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  . = ALIGN(64 / 8);</span></span><br><span class="line"><span class="string">  _end = .; PROVIDE (end = .);</span></span><br><span class="line"><span class="string">  . = DATA_SEGMENT_END (.);</span></span><br><span class="line"><span class="string">···</span></span><br></pre></td></tr></table></figure><p>现在执行 <code>hello</code> 文件来看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bss start:  0x558cdfa3c018</span><br><span class="line">bss end:    0x558cdfa3c028</span><br><span class="line">data start: 0x558cdfa3c000</span><br><span class="line">data end:   0x558cdfa3c018</span><br><span class="line">a address:  0x558cdfa3c01c</span><br><span class="line">b address:  0x558cdfa3c010</span><br><span class="line">c address:  0x558cdfa3c020</span><br><span class="line">d address:  0x558cdfa3c014</span><br></pre></td></tr></table></figure><p>其中 <strong>a，c</strong> 在 bss 段内（0x558cdfa3c018~0x558cdfa3c028），<strong>b，d</strong> 在 data 段内（0x558cdfa3c000~0x558cdfa3c018），而我们在源文件中可以看大到 a 和 c 都是未经过初始化而 b 和 d 都是经过初始化的。由此可以证明以上的结论。</p><p>再证明 static 对象在 ELF 文件中的段（data段或 bss段）中占有一席之地！</p><p>执行如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -s -j .data hello</span><br></pre></td></tr></table></figure><p>objdump 的 <code>-s</code> 选项用于查看某个 section 的全部内容，而 <code>-j</code> 选项用来指定某个具体的 section，该命令的使用可以看我这篇文章 <a href>objdump</a></p><p>得到以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .data:</span><br><span class="line"> 201000 00000000 00000000 08102000 00000000  .......... .....</span><br><span class="line"> 201010 01000000 02000000                    ........    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到第一列是相对地址，每一行有 16 个字节。在之前的符号输出中已经看到了 data段起始于 <code>0000000000201000</code> 在这里也可得到验证。再看 <code>201010</code> 处后面四个字节表示的就是数字 1（即 b 对象的值），再后面四个字节表示的数字 2（即 d 对象的值）。</p><h2 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h2><p>我们已经对 POD 类型进行了实验，接下来就是对用户自定义的类进行实验了！</p><p>有如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> __data_start;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> _edata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> __bss_start;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> _end;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() </span><br><span class="line">        :a(<span class="number">10</span>)</span><br><span class="line">    &#123;&#125;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bss start:  %p\n&quot;</span>, &amp;__bss_start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bss end:    %p\n&quot;</span>, &amp;_end);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data start: %p\n&quot;</span>, &amp;__data_start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data end:   %p\n&quot;</span>, &amp;_edata);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a address:  %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bss start:  0x56124497d010</span><br><span class="line">bss end:    0x56124497d020</span><br><span class="line">data start: 0x56124497d000</span><br><span class="line">data end:   0x56124497d010</span><br><span class="line">a address:  0x56124497d014</span><br></pre></td></tr></table></figure><p>由此可见 a 在 bss段。这证明了很多东西！</p><ol><li>在类内对 ints 类型的赋初值并不是定义而仅仅是申明，所以在类内进行赋初值有什么用？我也不知道现在。</li><li>虽然在程序被加载进入内存之前，在 bss 段中就已经给未初始化的 static 对象记录了应该预留的空间，注意不是真正的预留了，而是写了一个数，因为 bss 段空间的值都是 0，没有必要让费磁盘空间来存一些没有意义的 0.</li></ol><h1 id="链接的顺序不同导致初始化次序不同"><a href="#链接的顺序不同导致初始化次序不同" class="headerlink" title="链接的顺序不同导致初始化次序不同"></a>链接的顺序不同导致初始化次序不同</h1><p>看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ji.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ji</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ji()</span><br><span class="line">        :weight(<span class="number">1000</span>)</span><br><span class="line">    &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;wo you yi zhi ji.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">xiadan</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ji kai shi xiadan&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">w</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> weight; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># ji.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ji.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ji j; <span class="comment">// nonlocal-static 对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># dan.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ji.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dan</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    dan(ji j)</span><br><span class="line">        :weight(<span class="number">50</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ji zhong &quot;</span> &lt;&lt; j.w() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        j.xiadan();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># main.cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dan.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> ji j;</span><br><span class="line"></span><br><span class="line"><span class="function">dan <span class="title">d</span><span class="params">(j)</span></span>; <span class="comment">// nonlocal-static 对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将 j.cc 和 main.cc 都编译成 .o 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++  -c -o main.o main.cc</span><br><span class="line">$ g++  -c -o ji.o ji.cc</span><br></pre></td></tr></table></figure><p>然后再链接 2 个 .o 文件，首先我们先把 main.o 放在前面，ji.o 放在后面，并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.o ji.o</span><br><span class="line">$ ./a.out</span><br><span class="line">    ji zhong 0</span><br><span class="line">    ji kai shi xiadan</span><br><span class="line">    wo you yi zhi ji.</span><br></pre></td></tr></table></figure><p>我们再把 ji.o 放在前面，main.o 放在后面，并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ ji.o main.o</span><br><span class="line">$ ./a.out</span><br><span class="line">    wo you yi zhi ji.</span><br><span class="line">    ji zhong 1000</span><br><span class="line">    ji kai shi xiadan</span><br></pre></td></tr></table></figure><p>这说明了在不同编译单元的 nonlocal-static 对象的初始化次序是根据链接的时候的次序来排的，如果链接时排序出现问题就会导致初始化顺序出现问题，那么怎么做到我链接时目标文件即使是无序的也能保证初始化顺序是有序的呢？那就是用 local-static ！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ji.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ji</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ji()</span><br><span class="line">        :weight(<span class="number">1000</span>)</span><br><span class="line">    &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;wo you yi zhi ji.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">xiadan</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ji kai shi xiadan&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">w</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> weight; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># ji.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ji.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">ji <span class="title">getji</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ji j; <span class="comment">// 函数内的 static 对象都是 local static 对象！</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># dan.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ji.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dan</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    dan(ji j)</span><br><span class="line">        :weight(<span class="number">50</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ji zhong &quot;</span> &lt;&lt; j.w() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        j.xiadan();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># main.cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dan.h&quot;</span></span></span><br><span class="line"><span class="function">ji <span class="title">getji</span><span class="params">()</span></span>;</span><br><span class="line">ji j = getji();</span><br><span class="line"></span><br><span class="line"><span class="function">dan <span class="title">d</span><span class="params">(j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面那样进行连接测试，经测试发现，不管 main.o 在前还是在后都不会影响对象 j 和 d 的初始化次序。为什么可以这样呢？这个手法的基础在于：</p><p>C++ 保证，函数内的 local static 对象会在“该函数被调用期间”“首次遇上该对象之定义式”时被初始化。所以如果你以“函数调用”（返回一个 reference 指向 local static 对象）替换“直接访问 non-local static 对象”，你就获得了保证，保证你所获得的那个 reference 将指向一个历经初始化的对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《Effective C++》</li><li><a href="https://zhuanlan.zhihu.com/p/28659560">浅谈程序中的text段、data段和bss段</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;不同编译单元内定义之-non-local-static-对象的初始化次序&quot;&gt;&lt;a href=&quot;#不同编译单元内定义之-non-local-static-对象的初始化次序&quot; class=&quot;headerlink&quot; title=&quot;不同编译单元内定义之 non-local</summary>
      
    
    
    
    
  </entry>
  
</feed>
