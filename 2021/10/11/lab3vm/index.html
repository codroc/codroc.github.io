<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> MIT 6.s081 2020 Lab3 Page tables · Codroc Blog</title><meta name="description" content="MIT 6.s081 2020 Lab3 Page tables - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">MIT 6.s081 2020 Lab3 Page tables</h1><div class="post-info">2021年10月11日</div><div class="post-content"><p>这个实验是至今为止做的最难的一个了，做了估计有一礼拜。。。。主要的坑有两个，也是重要的知识点，下面会详细记录。</p>
<h4 id="为了方便在虚拟地址与物理地址之间的转换操作，做出以下宏定义："><a href="#为了方便在虚拟地址与物理地址之间的转换操作，做出以下宏定义：" class="headerlink" title="为了方便在虚拟地址与物理地址之间的转换操作，做出以下宏定义："></a>为了方便在虚拟地址与物理地址之间的转换操作，做出以下宏定义：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_U (1L <span class="meta-string">&lt;&lt; 4) // 1 -&gt; user can access</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF) <span class="comment">// PTE 前 10 位为标志位</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK) <span class="comment">// 找 PPN （level）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> uint64 <span class="keyword">pte_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="keyword">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p>现在的 OS 都有页表机制。因为这是解决进程间独立，提高安全性和可维护性的高效做法。</p>
<p><strong>页表机制是由软硬件共同实现的，</strong>这句话在之前就听说过，做了实验之后得到了深刻的理解。<strong>satp</strong> 这个寄存器就是实现分页机制最重要的一个寄存器。具体要去看 <a target="_blank" rel="noopener" href="https://riscv.org/technical/specifications/">The RISC-V Instruction Set Manual<br>Volume II: Privileged Architecture</a> 对应章节。总之对于 Sv39 地址空间的 riscv64 实现，给出一个虚拟地址，硬件会根据 satp 来将其映射成物理地址，可以用公式 PA = F(satp, VA) 来表示：</p>
<p><img src="https://s3.bmp.ovh/imgs/2021/10/a1fa6276b549f90b.png" alt="分页机制过程"></p>
<p>这一步从虚拟地址到物理地址的地址转换是硬件帮我们完成的，那软件要做什么事呢？想一想，页表是需要人工创建出来的呀，所以软件就是在做创建页表并建立映射的工作。</p>
<h3 id="1-Print-a-page-table"><a href="#1-Print-a-page-table" class="headerlink" title="1. Print a page table"></a>1. Print a page table</h3><p>实验说明：写一个函数，实现打印页表的功能。</p>
<p>函数签名：void vmprint(pagetable_t pagetable);</p>
<p>只要仔细查看 39 位虚拟地址的结构以及 PTE（页表条目）的结构，再对根页表做遍历就行了。</p>
<p>因为一个 PTE 占用 8 字节，所以一页页表只能存放 512 个 PTE，虚拟地址前 27 位的每 9 位来索引页表中的 PTE。经过三级索引后就能得到物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">    <span class="keyword">int</span> ptes_per_table = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ptes_per_table;++i) &#123;</span><br><span class="line">        uint64 *va = (uint64 *)(pagetable + i);</span><br><span class="line">        <span class="keyword">pte_t</span> l2pte = (<span class="keyword">pte_t</span>)*va;</span><br><span class="line">        <span class="comment">// if pte is invalid</span></span><br><span class="line">        <span class="keyword">if</span> ((l2pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">pagetable_t</span> l2pagetable = (<span class="keyword">pagetable_t</span>) PTE2PA(l2pte);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, l2pte, l2pagetable);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; ptes_per_table;++j) &#123;</span><br><span class="line">            uint64 *va = (uint64 *)(l2pagetable + j);</span><br><span class="line">            <span class="keyword">pte_t</span> l1pte = (<span class="keyword">pte_t</span>) *va;</span><br><span class="line">            <span class="keyword">if</span> ((l1pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">pagetable_t</span> l1pagetable = (<span class="keyword">pagetable_t</span>) PTE2PA(l1pte);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>, j, l1pte, l1pagetable);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; ptes_per_table;++k) &#123;</span><br><span class="line">                uint64 *va = (uint64 *)(l1pagetable + k);</span><br><span class="line">                <span class="keyword">pte_t</span> l0pte = (<span class="keyword">pte_t</span>) *va;</span><br><span class="line">                <span class="keyword">if</span> ((l0pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>, k, l0pte,</span><br><span class="line">                        PTE2PA(l0pte));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-A-kernel-page-table-per-process"><a href="#2-A-kernel-page-table-per-process" class="headerlink" title="2. A kernel page table per process"></a>2. A kernel page table per process</h3><p>实验说明：为每一个进程都分配一个内核页表。</p>
<p>这个实验是为 lab 3 做铺垫的。所以也不是很难。</p>
<p>总共分两个步骤</p>
<ol>
<li>分配一个进程时进行页表的分配和映射</li>
<li>结束一个进程时进行页表的解映射和销毁</li>
</ol>
<p>一个进程内核页表，包括以下映射：</p>
<ul>
<li>UART0，VIRTIO0，PLIC</li>
<li>内核代码段</li>
<li>内核数据段以及 RAM</li>
<li>TRAMPOLINE</li>
<li>内核栈</li>
</ul>
<p>不做 CLINT 的映射是因为，xv6 OS 限制了用户进程的最大虚拟地址必须小于内核最低处虚拟地址（0xC000000），而 CLINT 在虚拟地址 （0x2000000）处，因此会与用户进程虚拟地址冲突，因此不能对 CLINT 进行映射。</p>
<hr>
<p>首先在 struct proc 中添加一个<strong>进程内核页</strong>字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.h:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">···</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> proc_kern_pt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后学着 kvminit 函数实现一个 proc_kvminit 为 proc_kern_pt 创建内核映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line"><span class="comment">//my code:</span></span><br><span class="line"><span class="keyword">pagetable_t</span></span><br><span class="line">proc_kvminit()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> pkpt = (<span class="keyword">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>((<span class="keyword">char</span> *)pkpt, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  mappages(pkpt, UART0, PGSIZE, UART0, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  mappages(pkpt, VIRTIO0, PGSIZE, VIRTIO0, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  <span class="comment">// mappages(pkpt, CLINT, 0x10000, CLINT, PTE_R | PTE_W);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  mappages(pkpt, PLIC, <span class="number">0x400000</span>, PLIC, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  mappages(pkpt, KERNBASE, (uint64)etext-KERNBASE, KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  mappages(pkpt, (uint64)etext, PHYSTOP-(uint64)etext, (uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  mappages(pkpt, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> pkpt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>现在只剩下内核栈还没有完成映射了。</p>
<p>OS 为每一个进程都分配了一页内核栈，用于该进程陷入内核后执行内核函数。</p>
<p>阅读 procinit 函数来理解内核是如何给每个进程分配内核栈并做映射的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line"></span><br><span class="line"> <span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"> <span class="keyword">void</span></span><br><span class="line"> procinit(<span class="keyword">void</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">   initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">       initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">       <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">       <span class="comment">// guard page.</span></span><br><span class="line">       <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">       <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">         panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">       uint64 va = KSTACK((<span class="keyword">int</span>) (p - proc));</span><br><span class="line">       kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">       p-&gt;kstack = va;</span><br><span class="line">   &#125;</span><br><span class="line">   kvminithart();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>由于我们会在每个进程的地址空间中（由 proc_kern_pt 确定）做内核栈的映射，因此这里就不需要为内核页表做映射了。所以对以上代码进行修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">procinit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// my code:</span></span><br><span class="line">      <span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">      <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">      <span class="comment">// guard page.</span></span><br><span class="line"><span class="comment">//      char *pa = kalloc();</span></span><br><span class="line"><span class="comment">//      if(pa == 0)</span></span><br><span class="line"><span class="comment">//        panic(&quot;kalloc&quot;);</span></span><br><span class="line"><span class="comment">//      uint64 va = KSTACK((int) (p - proc));</span></span><br><span class="line"><span class="comment">//      kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span></span><br><span class="line"><span class="comment">//      p-&gt;kstack = va;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  kvminithart();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 procalloc 函数中添加分配内核栈并做映射的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>*</span></span><br><span class="line"><span class="class"> <span class="title">allocproc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">	···</span><br><span class="line"> found:</span><br><span class="line">   p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// my code:</span></span><br><span class="line">   p-&gt;proc_kern_pt = proc_kvminit();</span><br><span class="line">   <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">   <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">   uint64 va = TRAMPOLINE - <span class="number">2</span> * PGSIZE;</span><br><span class="line">   mappages(p-&gt;proc_kern_pt, va, PGSIZE, (uint64)pa, PTE_R | PTE_W);</span><br><span class="line">   p-&gt;kstack = va;</span><br><span class="line">   <span class="comment">///////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里把内核栈映射到 va = TRAMPOLINE - 2 * PGSIZE 还有一个好处，那就是如果栈溢出了，由于 va 以下的虚拟地址未作映射，会导致一个异常，以此来防止栈溢出而不自知。</p>
<p>然后实现在进程结束时解除映射并释放进程内核页表的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line"></span><br><span class="line"> <span class="comment">// my code:</span></span><br><span class="line"> <span class="keyword">extern</span> <span class="keyword">char</span> etext[];</span><br><span class="line"> <span class="keyword">void</span></span><br><span class="line"> proc_freekpagetable(<span class="keyword">pagetable_t</span> pagetable, uint64 kstack, uint64 sz) &#123;</span><br><span class="line">   uvmunmap(pagetable, UART0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   uvmunmap(pagetable, VIRTIO0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="comment">// uvmunmap(pagetable, CLINT, 0x10000 / PGSIZE, 0);</span></span><br><span class="line">   uvmunmap(pagetable, PLIC, <span class="number">0x400000</span> / PGSIZE, <span class="number">0</span>);</span><br><span class="line">   uvmunmap(pagetable, KERNBASE, ((uint64)etext - KERNBASE) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">   uvmunmap(pagetable, (uint64)etext, (PHYSTOP - (uint64)etext) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">   uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="comment">// uvmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 0);</span></span><br><span class="line">   uvmunmap(pagetable, kstack, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">   freewalk(pagetable);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>在 freeproc 函数中进行页表的释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">freeproc(struct proc *p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="keyword">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;proc_kern_pt)</span><br><span class="line">      proc_freekpagetable(p-&gt;proc_kern_pt, p-&gt;kstack, p-&gt;sz);</span><br><span class="line">  p-&gt;proc_kern_pt = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">///////////////////////////////////////////////////////////</span></span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后就是在 scheduler 函数中在切换进程前切换 进程内核页表，在没有进程运行时要切换回 内核页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">scheduler(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        <span class="comment">// my code:</span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;proc_kern_pt)); <span class="comment">// 切换进程前，先切换进程内核页表</span></span><br><span class="line">        sfence_vma();</span><br><span class="line">        <span class="comment">/////////////////////////////////////</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">        <span class="comment">// my code:</span></span><br><span class="line">        kvminithart(); <span class="comment">// 切换回内核页表</span></span><br><span class="line">        <span class="comment">/////////////////////////////////////</span></span><br><span class="line">		···</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-Simplify-copyin-copyinstr"><a href="#3-Simplify-copyin-copyinstr" class="headerlink" title="3. Simplify copyin/copyinstr"></a>3. Simplify <em>copyin/copyinstr</em></h3><p>实验说明：原本用户空间的内容 copy 到内核空间时需要对用户空间的地址进行代码上的转换（人工查页表进行转换），变成物理地址（由于内核数据段的虚拟地址就是物理地址）；lab 3 就想实现省去代码上的地址转换，让用户空间中的内容能直接 copy 到内核空间。</p>
<p>解析：其实就是在 lab 2 的基础上，将用户空间的映射添加到进程内核页表中去。</p>
<p>总共三个地方涉及到了<strong>用户申请内存并做映射</strong>的操作：</p>
<ul>
<li>fork</li>
<li>exec</li>
<li>sbrk</li>
</ul>
<p>仔细阅读 uvmalloc 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line">uvmalloc(<span class="keyword">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个函数是做了物理内存分配和映射的。但是我们不需要做真正的分配内存的事，只需要做个映射就足够了。因此自己实现一个 proc_uvmalloc:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line"><span class="comment">// my code:</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">proc_uvmalloc(<span class="keyword">pagetable_t</span> pt, <span class="keyword">pagetable_t</span> npt, uint64 oldsz, uint64 newsz) &#123;</span><br><span class="line">    oldsz = PGROUNDUP(oldsz);</span><br><span class="line">    <span class="keyword">for</span> (uint64 a = oldsz; a &lt; newsz; a += PGSIZE) &#123;</span><br><span class="line">        uint64 pa = walkaddr(pt, a); <span class="comment">// 根据 进程页表 和 虚拟地址 来获得对于的物理地址</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != mappages(npt, a, PGSIZE, pa, PTE_W|PTE_X|PTE_R)) <span class="comment">// 做映射</span></span><br><span class="line">            panic(<span class="string">&quot;proc_uvmalloc\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>uvmcopy 这个函数是 fork 中需要用到的，因为要复制父进程的页表以及内存镜像。由于它也是做了内存的分配和映射，而我们仅仅需要映射，因此也自己实现一个 proc_uvmcopy：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">uvmcopy(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    memmove(mem, (<span class="keyword">char</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// my code:</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">proc_uvmcopy(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz) &#123;</span><br><span class="line">    uint64 a;</span><br><span class="line">    <span class="keyword">for</span> (a = <span class="number">0</span>;a &lt; sz;a += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *pte = walk(old, a, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        <span class="keyword">int</span> flags = PTE_FLAGS(*pte) &amp; (~PTE_U);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != mappages(<span class="keyword">new</span>, a, PGSIZE, pa, flags))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fork 中需要改动的地方：由于 fork 函数的作用是，分配一个新进程并复制父进程的内存镜像，所以 uvmcopy 函数会被调用，在它被调用完后我们只需要调用自己实现的 proc_uvmcopy，为 进程内核页表 添加映射即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">kernel/proc.c:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    panic(<span class="string">&quot;fork:uvmcopy\n&quot;</span>);</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != proc_uvmcopy(np-&gt;pagetable, np-&gt;proc_kern_pt, p-&gt;sz))</span><br><span class="line">      panic(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">  <span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br></pre></td></tr></table></figure>
<p> exec ：一般在 fork 被调用完之后再调用，并根据可执行文件镜像，来加载内容到内存中。也就是说进程页表要重新分配过，同理 进程内核页表 也需要重新分配过。</p>
<p>这里就是那两个重要的坑出现的地方了：</p>
<ol>
<li><font color="red">进程内核页表 不能重新分配，而是在原来的基础上进行修改</font>，把用户地址映射部分全部清除掉，根据可执行文件镜像来重新做映射。为什么不能重新分配呢？因为从 用户态 执行到内核态的 exec 函数的整个函数调用过程都记录在内核栈中，如果重新分配进程内核页表，也就会重新分配内核栈，但这个新的内核栈无法跟原来的匹配起来（即使将原来内核栈中的内容 memmove 到新的，也会出错），会出现意想不到的错误。 </li>
<li><font color="red">解除 进程内核页表 中用户空间的映射这个过程需要在确保 exec 执行成功的前提下进行</font>，因为如果不这样的话，你提前解除了映射，在后面进程退出时会再解除以此从而导致 <strong>panic: uvmunmap: not map</strong> 错误。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">kernel/exec.c:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span></span><br><span class="line">  exec(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv) &#123;</span><br><span class="line">      ···</span><br><span class="line">          </span><br><span class="line">      <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">       sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">       sp -= sp % <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">         <span class="keyword">goto</span> bad;</span><br><span class="line">       <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="keyword">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// my code: 要在保证代码不会去到 bad 时，做 uvmunmap 并做用户空间的映射</span></span><br><span class="line">       uvmunmap(p-&gt;proc_kern_pt, <span class="number">0</span>, PGROUNDUP(p-&gt;sz) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">       proc_uvmalloc(pagetable, p-&gt;proc_kern_pt, <span class="number">0</span>, sz);</span><br><span class="line">       <span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">       <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">       <span class="comment">// value, which goes in a0.</span></span><br><span class="line">       p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Save program name for debugging.</span></span><br><span class="line">       <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">         <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">           last = s+<span class="number">1</span>;</span><br><span class="line">       safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Commit to the user image.</span></span><br><span class="line">       oldpagetable = p-&gt;pagetable;</span><br><span class="line">       p-&gt;pagetable = pagetable;</span><br><span class="line">       p-&gt;sz = sz;</span><br><span class="line">       p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">       p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">       proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// my code:</span></span><br><span class="line">       <span class="keyword">if</span> (p-&gt;pid == <span class="number">1</span>)</span><br><span class="line">           vmprint(p-&gt;pagetable);</span><br><span class="line">       <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line">       </span><br><span class="line">       bad:</span><br><span class="line">      	···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</div></article></div></main><footer><div class="paginator"><a href="/2021/10/18/lab4interruptHandler/" class="prev">上一篇</a><a href="/2021/09/18/lab2trap%E7%9A%84%E6%97%85%E9%80%94/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>