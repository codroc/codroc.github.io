<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> MIT 6.s081 2020 Lab6 Copy-on-write fork · Codroc Blog</title><meta name="description" content="MIT 6.s081 2020 Lab6 Copy-on-write fork - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">MIT 6.s081 2020 Lab6 Copy-on-write fork</h1><div class="post-info">2021年10月21日</div><div class="post-content"><h3 id="copy-on-write"><a href="#copy-on-write" class="headerlink" title="copy-on-write"></a>copy-on-write</h3><p>​        COW 在我看 <strong>深入理解计算机系统</strong> 这本书的时候就已经接触过了，可惜那时后理解不深，现在做完 VM 相关的 3 个 lab 后，算是彻彻底底明白了。其实理解后感觉很自然很简单。</p>
<p>​        Fork 可以创建出一个子进程，并与父进程有一致的内存映像。在之前的实现中，xv6 是通过 uvmcopy 为子进程分配物理内存并作映射，然后将对应的父进程中的内存映像 memmove 到子进程对应内存中。</p>
<p>​        所以这里每次 Fork 的时候都是实实在在分配了物理内存的！所以这就引出了一个问题了？有必要实实在在得给子进程分配物理内存吗？</p>
<p>​        我觉得，没必要！</p>
<p>​        因为很多 Fork 后面接着是调用 exec 系统调用来装载新的可执行文件的 Section 进入内存中，那么在装载前，我们就需要先释放用户进程空间映射到的物理内存，这样一来，之前 fork 时分配的动作相当于做了无用功；</p>
<p>​        除此之外，由于 text section 是存放代码的节，在 fork 后，父子进程是可以共享同的，这样还能节省物理内存。data section 也可以被用来共享，在发生写操作时才有必要为写的那个进程去分配物理页。</p>
<p>​        由于我们不做物理内存的实际分配以及 memmove 而是仅仅建立了映射，整个的 Fork 的执行速度将会大大提升。</p>
<p>​        在真正需要某一物理页的时候（写某一页物理页时）再分配也不迟呀！</p>
<p>COW 很好地利用了异常机制，在 Fork 中将父子进程对应用户空间的 PTEs 中的写权限位（PTE_W）置 0，这样任意进程在写 PTE 对应的物理页时都会发生一个页异常，紧接着我们只要在 usertrap 中添加一个由 <strong>写权限为0</strong> 导致的页异常处理逻辑即可！</p>
<p>由于现在一个物理页可能由多个进程进行共享，因此在进程结束释放资源的时候，需要查看它所释放的物理页是否有别的进程在引用。我们的实现方法是增加一个为每一个物理页设置一个 reference count 来表明有多少进程引用了这个物理页。</p>
<p>现在整理一下实现 lab 的思路：</p>
<ul>
<li>定义一个全局数组来记录物理页引用计数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rc[<span class="number">128</span>*<span class="number">1024</span>*<span class="number">1024</span> / PGSIZE]; <span class="comment">// 由于 virtio 板子可用的最大物理内存是 128M，所以最多 128M / 4K 页</span></span><br></pre></td></tr></table></figure>

<p>当一个物理页的 reference count = 0 时才进行真正的释放。</p>
<ul>
<li><p>在 <code>kalloc</code>中，被分配空闲页面的引用计数设为1。在 <code>kfree</code> 中，物理页的引用计数先减一，如果减一后 &lt;= 0（为什么是 &lt;= 而不是 = ？这是为初始化内存的时候准备的， <code>freerange</code> 会最新调用 <code>kfree</code> 一次），才会被加入空闲链表，减1和判&lt;=0必须整个是原子操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一段代码 加锁和解锁 是比较难理解的地方。</span></span><br><span class="line">kernel/kalloc.c:</span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kfree(<span class="keyword">void</span> *pa)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem.lock); <span class="comment">// 加锁</span></span><br><span class="line">  uint64 idx = ((uint64)pa - (uint64)PGROUNDUP((uint64)end)) / PGSIZE;</span><br><span class="line">  rc[idx]--;</span><br><span class="line">  <span class="keyword">if</span> (rc[idx] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      release(&amp;kmem.lock);<span class="comment">// 解锁</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  </span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>uvmcopy</code> 中不再实际分配内存而仅仅做映射，并对父进程的各个物理页的引用计数加一，同时父子两者的 PTEs 都要清除 Write 位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">uvmcopy(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="comment">// char *mem;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte) &amp; (~PTE_W);</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// set PTE_W to 0</span></span><br><span class="line">    *pte &amp;= ~PTE_W;</span><br><span class="line">    <span class="comment">// increament rc</span></span><br><span class="line">    uint64 idx = ((uint64)pa - (uint64)PGROUNDUP((uint64)end)) / PGSIZE;</span><br><span class="line">    acquire(&amp;kmem.lock); <span class="comment">// 这里一定要在修改共享资源之前加锁</span></span><br><span class="line">    rc[idx]++;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br></pre></td></tr></table></figure></li>
<li><p>改动 <code>usertrap</code> ，在一个 va 发生缺页异常时，尝试对它进行分配新的物理页并作映射和内容 copy，打开 PTE_W ，对原来所引用的物理页的引用计数 -1，如果失败了就走原来把它 kill 掉的逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> kernel/trap.c:</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span></span><br><span class="line"> usertrap(<span class="keyword">void</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    ···</span><br><span class="line">	syscall();</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// ok</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     uint64 cause = r_scause();</span><br><span class="line">     <span class="keyword">if</span> (cause == <span class="number">13</span> || cause == <span class="number">15</span>) &#123; <span class="comment">// 13 和 15 表示页异常，具体见 riscv 特权指令手册</span></span><br><span class="line">         uint64 va = r_stval(); <span class="comment">// 读取导致异常的那个虚拟地址</span></span><br><span class="line">         <span class="keyword">pte_t</span> *pte = walk(p-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">if</span> (pte == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span>) <span class="comment">// 如果是因为访问 stack guard page 导致的异常，就把进程 killed 掉</span></span><br><span class="line">             p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>) &#123; <span class="comment">// 如果是缺页异常；这个 lab 不会发生</span></span><br><span class="line">             <span class="comment">// lazy allocation, for now just kill it</span></span><br><span class="line">             p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_W) == <span class="number">0</span>) &#123; <span class="comment">// 如果是写物理页导致的页异常</span></span><br><span class="line">             <span class="keyword">char</span> *pa = (<span class="keyword">char</span> *)PTE2PA(*pte);</span><br><span class="line">             uint64 idx = ((uint64)pa - (uint64)PGROUNDUP((uint64)end)) / PGSIZE;</span><br><span class="line">             *pte |= PTE_W;</span><br><span class="line">             <span class="keyword">if</span> (rc[idx] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                 <span class="comment">// cow</span></span><br><span class="line">                 <span class="keyword">char</span> *mem = kalloc();</span><br><span class="line">                 <span class="keyword">if</span> (mem) &#123;</span><br><span class="line">                     memmove(mem, pa, PGSIZE);</span><br><span class="line">                     <span class="keyword">int</span> flags = PTE_FLAGS(*pte);</span><br><span class="line">                     *pte = PA2PTE(mem)|flags;</span><br><span class="line">                     <span class="comment">// decreament rc</span></span><br><span class="line">                     kfree((<span class="keyword">void</span>*)pa);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                     p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>copyout</code> 同 <code>usetrap</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">kernel/vm.c:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">copyout(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">    uint64 idx = ((uint64)pa0 - (uint64)PGROUNDUP((uint64)end)) / PGSIZE;</span><br><span class="line">    <span class="keyword">if</span> (rc[idx] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 这一页是共享的，要重新分配一页进行修改</span></span><br><span class="line">        <span class="keyword">char</span> *mem = kalloc();</span><br><span class="line">        <span class="keyword">if</span> (mem) &#123;</span><br><span class="line">            <span class="keyword">pte_t</span> *pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">            *pte |= PTE_W;</span><br><span class="line">            memmove(mem, (<span class="keyword">void</span>*)pa0, PGSIZE);</span><br><span class="line">            <span class="keyword">int</span> flags = PTE_FLAGS(*pte);</span><br><span class="line">            *pte = PA2PTE(mem)|flags;</span><br><span class="line">            <span class="comment">// decreament rc</span></span><br><span class="line">            kfree((<span class="keyword">void</span>*)pa0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        n = PGSIZE - (dstva - va0);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">            n = len;</span><br><span class="line">        memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">  </span><br><span class="line">        len -= n;</span><br><span class="line">        src += n;</span><br><span class="line">        dstva = va0 + PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">err:</span><br><span class="line">  uvmunmap(pagetable, <span class="number">0</span>, (uint64)PGROUNDUP(p-&gt;sz) / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2021/11/01/lab8locks/" class="prev">上一篇</a><a href="/2021/10/19/lab5lazyAllocation/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>