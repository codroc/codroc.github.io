<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> MIT 6.s081 2020 Lab4 Trap · Codroc Blog</title><meta name="description" content="MIT 6.s081 2020 Lab4 Trap - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">MIT 6.s081 2020 Lab4 Trap</h1><div class="post-info">2021年10月18日</div><div class="post-content"><p>lab4 是 traps 相关</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>系统调用的时候发生了什么？例如 write()？</p>
<ol>
<li>保存 32 个用户寄存器以及 pc</li>
<li>切换到 supervisor 模式</li>
<li>切换到内核页表</li>
<li>切换到内核栈</li>
<li>跳到 C 代码处</li>
</ol>
<p><strong>不要在 supervisor 模式执行用户代码！</strong>我之前就是这个思路（如何在内核空间中执行用户代码），想了很久都没有答案，然后看了别人的解析才发现，原来思路错了！</p>
<p>在 supervisor 模式，多了哪些特权？</p>
<ol>
<li>supervisor 模式下能够使用 CPU 的控制状态寄存器：<ol>
<li>satp       – 保存了页表物理地址</li>
<li>stvec      – ecall 会跳转到该寄存器保存的地址处，即 TRAMPOLINE</li>
<li>sepc       – ecall 会将用户 pc 保存到 sepc 中</li>
<li>sscratch – 保存 trapframe 的地址</li>
</ol>
</li>
<li>supervisor 模式下能够使用没有 PTE_U 标志的 PTEs</li>
</ol>
<p>除此之外，supervisor 模式没有什么特别的了！它也不能访问不在其页表中的内容！</p>
<h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p>添加一个 backtrace 函数，sys_sleep 调用这个函数后可以打印出函数调用栈</p>
<p><strong>实现思路：</strong></p>
<p>根据 RISCV ABI，ra 寄存器存放返回地址，sp 寄存器存放<strong>栈顶指针</strong>，s0 寄存器存放<strong>栈基指针</strong>。在 RISCV 上的汇编语言 ABI 规定，在开辟新的函数调用栈的时候，将上一个栈的 <strong>栈基指针</strong> 存到新的 <strong>栈基-16</strong> 处；将 ra 存放到新的 <strong>栈基-8</strong> 处。因此我们可以根据栈基指针遍历整个函数调用过程，直到 栈基指针 的值超过了内核栈。</p>
<p><strong>实现：</strong></p>
<p>这个实现还是很简单的。</p>
<p>首先我们要获取 <strong>栈基指针 s0：</strong>用 C 代码封装汇编指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel/riscv.h:</span><br><span class="line"></span><br><span class="line"><span class="comment">// my code:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line">r_fp()</span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span></span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后不断根据 栈基指针 来遍历内核栈即可，结束条件就是遍历超过一页时停止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kernel/<span class="built_in">printf</span>.c:</span><br><span class="line"></span><br><span class="line"><span class="comment">// my code:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">    uint64 fp = r_fp();</span><br><span class="line">    uint64 bottom = PGROUNDUP(fp), top = PGROUNDDOWN(fp);</span><br><span class="line">    <span class="keyword">while</span> (fp &lt; bottom &amp;&amp; fp &gt;= top) &#123; <span class="comment">// 只要 fp 超过了一页就结束</span></span><br><span class="line">        uint64 ra = *(uint64*)(fp - <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ra);</span><br><span class="line">        fp = *(uint64*)(fp - <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 sys_sleep 中调用就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kernel/sysproc.c:</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line">sys_sleep(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  backtrace();</span><br><span class="line">  <span class="comment">//////////////</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line">····</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>这个实验要我们实现一个定时器中断处理。</p>
<p>定时器中断是软中断，每过一个 ticks 都会触发定时器中断，即会从用户态陷入内核态处理定时器中断相关逻辑。</p>
<p>通过 sigalarm 系统调用来注册一个定时器中断（每隔多久执行以此中断处理函数）。添加系统调用的方式和 lab2 一样。这个注册是对应于某个具体进程的，因此需要在 struct proc 结构体中新添加几个字段来保存 <strong>间隔时间</strong> 和 <strong>中断处理函数虚拟地址</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">···</span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  uint64 alarm_interval; <span class="comment">// 中断时间间隔</span></span><br><span class="line">  fn handler;			  <span class="comment">// 中断处理函数</span></span><br><span class="line">  uint64 ticks_left;	  <span class="comment">// 还剩几个 ticks 就要触发中断</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，在 sys_sigalarm 中对当前申请注册中断处理的进程的结构体字段进行相应的填写，然后修改 trap.c/usertrap 中处理定时器中断的逻辑即可。</p>
<p>由于 系统调用、中断、异常都会将 TRAMPOLINE 作为内核的进入点，因此执行的是同一套逻辑，只是会根据 陷入内核的原因（scause 中的值）来区分到底是三类中的哪一类导致的 trap:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">···</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;···&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 scause == 8 则是系统调用，其他的则为中断或异常，可以根据 devintr() 的返回值来判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 if timer device,</span></span><br><span class="line"><span class="comment">// 1 if other device,</span></span><br><span class="line"><span class="comment">// 0 if not recognized.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">devintr()</span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// 外部中断</span></span><br><span class="line">    <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line">	···</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// 定时器中断</span></span><br><span class="line">    <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">    <span class="comment">// forwarded by timervec in kernelvec.S.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们只要添加一个处理定时器中断的逻辑即可。</p>
<p>这里这个逻辑该怎么实现呢？我刚开始一直琢磨着如何在内核态去执行用户空间的代码，想到了建立进程内核页表（即 lab3 的内容），但是一想这实验应该不会涉及到前面的内容呀。。。然后实在没办法才看了下解析，看到别人的思路后恍然大悟。</p>
<p><strong>思路：</strong>用户陷入内核时把 pc 值存在了 sepc 中，然后在 TRAMPOLINE 中做了进程状态的保存（将 sepc 保存到 p-&gt;trapframe-&gt;sepc 中）进入 usertrap；随后必定要按原路返回，通过 usertrapret 进入 userret 恢复进程的寄存器状态，最后依赖  sepc 回到下一条地址处或原地址处。我们只要在定时器中断处理中，将 中断函数的地址赋值给 p-&gt;trapframe-&gt;sepc，然后一切就水到渠成了！</p>
<p>当然这样的话相当于打乱了原来用户空间栈中的执行顺序，因此在 中断处理函数 结尾处要调用相应的 sigreturn 系统调用来回到原来的状态。而这个 sigreturn 的功能也就明了了，无非就是在 定时器中断处理中 在修改 p-&gt;trapframe-&gt;sepc 之前对整个 trapframe 做个备份保存起来，在 sigreturn 中用备份恢复 trapframe 就可以了。</p>
<p>在 struct proc 中新增一个 trapframe 备份字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">···</span><br><span class="line">  <span class="comment">// my code:</span></span><br><span class="line">  uint64 alarm_interval; <span class="comment">// 中断时间间隔</span></span><br><span class="line">  fn handler;			  <span class="comment">// 中断处理函数</span></span><br><span class="line">  uint64 ticks_left;	  <span class="comment">// 还剩几个 ticks 就要触发中断</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tmp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> inHandler;		  <span class="comment">// 表示是否有进程正在进行中断函数处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 usertrap 的定时器中断中保存 trapframe 备份：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> (which_dev == <span class="number">2</span>) <span class="comment">// 定时器中断</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (p-&gt;alarm_interval != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (p-&gt;ticks_left == <span class="number">1</span> &amp;&amp; p-&gt;inHandler == <span class="number">0</span>) &#123;</span><br><span class="line">                   p-&gt;inHandler = <span class="number">1</span>;</span><br><span class="line">                   *(p-&gt;tmp) = *(p-&gt;trapframe); <span class="comment">// copy saved user registers.</span></span><br><span class="line">                     p-&gt;ticks_left = p-&gt;alarm_interval;</span><br><span class="line">                     p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;</span><br><span class="line">               &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> (p-&gt;ticks_left == <span class="number">1</span>) <span class="comment">// it means p-&gt;inHandler == 1</span></span><br><span class="line">				p-&gt;ticks_left = <span class="number">1</span>; <span class="comment">// 等着另一个进程从中断处理函数中出来</span></span><br><span class="line">                <span class="keyword">else</span> p-&gt;ticks_left--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;···&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 sigreturn 中恢复 trapframe：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel/sysproc.c:</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line">sys_sigreturn(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    *(p-&gt;trapframe) = *(p-&gt;tmp);</span><br><span class="line">    p-&gt;inHandler = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></article></div></main><footer><div class="paginator"><a href="/2021/10/19/lab5lazyAllocation/" class="prev">上一篇</a><a href="/2021/10/11/lab3vm/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>