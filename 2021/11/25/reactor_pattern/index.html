<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 只用 EventLoop Poller Channel 实现 Reactor 模式 · Codroc Blog</title><meta name="description" content="只用 EventLoop Poller Channel 实现 Reactor 模式 - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">只用 EventLoop Poller Channel 实现 Reactor 模式</h1><div class="post-info">2021年11月25日</div><div class="post-content"><h3 id="用-C-实现一个简单的-Reactor-模式"><a href="#用-C-实现一个简单的-Reactor-模式" class="headerlink" title="用 C++ 实现一个简单的 Reactor 模式"></a>用 C++ 实现一个简单的 Reactor 模式</h3><p>何谓 Reactor 模式？（请看 Schmidt, D.C. (1995). Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events）</p>
<p>Reactor 模式的目的：<strong>处理多个客户端的并发服务请求</strong> （以下是论文 Reactor 的原话）</p>
<blockquote>
<p>The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. —— Reactor</p>
</blockquote>
<p>Reactor 模式的主要结构：</p>
<ul>
<li>Handles：标识由 OS 管理的一系列资源。这些资源通常包括：网络连接，打开文件，定时器，同步对象等等。Handle 可以看成是对这些资源的句柄，例如 fd (file description), timerfd。</li>
<li>Synchronous Event Demultiplexer：这在 Linux 中其实就是 select、poll、epoll。它利用 IO multiplexing 机制，通知用户哪些 Handles 已经 IO ready （即 调用 IO 函数不会导致 阻塞）。在我的实现中，epoll 接口被封装到了 Poller 类中。 </li>
<li>Initiation Dispatcher：用于注册、移除以及分发事件处理器 (Event Handler) 的接口。在我的实现中就是 Channel 类，它实现了事件分发机制。</li>
<li>Event Handler：这是一个接口，它实现了根据指定的 IO Event 来进行指定的操作。</li>
<li>Concrete Event Handler：这是 <strong>事件处理器</strong> 的具体实现。</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/11/24/oijO1J.png" alt="reactor 模式"></p>
<p>让我来解释一下整个流程：</p>
<ol>
<li>Concrete Event Handler 不断地监视是否有 IO event 发生</li>
<li>有 IO event 发生，Concrete Event Handler 立即通知 Handle，并让 Dispatcher 把 IO event 分发给对应的 event handler</li>
<li>event handler 处理 event</li>
<li>在处理 event 的过程中，可能又会注册需要 monitor 的 IO event 到 Concrete Event Handler 中去，并把对应的 event handler 注册到 Disapatcher 中去</li>
<li>回到步骤 1</li>
</ol>
<p>​    上述整个流程其实是管理所有文件描述符的所有事件（包括<em>可读</em>，<em>可写</em>，等等），并在适当时机执行指定的回调函数（event handler）。所以，这实际上是一个<strong>事件循环 （event loop）</strong>。因此我用 EventLoop 类来描述这一整个流程。</p>
<hr>
<p>一个简单的 Reactor 就仅仅需要以下三个类：</p>
<ul>
<li>EventLoop: 实现事件循环</li>
<li>Channel: 实现事件分发机制</li>
<li>Poller: 实现监视 IO event 并通知</li>
</ul>
<h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p>其核心是实现一个 <strong>事件循环</strong> <strong>loop</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Handle&gt; activeHandles;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        activeHandles.clear();</span><br><span class="line">    	<span class="comment">// 执行流程 1：一旦有 IO 事件发生就让 Poller 通知我</span></span><br><span class="line">        <span class="comment">// 并且把 对应 IO 的 Handle 告诉我 </span></span><br><span class="line">        Poller.poll(activeHandles);</span><br><span class="line">        <span class="comment">// 执行流程 2, 3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> handle : activeHandles)</span><br><span class="line">            Dispatcher.handleEvent(handle); <span class="comment">// 在具体 event handler 执行的过程中回去执行流程 4, 5</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里仅仅是伪代码，还有很多细节是需要补全的，例如 Dispatcher 会根据 handle 以及发生的 IO event 去挑选具体的 handler，这些细节可以全部封装到 Channel 中！所有实际的实现就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Channels*&gt; activeChannels;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        activeChannels.clear();</span><br><span class="line">    	<span class="comment">// 执行流程 1：一旦有 IO 事件发生就让 Poller 通知我</span></span><br><span class="line">        <span class="comment">// 并且把 对应 IO 的 Handle 告诉我 </span></span><br><span class="line">        Poller.poll(activeChannels);</span><br><span class="line">        <span class="comment">// 执行流程 2, 3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> channel : activeChannels)</span><br><span class="line">            channel-&gt;handleEvent(); <span class="comment">// 在具体 event handler 执行的过程中回去执行流程 4, 5</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h4><p>它就是对 整个 Epoll 机制的封装，即 epoll_create、epoll_wait、epoll_ctl</p>
<p>它无非就是通过 epoll_create 创建一个 epoll instance，然后 通过 epoll_ctl 注册用户需要让 OS monitor 的 IO event。所以代码整体骨架如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Poller::Poller()</span><br><span class="line">    : _epfd(epoll_create(<span class="number">1</span>))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Poller::~Poller() &#123;</span><br><span class="line">    ::close(_epfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Poller::poll</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;channel*&gt; activeChannel, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_events</span> <span class="title">events</span>[<span class="title">kMaxEvents</span>];</span></span><br><span class="line">    <span class="keyword">int</span> n = epoll_wait(_epfd, events, kMaxEvents, timeout); <span class="comment">// 等待 IO event 发生</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">        Channel* pChannel = <span class="keyword">reinterpret_cast</span>&lt;Channel*&gt;(events[i].data.ptr);</span><br><span class="line">        pChannel-&gt;setOccurEvents(events[i].events); <span class="comment">// 把 epoll 监测到的 IO 事件（可读、可写）记录到对应 Handle 的 channel 中去</span></span><br><span class="line">        activeChannel.push_back(pChannel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poller::update</span><span class="params">(Channel* pChannel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该函数用于注册 IO event 到 epoll instance 中去</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_events</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = pChannel.getWaitEvents(); <span class="comment">// 获取用户想要 OS monitor 的 IO event</span></span><br><span class="line">    ev.data.ptr = pChannel;</span><br><span class="line">    epoll_ctl(); <span class="comment">// 根据具体情况选择 EPOLL_CTL_ADD、EPOLL_CTL_MOD 或 EPOLL_CTL_DEL</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>​    这个类实现了 <strong>IO 事件分发</strong> 机制，也是 Reactor 模式中重要的一环。它记录了用户想要 epoll instance 帮忙 monitor 的 fd 的具体 IO event（例如可读事件），也记录了当 IO event 发生时应该进行的操作（即 event handler）。有时候我们要让 epoll instance 监视多种 IO event，例如 可读、可写，因此一旦 IO 可读，epoll instance 就会通知我们，我们此时需要记录下 具体是哪种 IO event 导致的通知以便做出正确的响应操作，因此也需要记录 已发生的 IO event</p>
<p>​    当前我的设计是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> EventCallBack = <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个 Channel 独属于 一个 EventLoop</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Channel</span><span class="params">(EventLoop*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 io multi-plexing 检测到的已发生的事件 记录在 _occurEvents 中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOccurEvents</span><span class="params">(<span class="keyword">uint32_t</span> occurEvents)</span> </span>&#123; _occurEvents = occurEvents; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">getWaitEvents</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _waitEvents; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置事件回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setReadEventCallBack</span><span class="params">(EventCallBack cb)</span> </span>&#123; _readEventCallBack = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWriteEventCallBack</span><span class="params">(EventCallBack cb)</span> </span>&#123; _writeEventCallBack = <span class="built_in">std</span>::move(cb);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把事件分发给具体的事件处理函数，它就是一个 Event Handler</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 epoll instance 关注 指定 事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">monitorReading</span><span class="params">()</span> </span>&#123; _waitEvents |= kReadEvent; update(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">monitorWriting</span><span class="params">()</span> </span>&#123; _waitEvents |= kWriteEvent; update(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kNoneEvent; <span class="comment">// 无任何 IO event</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kReadEvent; <span class="comment">// 可读 事件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kWriteEvent;<span class="comment">// 可写 事件</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将事件注册到 epoll instance 中去</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *_pLoop;</span><br><span class="line">    <span class="keyword">int</span> _fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> _waitEvents; <span class="comment">// 等待发生的事件</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _occurEvents; <span class="comment">// 已发生的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Concrete Event Handler</span></span><br><span class="line">    EventCallBack _readEventCallBack;</span><br><span class="line">    EventCallBack _writeEventCallBack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>这就是一个简单易用的 Reactor 模式的 C++ 实现。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>Schmidt, D.C. (1995). Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coding-diary/archive/2019/09/08/11484473.html">Reactor 模式</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/01f3fb1d4cb5">使用C++实现简单的Reactor模式</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2021/11/26/tcp_keep-alive/" class="prev">上一篇</a><a href="/2021/11/17/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>