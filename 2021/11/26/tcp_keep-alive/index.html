<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> TCP keep-alive · Codroc Blog</title><meta name="description" content="TCP keep-alive - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">TCP keep-alive</h1><div class="post-info">2021年11月26日</div><div class="post-content"><h2 id="TCP-保活机制"><a href="#TCP-保活机制" class="headerlink" title="TCP 保活机制"></a>TCP 保活机制</h2><h4 id="为什么需要-TCP-保活机制"><a href="#为什么需要-TCP-保活机制" class="headerlink" title="为什么需要 TCP 保活机制"></a>为什么需要 TCP 保活机制</h4><p>设想这种情况，TCP连接建立后，在一段时间范围内双发没有互相发送任何数据。思考以下两个问题：</p>
<ol>
<li>怎么判断对方是否还在线。这是因为，TCP对于非正常断开的连接系统并不能侦测到（比如网线断掉）。</li>
<li>长时间没有任何数据发送，连接可能会被中断。这是因为，网络连接中间可能会经过路由器、防火墙等设备，而这些有可能会对长时间没有活动的连接断掉。</li>
</ol>
<p>基于上面两点考虑，需要保活机制。</p>
<p><font color="green">其实 有一部分人认为，keep-alive 的检测应该放在 应用层 而不是 传输层。</font></p>
<h4 id="TCP保活机制的实现-Linux"><a href="#TCP保活机制的实现-Linux" class="headerlink" title="TCP保活机制的实现 (Linux)"></a>TCP保活机制的实现 (Linux)</h4><p><strong>系统级别：</strong></p>
<p>具体实现上有以下几个相关的配置：</p>
<ul>
<li>保活时间：默认7200秒（2小时）</li>
<li>保活时间间隔：默认75秒</li>
<li>保活探测数：默认9次                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </li>
</ul>
<p>可以通过 <code>/proc/sys/net/ipv4/</code> 接口查看</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/net/ipv4/tcp_keepalive_time</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/net/ipv4/tcp_keepalive_probes</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span></span><br></pre></td></tr></table></figure>

<p>或 通过 sysctl 查看</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysctl -A | grep keepalive</span></span><br></pre></td></tr></table></figure>

<h4 id="TCP-保活机制试验："><a href="#TCP-保活机制试验：" class="headerlink" title="TCP 保活机制试验："></a>TCP 保活机制试验：</h4><p>首先将 <strong>tcp_keepalive_time</strong> 设置为 20，即 20s 内 连接上没有数据收发就启动 间隔定时器；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 20 | sudo tee /proc/sys/net/ipv4/tcp_keepalive_time</span></span><br></pre></td></tr></table></figure>

<p>将 <strong>tcp_keepalive_intvl</strong> 设置为 5，即如果连接不活跃(开启定时器后，发送一个探测报文，但是没收到响应)，则每 5s 发送一个探测报文；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 5 | sudo tee /proc/sys/net/ipv4/tcp_keepalive_intvl</span></span><br></pre></td></tr></table></figure>

<p>将 <strong>tcp_keepalive_probes</strong> 设置为 2。即如果 发出探测报文后 对端没有回应则重复发送探测报文的次数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 2 | sudo tee /proc/sys/net/ipv4/tcp_keepalive_probes</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：修改 /proc 接口中的内容，不能用 vi/vim 编辑器，因为 vi/vim 的做法是先根据源文件创建一个 .swap 临时文件，而 /proc 中的内容都是 内存中的映像，根本不存在于 磁盘中，如果用 vi/vim 去修改必定得到 E667: Fsync failed 错误。</p>
</blockquote>
<p>在两台云服务器上进行实验，监听的一端设置 tcp keep-alive</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip: 124.70.82.205</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nohup sudo nc -l -p443 -k &amp; <span class="comment"># -k 表示开启 tcp keep-alive 机制</span></span></span><br></pre></td></tr></table></figure>

<p>在另一台服务器上对 124.70.82.205 443 发起连接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip: 112.124.36.253</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc 124.70.82.205 443</span></span><br></pre></td></tr></table></figure>

<p>在 ip: 124.70.82.205 上对 端口 443 进行抓包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tcpdump -i eth0 port 443</span></span><br><span class="line">10:45:09.891760 IP 124.70.82.205.https &gt; 112.124.36.253.44338: Flags [.], ack 2867648125, win 510, options [nop,nop,TS val 956683255 ecr 4136667676], length 0</span><br><span class="line">10:45:09.920708 IP 112.124.36.253.44338 &gt; 124.70.82.205.https: Flags [.], ack 1, win 229, options [nop,nop,TS val 4136687900 ecr 956519734], length 0</span><br><span class="line"></span><br><span class="line">10:45:30.115763 IP 124.70.82.205.https &gt; 112.124.36.253.44338: Flags [.], ack 1, win 510, options [nop,nop,TS val 956703479 ecr 4136687900], length 0</span><br><span class="line">10:45:30.144706 IP 112.124.36.253.44338 &gt; 124.70.82.205.https: Flags [.], ack 1, win 229, options [nop,nop,TS val 4136708124 ecr 956519734], length 0</span><br><span class="line"></span><br><span class="line">10:45:50.339764 IP 124.70.82.205.https &gt; 112.124.36.253.44338: Flags [.], ack 1, win 510, options [nop,nop,TS val 956723703 ecr 4136708124], length 0</span><br><span class="line">10:45:50.368749 IP 112.124.36.253.44338 &gt; 124.70.82.205.https: Flags [.], ack 1, win 229, options [nop,nop,TS val 4136728348 ecr 956519734], length 0</span><br></pre></td></tr></table></figure>

<p>可以看到 由于连接不活跃，每隔 一个 <strong>tcp_keepalive_time</strong> 都会向对端 发送一个 keep-alive 报文，来探测对端是否还“活着”。</p>
<p><strong>上述实验的过程描述：</strong></p>
<p>连接中启动保活功能的一端，在保活时间内连接处于非活动状态，则向对方发送一个保活探测报文，如果收到响应，则重置保活计时器，如果没有收到响应报文，则经过一个保活时间间隔后再次向对方发送一个保活探测报文，如果还没有收到响应报文，则继续，直到发送次数到达保活探测数，此时，对方主机将被确认为不可到达，连接被中断。</p>
<p>TCP保活功能工作过程中，开启该功能的一端会发现对方处于以下四种状态之一：</p>
<ol>
<li>对方主机仍在工作，并且可以到达。此时请求端将保活计时器重置。如果在计时器超时之前应用程序通过该连接传输数据，计时器再次被设定为保活时间值。</li>
<li>对方主机已经崩溃，包括已经关闭或者正在重新启动。这时对方的TCP将不会响应。请求端不会接收到响应报文，并在经过保活时间间隔指定的时间后超时。超时前，请求端会持续发送探测报文，一共发送保活探测数指定次数的探测报文，如果请求端没有收到任何探测报文的响应，那么它将认为对方主机已经关闭，连接也将被断开。</li>
<li>客户主机崩溃并且已重启。在这种情况下，请求端会收到一个对其保活探测报文的响应，但这个响应是一个重置报文段 <code>RST</code>，请求端将会断开连接。</li>
<li>对方主机仍在工作，但是由于某些原因不能到达请求端（例如网络无法传输，而且可能使用ICMP通知也可能不通知对方这一事实）。这种情况与状态2相同，因为TCP不能区分状态2与状态4，结果是都没有收到探测报文的响应。</li>
</ol>
<blockquote>
<p>tcp 保活机制的弊端：保活机制会占用不必要的带宽</p>
</blockquote>
<p><strong>保活机制是存在争议的，主要争议之处在于是否应在TCP协议层实现，有两种主要观点：其一，保活机制不必在TCP协议中提供，而应该有应用层实现；其二，认为大多数应用都需要保活机制，应该在TCP协议层实现。</strong></p>
<p><font color="red">这里修改的 /proc 中的变量会导致 全局（整个系统）的 tcp keep-alive 机制发送变化，那么能不能只针对一个 socket 进行 keep-alive 机制的制定呢？</font></p>
<h4 id="针对单个-socket-的保活机制"><a href="#针对单个-socket-的保活机制" class="headerlink" title="针对单个 socket 的保活机制"></a>针对单个 socket 的保活机制</h4><p>下面介绍针对单个 socket 连接 细粒度设置 的三个选项参数：</p>
<p><strong>保活时间：TCP_KEEPIDLE、保活探测时间间隔：TCP_KEEPINTVL、探测循环次数：TCP_KEEPCNT</strong>（可通过 man 7 tcp 中 Socket options 这一节查看细节）</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTEN_PORT 33333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUF 65536</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">echo_data</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">events_handle</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用TCP保活机制的相关代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_keepalive</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> keepalive_time, <span class="keyword">int</span> keepalive_intvl, <span class="keyword">int</span> keepalive_probes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> optval;</span><br><span class="line">    <span class="keyword">socklen_t</span> optlen = <span class="keyword">sizeof</span>(optval);</span><br><span class="line">    optval = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optval = keepalive_probes;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_TCP, TCP_KEEPCNT, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optval = keepalive_intvl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_TCP, TCP_KEEPINTVL, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optval = keepalive_time;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(sockfd, SOL_TCP, TCP_KEEPIDLE, &amp;optval, optlen)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failure.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> _argc, <span class="keyword">char</span>* _argv[])</span> </span>&#123;</span><br><span class="line">    run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == epfd) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create1 failure.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="keyword">int</span> listen_sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bzero(&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    seraddr.sin_port = htons(LISTEN_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bind(listen_sock, (struct sockaddr*)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr))) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind server addr failure.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(listen_sock, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = listen_sock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == epoll_ctl(epfd, EPOLL_CTL_ADD, listen_sock, &amp;ev)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl add listen_sock failure.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nfds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == nfds) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait failure.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> n = <span class="number">0</span>; n &lt; nfds; ++n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[n].data.fd == listen_sock) &#123;</span><br><span class="line">                <span class="keyword">int</span> conn_sock = accept(listen_sock, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == conn_sock) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept failure.&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accept from %s:%d\n&quot;</span>, inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)), ntohs(cliaddr.sin_port));</span><br><span class="line">                set_keepalive(conn_sock, <span class="number">120</span>, <span class="number">20</span>, <span class="number">3</span>);</span><br><span class="line">                setnonblocking(conn_sock);</span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = conn_sock;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == epoll_ctl(epfd, EPOLL_CTL_ADD, conn_sock, &amp;ev)) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl add conn_sock failure.&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                events_handle(epfd, events[n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(listen_sock);</span><br><span class="line">    close(epfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 33333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 65535</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client_handle</span><span class="params">(<span class="keyword">int</span> sock)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input args %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> server_port = SERVER_PORT;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> == argc) &#123;</span><br><span class="line">        server_port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bzero(&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr);</span><br><span class="line">    seraddr.sin_port = htons(server_port);</span><br><span class="line"></span><br><span class="line">    connect(sock, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    client_handle(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/s_lisheng/article/details/87288445">【TCP/IP详解】TCP保活机制</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/224595048">HTTP keep-alive和TCP keepalive的区别，你了解吗？</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2021/12/14/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/" class="prev">上一篇</a><a href="/2021/11/25/reactor_pattern/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>