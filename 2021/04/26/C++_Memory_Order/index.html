<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> C++ Memory Order · Codroc Blog</title><meta name="description" content="C++ Memory Order - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++ Memory Order</h1><div class="post-info">2021年4月26日</div><div class="post-content"><h1 id="C-Memory-Order"><a href="#C-Memory-Order" class="headerlink" title="C++ Memory Order"></a>C++ Memory Order</h1><h1 id="reordering-现象"><a href="#reordering-现象" class="headerlink" title="reordering 现象"></a>reordering 现象</h1><p>首先简要介绍下编译器和 CPU 的 reordering 现象。这也被叫做程序的乱序执行。</p>
<p>乱序是指代码的执行过程和代码的书写过程不一样，其中一些指令的顺序会被<strong>编译器或 CPU</strong> 调整。目的是为了提高程序的运行效率。</p>
<h2 id="编译器的-reordering-优化"><a href="#编译器的-reordering-优化" class="headerlink" title="编译器的 reordering 优化"></a>编译器的 reordering 优化</h2><p><strong>典型的就是通过调整指令顺序，在不改变程序语义的前提下，尽可能地减少寄存器的读取、存储次数，充分复用寄存器的存储值</strong></p>
<p>我们知道 C/C++ 源代码会通过编译汇编变成机器码。这里就可能产生 reordering 现象。例如：</p>
<p>假设有 3 条指令：</p>
<ol>
<li>计算变量 A 和 B 的值，并把结果 C 保存到寄存器 ax 中</li>
<li>指令需要用到 ax 寄存器，因此把 C 从 ax 中取出另存</li>
<li>指令使用 C 的值且与第二条指令无关</li>
</ol>
<p>按照上面描述的，如果不进行 reordering 优化，程序的执行顺序是这样：C 在第一条指令被执行过后存入寄存器 ax；在第二条指令执行时 C 不再存在于 ax 中；第三条指令执行时 C 被重新读入寄存器 ax 中。</p>
<p>而如果按照乱序执行呢？就可以出现这样的情况：C 在第一条指令被执行过后存入寄存器 ax；由于第二条指令与第三条指令不想关，因此先执行第三条指令，再执行第二条指令，这样就少了一次寄存器 ax 的读写操作，降低了重复读取的开销。</p>
<h2 id="CPU-的乱序执行优化"><a href="#CPU-的乱序执行优化" class="headerlink" title="CPU 的乱序执行优化"></a>CPU 的乱序执行优化</h2><p>当 C/C++ 源码编译汇编成机器码后，CPU 取机器码的顺序也可能是乱序的！也就是说，如果有两个线程 A 和 B，这两个线程执行同一份代码的指令顺序都可能不同，甚至于同一个线程，多次运行同一段代码，每次执行的指令顺序都可能不同，这就是 CPU 层面的 reordering 导致的。为什么呢？</p>
<p><strong>CPU 的执行原理</strong></p>
<p>现在的 CPU 采用流水线来执行指令。一条指令的执行被分为：取指、译码、访存、执行、写回等若干个阶段（具体可以看 [CSAPP]）。<strong>多条指令可以同时存在于流水线中，同时被执行</strong>。特别是，当代 CPU 的 IPC （每时钟执行指令数）一般都远大于 1，也就是所谓的多发射，很多命令都是并行执行的。比如，当代 CPU 当中（一个核心）一般会有 2 套以上的整数 ALU（加法器），2 套以上的浮点 ALU（加法器），往往还有独立的乘法器，以及，独立的 Load 和 Store 执行器。Load 和 Store 模块往往还有 8 个以上的队列，也就是可以同时进行 8 个以上内存地址（cache line）的读写交换。</p>
<p>例如现在有 3 条指令：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a++;</span><br><span class="line">b = f(a); <span class="comment">//不是指函数，而仅仅是指 b 依赖于 a；函数要更加复杂，函数会由更多条指令构成；</span></span><br><span class="line">c++</span><br></pre></td></tr></table></figure>

<p>那么可以画出它们的流水线：</p>
<img src="/2021/04/26/C++_Memory_Order/pipeline.PNG" class title="Pipeline">

<p>由于 b = f(a) 这条指令依赖于前面 a++ 这条指令的执行结果，所以 b = f(a) 将在执行阶段被阻塞，直到 a++ 写回阶段结束才能继续，这样就多出了<strong>空等时间</strong>。但是 c++ 是不依赖于前面两天指令的，如果把 c++ 移到第二条指令处，是不是可以先去执行 c++ 而不用阻塞 b = f(a) 指令了，这提高了程序的执行效率。</p>
<p>除此之外，由于现在是多核时代，每个核一般都有自己独立的 L1 Cache 和 L2 Cache 以及多核共享的 L3 Cache。一个线程在代码中对多个变量的一次修改，可能会以不同的次序同步到另一个线程所在的核心上。不同线程对数据的需求不同，按需同步也会导致 CacheLine 的读序和写序不同。</p>
<p>如果其中第一个变量扮演了开关的作用，控制对后续变量的访问。那么当这些变量被一起同步到其他核心时，更新顺序可能变了，第一个变量未必是第一个更新的，然而其他线程还认为它代表着其他变量有效，去访问了实际已被删除的变量，从而导致未定义的行为。比如下面的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line"><span class="comment">// ready was initialized to false</span></span><br><span class="line">p.init();</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread2</span></span><br><span class="line"><span class="keyword">if</span> (ready) &#123;</span><br><span class="line">    p.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从人的角度，这是对的，因为线程 2 在 ready 为 true 时才会访问 p，按线程 1 的逻辑，此时 p 应该初始化好了。但对多核机器而言，这段代码可能难以正常运行： </p>
<ul>
<li>线程 1 中的 ready = true 可能会被编译器或 cpu 重排到 p.init() 之前，从而使线程 2 看到 ready 为 true 时，p 仍然未初始化。这种情况同样也会在线程 2 中发生，p.bar() 中的一些代码可能被重排到检查 ready 之前</li>
<li>即使没有重排，ready 和 p 的值也会独立地同步到线程 2 所在核心的 cache，线程 2 仍然可能在看到 ready 为 true 时看到未初始化的 p</li>
</ul>
<h1 id="六种内存序"><a href="#六种内存序" class="headerlink" title="六种内存序"></a>六种内存序</h1><p>C++ 有六种内存序：</p>
<p>std::memory_order 定义于头文件 <atomic></atomic></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">memory_order</span> &#123;</span></span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure>

<p>可以分为四大类：</p>
<ol>
<li>宽松顺序</li>
<li>释放获得顺序</li>
<li>释放消费顺序</li>
<li>序列一致顺序</li>
</ol>
<p>下面详细介绍下这四大类。</p>
<hr>

<h2 id="宽松顺序-Relaxed-Ordering"><a href="#宽松顺序-Relaxed-Ordering" class="headerlink" title="宽松顺序 (Relaxed Ordering)"></a>宽松顺序 (Relaxed Ordering)</h2><p>带标签 <code>memory_order_relaxed</code> 的原子操作无同步操作；它们不会在共时的内存访问间强加顺序。它们只保证原子性和修改顺序一致性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; x = <span class="number">0</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; y = <span class="number">0</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="comment">// thread 1:</span></span><br><span class="line">r1 = y.load(<span class="built_in">std</span>::memory_order_relaxed); <span class="comment">// A</span></span><br><span class="line">x.store(r1, <span class="built_in">std</span>::memory_order_relaxed); <span class="comment">// B</span></span><br><span class="line"><span class="comment">// thread 2:</span></span><br><span class="line">r2 = x.load(<span class="built_in">std</span>::memory_order_relaxed); <span class="comment">// C </span></span><br><span class="line">y.store(<span class="number">42</span>, <span class="built_in">std</span>::memory_order_relaxed); <span class="comment">// D</span></span><br></pre></td></tr></table></figure>

<p>之前在对 reordering 现象的介绍中已经说了，那些没有相互依赖的指令可能会被编译器或（和）CPU reorder。那么看上面的代码，thread 1 中 A 和 B 相互依赖并且是原子的，对的，有时候load和store都需要原子地进行，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> i = <span class="number">0</span>; <span class="comment">// global variable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread-1:</span></span><br><span class="line">i = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//Thread-2:</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br></pre></td></tr></table></figure>

<p>C++ 并不保证 <code>i = 100</code> 是原子操作，因为在某些 CPU Architecture 中，写入 <code>int64_t</code> 需要两个 CPU 指令，所以 Thread-2 可能会读取到 <code>i</code> 在赋值过程的中间状态。</p>
<p>继续话题。因此 A 和 B 必定按照代码书写的顺序执行。再看 C 和 D，它们是原子的但是并不相互依赖，所以编译器或 CPU 可能对它们进行 reorder，这里加的标签是 <code>memory_order_relaxed</code>，它只保证原子性和修改顺序一致性，不保证同步操作。因此执行完上面的程序，可能出现<code>r1 == r2 == 42</code>。理解这一点并不难，因为编译器允许调整 C 和 D 的执行顺序。如果程序的执行顺序是 D -&gt; A -&gt; B -&gt; C，那么就会出现<code>r1 == r2 == 42</code>。</p>
<p>总结：对于 <code>memory_order_relaxed</code> 来说，无关系依赖的指令仍旧有可能被编译器或 CPU reorder！</p>
<hr>


<h2 id="释放获得顺序-Release-Acquire-Ordering"><a href="#释放获得顺序-Release-Acquire-Ordering" class="headerlink" title="释放获得顺序 (Release-Acquire Ordering)"></a>释放获得顺序 (Release-Acquire Ordering)</h2><p>若线程 A 中的一个原子存储带标签 <code>memory_order_release</code> ，而线程 B 中来自同一变量的原子加载带标签 <code>memory_order_acquire</code> ，则从线程 A 的视角<em>先发生于</em>原子存储的所有内存写入（非原子及宽松原子的），在线程 B 中成为<em>可见副效应</em>，即一旦原子加载完成，则保证线程 B 能观察到线程 A 写入内存的所有内容。</p>
<p>什么意思呢？</p>
<ol>
<li>首先 <code>store()</code> 是使用标签 <code>memory_order_release</code> 的，而 <code>load()</code> 是使用标签 <code>memory_order_acquire</code> 的，这其实是遵循先 release 再 acquire（即先写再读）的规则</li>
<li><em>可见副效应</em>是指，在 B 线程中原子加载后面的指令，它们能看到 A 线程在执行完原子存储后对内存产生的所有变化，这是什么意思？难道原来不加 <code>release-acquire</code> 标签就看不到吗？是的，可能由于 reorder 导致原先在 A 线程原子存储前的指令被换到了原子存储后，这样线程 B 就看不到本应看到的内存变化了。</li>
<li>注意第 2 条说的<em>B 线程中原子加载后面的指令</em>，也就是说 B 线程原子加载后面的指令也不能被 reorder 到原子加载前面，因为如果有指令被移到了前面，那该条指令就看不到 A 线程对内存产生的变化了。</li>
</ol>
<p>总结：在这种模型下，<code>store()</code> 使用 <code>memory_order_release</code>，而 <code>load()</code> 使用 <code>memory_order_acquire</code>。这种模型有两种效果，第一种是可以限制 CPU 指令的重排:</p>
<ul>
<li>在 <code>store()</code> 之前的所有读写操作，不允许被移动到这个 <code>store()</code> 的后面。</li>
<li>在 <code>load()</code> 之后的所有读写操作，不允许被移动到这个 <code>load()</code> 的前面。</li>
</ul>
<p>看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt; ptr;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p  = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);             <span class="comment">// A</span></span><br><span class="line">    data = <span class="number">42</span>;                                              <span class="comment">// B</span></span><br><span class="line">    ptr.store(p, <span class="built_in">std</span>::memory_order_release);                <span class="comment">// C</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p2;</span><br><span class="line">    <span class="keyword">while</span> (!(p2 = ptr.load(<span class="built_in">std</span>::memory_order_acquire)))     <span class="comment">// D</span></span><br><span class="line">        ;</span><br><span class="line">    assert(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// 绝无问题                      // E</span></span><br><span class="line">    assert(data == <span class="number">42</span>); <span class="comment">// 绝无问题                          // F</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们分析下整个过程：</p>
<ul>
<li>这是 Release-Acquire Ordering</li>
<li>A B 不允许移到 C 后面，E F 不允许被移到 D 前面</li>
<li>while 循环直到 C 执行完后才会出循环，而一旦 C 执行完了，那么 data = 42，*ptr = “Hello” 是肯定的了</li>
<li>因此 E 和 F 的 assert 必定为真</li>
</ul>
<blockquote>
<p>注意：虽然 Release-Acquire Ordering 规定 store 前的指令不能移到 store 后面，但是 store 前的可以被 reorder！也就是 A 和 B 可能会乱序执行（虽然在这里好像没什么必要这么做）</p>
</blockquote>
<hr>

<h2 id="释放消费顺序-Release-Consume-Ordering"><a href="#释放消费顺序-Release-Consume-Ordering" class="headerlink" title="释放消费顺序 (Release-Consume Ordering)"></a>释放消费顺序 (Release-Consume Ordering)</h2><p>若线程 A 中的原子存储带标签 <code>memory_order_release</code> 而线程 B 中来自同一对象的读取存储值的原子加载带标签 <code>memory_order_consume</code> ，则线程 A 视角中<em>先发生于</em>原子存储的所有内存写入（非原子和宽松原子的），会在线程 B 中该加载操作所<em>携带依赖</em>进入的操作中变成<em>可见副效应</em>，即一旦完成原子加载，则保证线程B中，使用从该加载获得的值的运算符和函数，能见到线程 A 写入内存的内容。</p>
<p>这个内存序只是在上面 Release-Acquire Ordering 的内存序的基础上放开了一点约束：<strong>携带依赖</strong></p>
<p>也就是说保证那些跟原子加载操作相依赖的指令不会被 reorder 到原子加载前面。</p>
<p>看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt; ptr;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p  = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);                     <span class="comment">// A</span></span><br><span class="line">    data = <span class="number">42</span>;                                                      <span class="comment">// B</span></span><br><span class="line">    ptr.store(p, <span class="built_in">std</span>::memory_order_release);                        <span class="comment">// C</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p2;</span><br><span class="line">    <span class="keyword">while</span> (!(p2 = ptr.load(<span class="built_in">std</span>::memory_order_consume)))             <span class="comment">// D</span></span><br><span class="line">        ;</span><br><span class="line">    assert(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// 绝无出错： *p2 从 ptr 携带依赖         // E</span></span><br><span class="line">    assert(data == <span class="number">42</span>); <span class="comment">// 可能也可能不会出错： data 不从 ptr 携带依赖 // F</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们分析一下：</p>
<ul>
<li>这是 Release-Consume Ordering</li>
<li>store 前面的保证不会出现在 store 后面，因此 A B 必定在 C 前面（但 A B 还是 B A 就不知道了）</li>
<li>load 后面与 ptr 相依赖的指令不会出现在 load 前面，因此 E（*p2 依赖 ptr） 必定在 store 后面，而 F 可能出现在 D 前面</li>
</ul>
<hr>

<h2 id="序列一致顺序-Sequential-Consistency-Ordering"><a href="#序列一致顺序-Sequential-Consistency-Ordering" class="headerlink" title="序列一致顺序 (Sequential Consistency Ordering)"></a>序列一致顺序 (Sequential Consistency Ordering)</h2><p>带标签 <code>memory_order_seq_cst</code> 的原子操作不仅以与 Release-Acquire Ordering 相同的方式排序内存（在一个线程中<em>先发生于</em>存储的任何结果都变成进行加载的线程中的<em>可见副效应</em>），还对所有带此标签的内存操作建立<em>单独全序</em>。</p>
<p>这句话的前半句只要理解了 Release-Acquire Ordering 就明白了，就是说的 store 前的指令不允许出现在 store 后，load 后的指令不允许出现在 load 前；而后半句表示所有使用 seq_cst 的指令有严格的全序关系</p>
<p><font color="red"><a target="_blank" rel="noopener" href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/atomic_instructions.md">brpc</a> 对这个也做了不错的介绍！</font></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/-citywall123/p/13336477.html">乱序执行 cnblog</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/atomic/memory_order">cppreference</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/atomic_instructions.md">brpc</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24301047/answer/1193956492">知乎</a></li>
<li><a target="_blank" rel="noopener" href="http://senlinzhan.github.io/2017/12/04/cpp-memory-order/">http://senlinzhan.github.io/2017/12/04/cpp-memory-order/</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2021/03/27/non-local_static_object_initialization/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>