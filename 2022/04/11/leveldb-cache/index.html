<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> leveldb cache · Codroc Blog</title><meta name="description" content="leveldb cache - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">leveldb cache</h1><div class="post-info">2022年4月11日</div><div class="post-content"><h1 id="leveldb-笔记一：缓存系统-Cache"><a href="#leveldb-笔记一：缓存系统-Cache" class="headerlink" title="leveldb 笔记一：缓存系统 Cache"></a>leveldb 笔记一：缓存系统 Cache</h1><h3 id="LRUHandle"><a href="#LRUHandle" class="headerlink" title="LRUHandle"></a>LRUHandle</h3><blockquote>
<p>An entry is a variable length heap-allocated structure. 一个变长结构体对象，它被分配在堆上。</p>
</blockquote>
<p>LRUHandle 是 <strong>双向循环链表</strong>（为了实现 LRU 替换策略）的节点。在该链表上按访问时间排序。</p>
<p>变长体现在哪里？首先看它的结构体定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;</span><br><span class="line">  <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);</span><br><span class="line">  LRUHandle* next_hash;	<span class="comment">// Hash 表指针，同样 Hash 值的 Handler 串接起来</span></span><br><span class="line">  LRUHandle* next;</span><br><span class="line">  LRUHandle* prev;</span><br><span class="line">  <span class="keyword">size_t</span> charge;  <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length;</span><br><span class="line">  <span class="keyword">bool</span> in_cache;     <span class="comment">// Whether entry is in the cache.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;     <span class="comment">// References, including cache reference, if present.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;     <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next is only equal to this if the LRU handle is the list head of an</span></span><br><span class="line">    <span class="comment">// empty list. List heads never have meaningful keys.</span></span><br><span class="line">    assert(next != <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Slice(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除了 key_data 字段，其他都是固定长度的。因此可以这样认为，LRUHandle 是一个<strong>尾部长度可变</strong>的对象。</p>
<p><strong>存疑一：</strong>为什么不是 char* key_data 而是直接把 key 存储在 LRUHandle 中呢？为什么用 <code>char key_data[1]</code> 而不是 柔性数组 <code>char key_data[]</code></p>
<blockquote>
<p>Note:  GCC 由于对 C99 的支持，允许定义 char key_data[ ] 这样的柔性数组（Flexible Array)。但是由于 c++ 标准并不支持柔性数组的实现，这里定义为 key_data[1]，这也是 c++ 中的标准做法。</p>
</blockquote>
<p><strong>回答一：</strong>如果存的是指针，那么指针指向的 key 对象就也需要进行 malloc 分配空间，那么带上 LRUHandle 则需要 malloc 两次。如果把 key 对象和 LRUHandle 放在一块，只需要 malloc 一次，而 malloc 是有可能会陷入内核的，因此尽量减少 malloc 的次数，可以加快速度。</p>
<h3 id="HandleTable"><a href="#HandleTable" class="headerlink" title="HandleTable"></a>HandleTable</h3><p>它其实就是一个简单的 HashTable 先看它的成员变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleTable</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">uint32_t</span> length_;</span><br><span class="line">    <span class="keyword">uint32_t</span> elems_;</span><br><span class="line">    LRUHandle** list_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它使用开链法来解决 hash 冲突，总共设置 length_ 个 bucket，每个 bucket 就是一条单向链表，每条链表的节点就是 LRUHandle，这里可以和 LRUHandle 结构体中的 next_hash 字段结合起来。elems_ 就表示了 HandleTable 中总共有多少个元素，可以用于之后对 hash table 进行 Resize。</p>
<p>刚开始 hash table 自然是空的，因此直接调用 Resize，进行初始化。</p>
<p>Resize 需要考虑两种情况：</p>
<ol>
<li>hash table 为空时进行 Resize</li>
<li>hash table 不为空时进行 Resize</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (new_length &lt; elems_) &#123;</span><br><span class="line">        new_length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">    <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="keyword">sizeof</span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// hash table 不为空时，需要考虑：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">        LRUHandle* h = list_[i];</span><br><span class="line">        <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            LRUHandle* next = h-&gt;next_hash; <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">uint32_t</span> hash = h-&gt;hash; <span class="comment">// 2</span></span><br><span class="line">            LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)]; <span class="comment">// 2</span></span><br><span class="line">            h-&gt;next_hash = *ptr;</span><br><span class="line">            *ptr = h;</span><br><span class="line">            h = next; <span class="comment">// 1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hash table 不为空时，需要考虑：</span></span><br><span class="line">    assert(elems_ == count);</span><br><span class="line">    <span class="keyword">delete</span>[] list_;</span><br><span class="line">    list_ = new_list;</span><br><span class="line">    length_ = new_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实要看懂这段代码，唯一的难点是理解 LRUHandle** 到底是个什么东西，它其实就是一个 数组，数组中的每一个元素就是 LRUHandle 链表<strong>头节点的指针</strong>。然后在 while 循环中使用的是 链表的 <strong>头插法</strong></p>
<p>接下来就是 Insert、Remove、Lookup 和 FindPointer，这里只需要看懂 FindPointer，其他的就自然看懂了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;key())) &#123;</span><br><span class="line">        ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ptr </code> 是单向链表头节点，这个在之前已经说过了。在这里 <code>LRUHandle** ptr = &amp;list_[hash &amp; (length_ - 1)];</code> 的确是这样的，但是在 while 循环中，<code>ptr</code> 已经不是这个意思了，它是 LRUHandle::next_hash 的地址；而 <code>*ptr</code> 仍然是指向 LRUHandle 节点的指针。自然，返回值也就是 LRUHandle::next_hash 的地址。<strong>因此在后续的 Insert、Remove 操作中，我们直接修改 <code>ptr</code> 所指地址处的值（也就是 LRUHandle::next_hash 的值）就可以达到我们需要的效果。</strong></p>
<h3 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h3><p>逻辑上，设计成列表，一个 Hash Table。两个列表用于存储 LRUHandle 节点，由循环双向链表来实现 LRU 替换策略，Hash Table 用于加速对节点的索引 O(1)，用开链法解决 hash 冲突。</p>
<p>两链表，一哈希表：</p>
<ul>
<li>LRUHandle <strong>lru_</strong> GUARDED_BY(mutex_); // 虚拟头节点</li>
<li>LRUHandle <strong>in_use_</strong> GUARDED_BY(mutex_); // 虚拟头节点</li>
<li>HandleTable <strong>table_</strong> GUARDED_BY(mutex_);</li>
</ul>
<p>这里两个链表的关系是这样的，我们可以把 LRUCache 内的 Handle 分为四个状态：</p>
<p><img src="https://s4.ax1x.com/2022/01/13/7MccTI.png"></p>
<ol>
<li>*in use (ref=2)*：该 Handle 在 HandleTable 中，并且串联在 <code>in_use_</code> 链表中；由于该 Handle 既被外部使用，也被 <code>in_use_</code> 链表使用，因此有 ref=2；</li>
<li>*in lru (ref=1)*：该 Handle 在 HandleTable 中，并且串联在 <code>lru_</code> 链表中；由于该 Handle 只被 <code>lru_</code> 引用，因此 ref=1；</li>
<li>*not in lru, not in table (ref=1)*：该 Handle 不在链表中也不再 HandleTable 中，但是仍然被外部引用而未释放，因此 ref=1；</li>
<li>*not in lru, not in table (ref=0)*：该 Handle 不在链表中也不再 HandleTable 中，也不被外部使用，因此 ref=0；</li>
</ol>
<p>在 LRUCache 析构时，必须保证 in_use 链表为空，也就是说<strong>没有被外部引用并且在链表中</strong>（即状态 1）的节点。之后，就可以对 lru_ 链表中的节点逐一 调用 Unref 来让节点的 deleter 去释放资源。</p>
<p>LRUCache 类中有一点很符合 morden c++ 的写法，也很值得我学习：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Cache::Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span></span>;</span><br><span class="line">    <span class="function">Cache::Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Cache::Handle* handle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Remove</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Append</span><span class="params">(LRUHandle* <span class="built_in">list</span>, LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">FinishErase</span><span class="params">(LRUHandle* e)</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <strong>公共接口</strong> 中，用 <code>Cache::Handle*</code> 来表示 <code>LRUHandle*</code>；而在 <strong>私有接口</strong> 中，仍旧保留 <code>LRUHandle*</code>；这其实是向外隐藏了 <code>LRUHandle*</code>；</p>
<h3 id="ShardedLRUCache"><a href="#ShardedLRUCache" class="headerlink" title="ShardedLRUCache"></a>ShardedLRUCache</h3><p>这个类其实就是用来减少 race condition 的，因为 leveldb 缓存系统支持并发，因此要对每一个 LRUCache 加互斥锁，如果只有一个 LRUCache 的话，虽然在外部看来是并发访问了，但是由于为了保证线程安全，在方法临界区内所有访问都被串行化了。但是如果对 Cache 进行分片，也就是增加 LRUCache 的数量（其实就是搞一个 LRUCache 数组），通过 hash 的方式索引到具体某一个 LRUCache 进行访问，这样 LRUCache 之间是可以并行访问并保证线程安全的，这就提高了整个缓存系统的并发性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LRUCache shard_[kNumShards]; <span class="comment">// 分片缓存，通过 hash 方式来索引到某一个 LRUCache</span></span><br><span class="line">    port::Mutex id_mutex_;</span><br><span class="line">    <span class="keyword">uint64_t</span> last_id_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2022/04/22/SSL/" class="prev">上一篇</a><a href="/2022/04/08/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>