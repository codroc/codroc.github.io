<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> cs144 lab3 the TCP sender · Codroc Blog</title><meta name="description" content="cs144 lab3 the TCP sender - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">cs144 lab3 the TCP sender</h1><div class="post-info">2022年4月2日</div><div class="post-content"><h1 id="cs144-lab3-the-TCP-sender"><a href="#cs144-lab3-the-TCP-sender" class="headerlink" title="cs144 lab3: the TCP sender"></a>cs144 lab3: the TCP sender</h1><p>在前面的实验中，我们已经接触到了，seqno、ackno、SYN、FIN 标志、checksum 等技术。这个实验涉及到一个重要技术：<strong>超时重传</strong>。这是解决不可靠网络出现分组丢失问题的重要技术之一。</p>
<p>如何在可能丢失分组的不可靠网络之上进行可靠传输？<strong>ARQ 协议！</strong></p>
<h4 id="停等-ARQ-协议"><a href="#停等-ARQ-协议" class="headerlink" title="停等 ARQ 协议"></a>停等 ARQ 协议</h4><p>停止并等待协议的工作原理如下：</p>
<ol>
<li>发送点对接收点发送数据包，然后等待接收点回复ACK并且开始计时。</li>
<li>在等待过程中，发送点停止发送新的数据包。</li>
<li>当数据包没有成功被接收点接收时候，接收点不会发送ACK.这样发送点在等待一定时间后，重新发送数据包。</li>
<li>反复以上步骤直到收到从接收点发送的ACK.</li>
</ol>
<h4 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h4><p>为了克服停止并等待ARQ协议长时间等待ACK的缺点。这个协议会连续发送一组数据包，然后再等待这些数据包的ACK.</p>
<p>本实验的实现是 <strong>连续 ARQ 协议</strong>。</p>
<p>需要注意的点：</p>
<ul>
<li>SYN、FIN 也会占用窗口空间</li>
<li>根据 receiver 发来的 segment 来设置 sender 的窗口；发第一个 syn segment 前，将 sender 的窗口设置为 1</li>
<li>当 peer 的窗口大小为 0 时，把发送窗口大小设置为 1</li>
</ul>
<h4 id="一些疑惑的点："><a href="#一些疑惑的点：" class="headerlink" title="一些疑惑的点："></a><strong>一些疑惑的点：</strong></h4><p>receiver 会发回来一个 <strong>ackno</strong> 和 <strong>windown_size</strong> 。<strong>receiver 发回的 ackno 表示的是 ackno 之前的所有 segment 都已经被成功接收并 reassemble</strong>。这也就是说对与一个 ByteStream 而言，receiver 已经把 [0, unwrap(ackno, isn, checkpoint) ) 范围的元素（在这里就是一个字节） reassemble 了！并且 receiver 还可以接受 [unwrap(ackno, isn, checkpoint), unwrap(ackno, isn, checkpoint) + window_size) 范围的元素，那么对于 sender 来说，它能的发送 ByteStream 的范围就是 [_next_seqno, unwrap(ackno, isn, checkpoint) + window_size)；也就是说发送窗口大小是 <code>unwrap(ackno, isn, checkpoint) + window_size - _next_seqno</code>。</p>
<p>本实验对于超时的 segment 的处理是这样的：仅仅设置一个定时器（<em>注意不是像 SR 中那样每一个 segment 都设一个 timer</em>），如果超时了，就重传最早的那个（seqno 最靠前的）segment，并把 RTO 乘倍。 </p>
<p><strong>sender 要发哪些东西给 peer？</strong></p>
<p>首先 payload 肯定是要发的；其次是 header 中的一些字段：SYN、FIN，seqno；</p>
<p>sender 的发送窗口大小就没必要发了，因为本来就是 receiver 来控制 sender 能够发多少数据，sender 控制不了 receiver！</p>
<p><strong>何时开启一个 timer ？</strong></p>
<ul>
<li>当带有负载或带有 SYN、FIN 标志的 segment 被发送时，就要开启 timer，<strong>因为这些 segment 都是占用了 absolut seqno 的 segment，要保证这些 segment 可靠送达对端！</strong></li>
<li>超时重传时要重启 timer</li>
</ul>
<p><strong>为什么超时的时候 RTO 要乘倍增长或保持不变？</strong></p>
<p>讲一下自己的理解：因为，如果是因为网络环境差导致的分组丢失，从而导致超时，那么我们应该尽量降低重传频率，不然网络环境会更加不堪重负，这时候就要乘倍增长 RTO 让重传频率降低；如果不是因为网络环境差，而是因为 receiver 处理数据太慢（即 ByteStream 中的数据迟迟没有读走），导致窗口大小变为 0，如果此时发送方傻傻的把发送窗口变成 0，而 receiver 又不继续发响应，那么当 receiver 的接收窗口大于 0 时，发送方无法得知，由于发送方窗口一直为 0 而导致通信被阻塞了（有没有这种可能？）。。。所以当 receiver 窗口为 0 时，而发送方仍有东西要发送时（即占用 absolute sequence number），让发送窗口为 1，这样发送方会不断向 receiver 发送一个字节，而此时 receiver 因为接收窗口为 0 而无法接收（直接不理会收到的 segment）导致发送方超时，由于这时候的超时不是网络环境导致的，所以让 RTO 保持原样是合理的！</p>
<h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p>经过大概 10 次左右的 <code>make check_lab3</code> 终于通过了所有测试用例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Test project &#x2F;home&#x2F;cs144&#x2F;sponge&#x2F;build</span><br><span class="line">      Start  1: t_wrapping_ints_cmp</span><br><span class="line"> 1&#x2F;33 Test  #1: t_wrapping_ints_cmp ..............   Passed    0.00 sec</span><br><span class="line">      Start  2: t_wrapping_ints_unwrap</span><br><span class="line"> 2&#x2F;33 Test  #2: t_wrapping_ints_unwrap ...........   Passed    0.00 sec</span><br><span class="line">      Start  3: t_wrapping_ints_wrap</span><br><span class="line"> 3&#x2F;33 Test  #3: t_wrapping_ints_wrap .............   Passed    0.00 sec</span><br><span class="line">      Start  4: t_wrapping_ints_roundtrip</span><br><span class="line"> 4&#x2F;33 Test  #4: t_wrapping_ints_roundtrip ........   Passed    0.12 sec</span><br><span class="line">      Start  5: t_recv_connect</span><br><span class="line"> 5&#x2F;33 Test  #5: t_recv_connect ...................   Passed    0.00 sec</span><br><span class="line">      Start  6: t_recv_transmit</span><br><span class="line"> 6&#x2F;33 Test  #6: t_recv_transmit ..................   Passed    0.03 sec</span><br><span class="line">      Start  7: t_recv_window</span><br><span class="line"> 7&#x2F;33 Test  #7: t_recv_window ....................   Passed    0.00 sec</span><br><span class="line">      Start  8: t_recv_reorder</span><br><span class="line"> 8&#x2F;33 Test  #8: t_recv_reorder ...................   Passed    0.00 sec</span><br><span class="line">      Start  9: t_recv_close</span><br><span class="line"> 9&#x2F;33 Test  #9: t_recv_close .....................   Passed    0.00 sec</span><br><span class="line">      Start 10: t_recv_special</span><br><span class="line">10&#x2F;33 Test #10: t_recv_special ...................   Passed    0.00 sec</span><br><span class="line">      Start 11: t_send_connect</span><br><span class="line">11&#x2F;33 Test #11: t_send_connect ...................   Passed    0.00 sec</span><br><span class="line">      Start 12: t_send_transmit</span><br><span class="line">12&#x2F;33 Test #12: t_send_transmit ..................   Passed    0.03 sec</span><br><span class="line">      Start 13: t_send_retx</span><br><span class="line">13&#x2F;33 Test #13: t_send_retx ......................   Passed    0.00 sec</span><br><span class="line">      Start 14: t_send_window</span><br><span class="line">14&#x2F;33 Test #14: t_send_window ....................   Passed    0.01 sec</span><br><span class="line">      Start 15: t_send_ack</span><br><span class="line">15&#x2F;33 Test #15: t_send_ack .......................   Passed    0.00 sec</span><br><span class="line">      Start 16: t_send_close</span><br><span class="line">16&#x2F;33 Test #16: t_send_close .....................   Passed    0.00 sec</span><br><span class="line">      Start 17: t_send_extra</span><br><span class="line">17&#x2F;33 Test #17: t_send_extra .....................   Passed    0.00 sec</span><br><span class="line">      Start 18: t_strm_reassem_single</span><br><span class="line">18&#x2F;33 Test #18: t_strm_reassem_single ............   Passed    0.00 sec</span><br><span class="line">      Start 19: t_strm_reassem_seq</span><br><span class="line">19&#x2F;33 Test #19: t_strm_reassem_seq ...............   Passed    0.00 sec</span><br><span class="line">      Start 20: t_strm_reassem_dup</span><br><span class="line">20&#x2F;33 Test #20: t_strm_reassem_dup ...............   Passed    0.00 sec</span><br><span class="line">      Start 21: t_strm_reassem_holes</span><br><span class="line">21&#x2F;33 Test #21: t_strm_reassem_holes .............   Passed    0.00 sec</span><br><span class="line">      Start 22: t_strm_reassem_many</span><br><span class="line">22&#x2F;33 Test #22: t_strm_reassem_many ..............   Passed    0.04 sec</span><br><span class="line">      Start 23: t_strm_reassem_overlapping</span><br><span class="line">23&#x2F;33 Test #23: t_strm_reassem_overlapping .......   Passed    0.00 sec</span><br><span class="line">      Start 24: t_strm_reassem_win</span><br><span class="line">24&#x2F;33 Test #24: t_strm_reassem_win ...............   Passed    0.03 sec</span><br><span class="line">      Start 25: t_strm_reassem_cap</span><br><span class="line">25&#x2F;33 Test #25: t_strm_reassem_cap ...............   Passed    0.05 sec</span><br><span class="line">      Start 26: t_byte_stream_construction</span><br><span class="line">26&#x2F;33 Test #26: t_byte_stream_construction .......   Passed    0.00 sec</span><br><span class="line">      Start 27: t_byte_stream_one_write</span><br><span class="line">27&#x2F;33 Test #27: t_byte_stream_one_write ..........   Passed    0.00 sec</span><br><span class="line">      Start 28: t_byte_stream_two_writes</span><br><span class="line">28&#x2F;33 Test #28: t_byte_stream_two_writes .........   Passed    0.00 sec</span><br><span class="line">      Start 29: t_byte_stream_capacity</span><br><span class="line">29&#x2F;33 Test #29: t_byte_stream_capacity ...........   Passed    0.28 sec</span><br><span class="line">      Start 30: t_byte_stream_many_writes</span><br><span class="line">30&#x2F;33 Test #30: t_byte_stream_many_writes ........   Passed    0.00 sec</span><br><span class="line">      Start 53: t_address_dt</span><br><span class="line">31&#x2F;33 Test #53: t_address_dt .....................   Passed    5.03 sec</span><br><span class="line">      Start 54: t_parser_dt</span><br><span class="line">32&#x2F;33 Test #54: t_parser_dt ......................   Passed    0.00 sec</span><br><span class="line">      Start 55: t_socket_dt</span><br><span class="line">33&#x2F;33 Test #55: t_socket_dt ......................   Passed    0.00 sec</span><br></pre></td></tr></table></figure>



<p>代码如下：</p>
<p>重传定时器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RTimer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RTimer() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">        _time_out = to;</span><br><span class="line">        _started = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; _started = <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">time_out</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _time_out; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_time_out</span><span class="params">(<span class="keyword">size_t</span> t)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _started &amp;&amp; t &gt;= _time_out; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">started</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _started; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> _started&#123;&#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span> _time_out&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>TCPSender 类中，自己添加的 private 变量 和 方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPSender</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">// my code:</span></span><br><span class="line">     RTimer _timer;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TCPSegment&gt; _outstandings;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">size_t</span> _ms_since_alive&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> _rtx&#123;&#125;; <span class="comment">// consective retransmission times</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">uint64_t</span> _checkpoint&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">uint16_t</span> _win_size&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> _rto; <span class="comment">// retransmission time out</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">bool</span> _peer_busy&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">uint64_t</span> _bytes_in_flight&#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">bool</span> _fin_sended&#123;&#125;;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     <span class="function">TCPSegment <span class="title">make_segment</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span></span>;</span><br><span class="line">     <span class="function">WrappingInt32 <span class="title">get_seqno</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">uint64_t</span> <span class="title">get_absolute_seqno</span><span class="params">(WrappingInt32, WrappingInt32, <span class="keyword">uint64_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">space_available</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _win_size &gt; <span class="number">0</span>; &#125;</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">is_peer_busy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _peer_busy; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">send_and_store</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>TCPSender 接口的具体实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">TCPSender::TCPSender(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity, <span class="keyword">const</span> <span class="keyword">uint16_t</span> retx_timeout, <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;WrappingInt32&gt; fixed_isn)</span><br><span class="line">     : _isn(fixed_isn.value_or(WrappingInt32&#123;random_device()()&#125;))</span><br><span class="line">     , _initial_retransmission_timeout&#123;retx_timeout&#125;</span><br><span class="line">     , _stream(capacity)</span><br><span class="line">     , _timer()</span><br><span class="line">     , _outstandings()</span><br><span class="line">     , _rto(retx_timeout)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">uint64_t</span> <span class="title">TCPSender::bytes_in_flight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> _bytes_in_flight;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!space_available()) <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">// size_t last_size = _outstandings.size();</span></span><br><span class="line">     <span class="keyword">if</span> (_next_seqno == <span class="number">0</span>) &#123; <span class="comment">// 前两次握手</span></span><br><span class="line">         <span class="keyword">size_t</span> can_read = <span class="built_in">std</span>::min(TCPConfig::MAX_PAYLOAD_SIZE,</span><br><span class="line">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>&amp;&gt;(_win_size - <span class="number">1</span>)); <span class="comment">// 预留一个字节给 syn</span></span><br><span class="line">         send_and_store(_stream.read(can_read), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_stream.input_ended() &amp;&amp; !_fin_sended) &#123; <span class="comment">// 后面四次挥手</span></span><br><span class="line">         <span class="comment">// 判断何时发送 fin</span></span><br><span class="line">         <span class="keyword">if</span> (_win_size &gt;= _stream.buffer_size() + <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="comment">// 刚好能把 fin 塞入</span></span><br><span class="line">             send_and_store(_stream.read(_win_size), <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">             _fin_sended = <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 仅传输 payload</span></span><br><span class="line">     <span class="keyword">while</span> (!_stream.buffer_empty() &amp;&amp; space_available()) &#123;</span><br><span class="line">         <span class="keyword">size_t</span> can_read = <span class="built_in">std</span>::min(TCPConfig::MAX_PAYLOAD_SIZE,</span><br><span class="line">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>&amp;&gt;(_win_size));</span><br><span class="line">         send_and_store(_stream.read(can_read), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 因为 ack_received 后会调用一次 fill_window 因此判断下是否已经 FIN_ACKED，如果 FIN_ACKED 了，那么 _outstandings 肯定为空</span></span><br><span class="line">     <span class="keyword">if</span> (!_timer.started() &amp;&amp; !_outstandings.empty())</span><br><span class="line">         _timer.start(_ms_since_alive + _rto);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"> <span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="keyword">const</span> WrappingInt32 ackno, <span class="keyword">const</span> <span class="keyword">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">uint64_t</span> left = get_absolute_seqno(ackno, _isn, _checkpoint);</span><br><span class="line">     <span class="keyword">if</span> (left &gt; _next_seqno) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">uint64_t</span> right = left + window_size;</span><br><span class="line">     _win_size = right - _next_seqno;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (window_size == <span class="number">0</span>) &#123; _peer_busy = <span class="literal">true</span>; _win_size = <span class="number">1</span>; &#125;</span><br><span class="line">     <span class="keyword">else</span> _peer_busy = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">bool</span> has_new_data = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">while</span> (!_outstandings.empty()) &#123;</span><br><span class="line">         TCPSegment segment = _outstandings.front();</span><br><span class="line">         <span class="keyword">uint64_t</span> ab_seqno = get_absolute_seqno(segment.header().seqno, _isn, _checkpoint);</span><br><span class="line">         <span class="keyword">uint16_t</span> length = segment.length_in_sequence_space();</span><br><span class="line">         <span class="keyword">if</span> (ab_seqno + length &gt; left)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         has_new_data = <span class="literal">true</span>;</span><br><span class="line">         _outstandings.pop();</span><br><span class="line">         _bytes_in_flight -= length;</span><br><span class="line"></span><br><span class="line">         _rto = _initial_retransmission_timeout;</span><br><span class="line">         _rtx = <span class="number">0</span>;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">if</span> (_outstandings.empty()) _timer.stop();</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(has_new_data) _timer.start(_ms_since_alive + _rto);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (_outstandings.empty()) <span class="keyword">return</span>;</span><br><span class="line">     _ms_since_alive += ms_since_last_tick;</span><br><span class="line">     <span class="keyword">if</span> (_timer.is_time_out(_ms_since_alive)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (is_peer_busy()) &#123;</span><br><span class="line">             <span class="comment">// 如果是对端繁忙的情况，即 发送端还有数据发，但 receiver 窗口变成 0</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 网络环境差导致丢包或延迟送达</span></span><br><span class="line">             _rtx++;</span><br><span class="line">             _rto *= <span class="number">2</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 重传最早的那个 segment，并重启定时器</span></span><br><span class="line">         <span class="comment">// assert(!_outstandings.empty()); // 一定非空</span></span><br><span class="line">         _segments_out.push(_outstandings.front());</span><br><span class="line">         <span class="comment">// _outstandings.pop();</span></span><br><span class="line">         _timer.start(_ms_since_alive + _rto);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _rtx; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     _segments_out.push(make_segment(<span class="string">&quot;&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">TCPSegment <span class="title">TCPSender::make_segment</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span> </span>&#123;</span><br><span class="line">     TCPSegment segment;</span><br><span class="line">     segment.payload() = <span class="built_in">std</span>::move(payload);</span><br><span class="line">     segment.header().seqno = get_seqno();</span><br><span class="line">     segment.header().syn = syn;</span><br><span class="line">     segment.header().fin = fin;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// _next_seqno += segment.length_in_sequence_space();</span></span><br><span class="line">     <span class="keyword">return</span> segment;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">WrappingInt32 <span class="title">TCPSender::get_seqno</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> wrap(_next_seqno, _isn);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">TCPSender::get_absolute_seqno</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="keyword">uint64_t</span> checkpoint)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> unwrap(n, isn, checkpoint);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">TCPSender::send_and_store</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; payload, <span class="keyword">bool</span> syn, <span class="keyword">bool</span> fin)</span> </span>&#123;</span><br><span class="line">     TCPSegment segment = make_segment(<span class="built_in">std</span>::move(payload), syn, fin);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// send</span></span><br><span class="line">     <span class="keyword">uint64_t</span> length = segment.length_in_sequence_space();</span><br><span class="line">     _segments_out.push(segment);</span><br><span class="line">     _next_seqno += length;</span><br><span class="line">     _win_size -= length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// store</span></span><br><span class="line">     _outstandings.push(segment);</span><br><span class="line">     _bytes_in_flight += length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// update checkpoint</span></span><br><span class="line">     _checkpoint = _next_seqno;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2022/03/27/cs144-lab1/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>