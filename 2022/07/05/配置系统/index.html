<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Config System · Codroc Blog</title><meta name="description" content="Config System - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Config System</h1><div class="post-info">2022年7月5日</div><div class="post-content"><h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><p><strong>配置系统有什么用？</strong></p>
<p>我的理解是方便程序的运行和发布。把配置变量都抽离出来放在配置文件中，如果要修改配置变量，就直接在配置文件里修改，然后重新运行程序就可以了。如果没有配置系统的情况下要修改配置变量，一般都是直接改程序源代码，然后重新编译连接，毫无疑问这将会是费时费力的（找对应版本的各种库，对应版本的编译器等等，还要等待漫长的编译连接过程。。。），对于那些非开源软件，想改源代码就更不可能了。。。。</p>
<p>配置系统就能够很好地解决这些问题。</p>
<h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><p>选择一种用于配置文件的语言，我选的是 YAML。它是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。</p>
<p>YAML 实质上是一种通用的数据串行化格式。它的基本语法规则如下：</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进时不允许使用 Tab 键，只允许使用空格。</li>
<li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li>
</ul>
<p><code>#</code>  表示注释，从这个字符一直到行尾，都会被解析器忽略。</p>
<p>YAML 支持的数据结构有三种：</p>
<ul>
<li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li>
<li>纯量（scalars）：单个的、不可再分的值</li>
</ul>
<p>和 JSON 对比，它数据类型更单调简单（JSON 有 6 种类型）</p>
<p>YAML 下载与安装：</p>
<p><code>yaml-cpp: github repo</code></p>
<p><code>mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make install</code></p>
<h3 id="基于-YAML-实现-配置系统"><a href="#基于-YAML-实现-配置系统" class="headerlink" title="基于 YAML 实现 配置系统"></a>基于 YAML 实现 配置系统</h3><p>配置系统的原则：</p>
<ul>
<li><strong>约定优于配置：</strong>约定即源代码中写死的值，而配置是指在配置文件 (.yaml) 中指定的值。</li>
<li><strong>不能无中生有：</strong>在源文件中未定义的配置变量，即使在配置文件 (.yaml) 中定义了也不会生效。</li>
</ul>
<p>总体的结构是这样的：</p>
<p>​    由于配置变量一般都由：变量名，变量值，变量描述构成。因此可以抽一个基类出来存放这些共通的属性，必然的，有时候会需要把配置变量输出到控制台给用户看，或根据字符串来重置变量值，因此还需要一个 fromString 和 toString 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVarBase</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ConfigVarBase&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span>; <span class="comment">// 根据 str 来设置 配置变量值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>;				  <span class="comment">// 把配置变量值转成字符串，便于输出</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _description;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    其中变量名和变量描述由于类型固定，可以放在基类中，而变量值则不固定了，它可以是任意类型，因此就可以根据基类派生出一个模板子类来表示具体的配置变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> :</span> <span class="keyword">public</span> ConfigVarBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    现在有配置变量了，缺一个管理这些配置变量的类，我使用 map 来进行管理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    static std::map&lt;std::string, ConfigVarBase::ptr&gt;&amp; GetConfigVars() &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, ConfigVarBase::ptr&gt; g_configVars;</span><br><span class="line">        <span class="keyword">return</span> g_configVars;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里为什么要用 static 函数来返回一个 local static 变量 map 呢？这是因为，配置系统可以被其他编译单元内的数据结构使用，如果其他编译单元想要使用 <strong>g_configVars</strong> 时，它还没有初始化完毕就会产生 runtime error，这种情况就是所谓的 non-local static 初始化顺序不一致。可以使用 local static 的方式来解决，也就是让别的编译单元通过调用函数的方式获取 <strong>g_configVars</strong>，这样使用它之前肯定被初始化好了。</p>
<p>这样一来 <strong>约定的变量</strong> 就实现了！</p>
<p>接下来就是怎么实现，从配置文件 (.yaml) 中读取配置变量。yaml-cpp 库提供了 LoadFile 函数，能从 .yaml 文件中读取 YAML::Node。</p>
<p>由于 .yaml 中的格式和我源代码中变量名字的格式是不一样的：</p>
<p>yaml 中是：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A:</span></span><br><span class="line">	<span class="attr">B:</span> <span class="number">10</span></span><br><span class="line">	<span class="attr">C:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>源文件中的变量名则为：A.B = 10，A.C = 20</p>
<p>因此这里需要一个从 YAML 名称格式到 源代码中的变量名称格式的转换。可以借助 yaml-cpp 中的 <code>IsNull, IsScalar, IsSequence, Ismap</code> 对 node 进行递归解析，然后将变量名进行转换。只有对象类型才需要递归解析下去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listAllNodes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> YAML::Node&amp; node,  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, YAML::Node&gt;&gt;&amp; allNodes)</span> </span>&#123;</span><br><span class="line">    allNodes.push_back(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(name, node));</span><br><span class="line">    <span class="keyword">if</span> (node.IsNull()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsScalar()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsSequence()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.IsMap()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = node.begin(); it != node.end(); ++it) &#123;</span><br><span class="line">            listAllNodes(name.empty() ? it-&gt;first.as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;() :</span><br><span class="line">                    name + <span class="string">&quot;.&quot;</span> + it-&gt;first.Scalar(), it-&gt;second, allNodes); <span class="comment">// 这里是名字转换的关键所在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config::loadFromYaml</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    YAML::Node node = YAML::LoadFile(filename);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, YAML::Node&gt;&gt; allNodes;</span><br><span class="line">    listAllNodes(<span class="string">&quot;&quot;</span>, node, allNodes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : allNodes) &#123; <span class="comment">// 对所有的 name、node 进行遍历</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name = i.first;</span><br><span class="line">        <span class="keyword">if</span> (name.empty())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ConfigVarBase::ptr p = Config::find(name);</span><br><span class="line">        <span class="keyword">if</span> (p) &#123; <span class="comment">// 这里保证了不会无中生有的原则</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">            ss &lt;&lt; i.second;</span><br><span class="line">            p-&gt;fromString(ss.str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道，YAML 文件中仅仅是一些文本，而我们需要根据 YAML 文本得到内存中的对象；或者根据内存中的对象得到 YAML 文本；这本质就是序列化和反序列化。和 JSON 的十分相似。<br>我做出了这样的总结：</p>
<ul>
<li>YAML::Node –&gt; std::string –&gt; Type<ul>
<li>通过 std::stringstream 来实现 YAML::Node –&gt; std::string. 这一部分 YAML 库已经做好了</li>
<li>通过 自己实现的 <code>LexicalCast\&lt;F, T\&gt;</code> 来做 std::string –&gt; Type 的转换</li>
</ul>
</li>
<li>Type –&gt; std::string –&gt; YAML::Node<ul>
<li>通过 YAML::Load 来实现 std::string –&gt; YAML::Node. 这一部分 YAML 库已经做好了</li>
<li>通过 自己实现的 <code>LexicalCast\&lt;F, T\&gt;</code> 来做 Type –&gt; std::string 的转换</li>
</ul>
</li>
</ul>
<h3 id="fromStr-和-toStr-的实现"><a href="#fromStr-和-toStr-的实现" class="headerlink" title="fromStr 和 toStr 的实现"></a>fromStr 和 toStr 的实现</h3><p>对于普通的内置类型可以用 boost::lexical_cast 来实现，而对于复杂的数据类型，例如：vector,list,set,map,unordered_set,unordered_map, 自定义类型 等，就要自己去实现了。</p>
<p><strong>STL 类型的支持：</strong></p>
<p>可以实现一个 LexicalCast 模板类，然后根据具体的 STL 容器对 LexicalCast 进行偏特化就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于普通内置类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> F&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boost::lexical_cast&lt;T&gt;(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cast from std::string to std::vector&lt;T&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        ...<span class="comment">// 利用 yaml-cpp 的 Load 得到 node 然后遍历 node，利用 stringstream 格式化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// cast from std::vector&lt;T&gt; to std::string</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">FromStr</span> =</span> LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, T&gt;, </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ToStr</span> =</span> LexicalCast&lt;T, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> :</span> <span class="keyword">public</span> ConfigVarBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">fromString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _val = FromStr()(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ToStr()(_val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>自定义类型的支持：</strong></p>
<p>自定义类型，需要实现 LexicalCast 偏特化，实现后，就可以支持 Config 解析自定义类型，自定义类型可以和常规 STL 容器一起使用。</p>
<p>例如，增加 Person 类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">bool</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from std::string to Person</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, Person&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Person <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        YAML::Node node = YAML::Load(str);</span><br><span class="line">        Person p;</span><br><span class="line">        p.name = node[<span class="string">&quot;name&quot;</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        p.age = node[<span class="string">&quot;age&quot;</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        p.sex = node[<span class="string">&quot;sex&quot;</span>].as&lt;<span class="keyword">bool</span>&gt;();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from Person to std::string</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span>Person, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span> </span>&#123;</span><br><span class="line">        YAML::Node node;</span><br><span class="line">        node[<span class="string">&quot;name&quot;</span>] = p.name;</span><br><span class="line">        node[<span class="string">&quot;age&quot;</span>] = p.age;</span><br><span class="line">        node[<span class="string">&quot;sex&quot;</span>] = p.sex;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="配置的事件机制"><a href="#配置的事件机制" class="headerlink" title="配置的事件机制"></a>配置的事件机制</h3><p>当一个配置项发生修改的时候，可以反向通知对应的代码。</p>
<p>这个其实挺容易实现的，在 ConfigVar 模板类中添加一个 OnChangeCallBack _cb 回调，它是 </p>
<p>std::function&lt;const T&amp; oldVal, const T&amp; newVal&gt; 类型的，每当要改变 ConfigVar::_val 时，先判断一下，新的值是否与旧值不同，如果是的化则回调 _cb</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ConfigVar</span> &#123;</span></span><br><span class="line">... </span><br><span class="line"><span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == _val)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (_cb)</span><br><span class="line">            _cb(_val, v);</span><br><span class="line">        _val = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnChangeCallBack</span><span class="params">(OnChangeCallBack cb)</span> </span>&#123; _cb = cb; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delOnChangeCallBack</span><span class="params">()</span> </span>&#123; _cb = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line">    OnChangeCallBack _cb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>这样配置系统基本就完成了！</p>
</div></article></div></main><footer><div class="paginator"><a href="/2022/06/14/rw_file_by_json/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>