<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Leetcode 刷题笔记 · Codroc Blog</title><meta name="description" content="Leetcode 刷题笔记 - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Leetcode 刷题笔记</h1><div class="post-info">2022年3月21日</div><div class="post-content"><h1 id="Leetcode-刷题笔记"><a href="#Leetcode-刷题笔记" class="headerlink" title="Leetcode 刷题笔记"></a>Leetcode 刷题笔记</h1><p><strong>要开始刷题了，记录下那些思想比较绕的，一时半会想不起来怎么做的题目</strong>。</p>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q || !root) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* l = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* r = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="comment">// 情况 1，p、q在左右两边</span></span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; r) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">// 两边都没有 p、q，那么直接返回</span></span><br><span class="line">        <span class="comment">// 情况 2 和 3</span></span><br><span class="line">        <span class="keyword">return</span> l ? l : r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>问题描述：给定一颗树的根节点 <code>root</code>，找出节点 <code>p</code> 和 <code>q</code> 的最近的公共祖先节点。</em></p>
<p>这个分三种情况：</p>
<ol>
<li>祖先节点正好在中间，而 p、q 节点在左右两边</li>
<li>p、q 都在一边，且祖先节点为 p</li>
<li>p、q 都在一边，且祖先节点为 q</li>
</ol>
<p>递归地查找 p、q 位置，即到底是在左右两边，还是在同一边。</p>
<p>对于第一种情况，我们只要返回 root 节点就行了；对于第二种情况，返回 p；第三种情况，返回 q</p>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></strong></p>
<p>这一题和 <strong>至多有K个重复字符的最长字串、无重复字符的最长字串</strong> 有类似的概念，可以一起训练。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fz</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">26</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i)</span><br><span class="line">            a[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pairs;</span><br><span class="line">        <span class="keyword">int</span> nl = l;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">bool</span> need_partation = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = l; i &lt; r &amp;&amp; nl &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt; k) &#123;</span><br><span class="line">                need_partation = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - nl &gt;= k)    pairs.push_back(&#123;nl, i&#125;);</span><br><span class="line">                <span class="keyword">while</span> (i &lt; r &amp;&amp; a[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt; k) ++i;</span><br><span class="line">                nl = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!need_partation) <span class="keyword">return</span> r - l &gt;= k ? r - l : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i - nl &gt;= k)    pairs.push_back(&#123;nl, i&#125;);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : pairs)</span><br><span class="line">            ret = max(ret, fz(s, p[<span class="number">0</span>], p[<span class="number">1</span>], k));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fz(s, <span class="number">0</span>, s.size(), k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题的思想很重要，采用分治的思想：<strong>如果字符出现的次数少于 K 那么该字符比不可能出现在最长字串中，因此可以用该字符对字符串进行划分，划分成一个个的区间，然后对区间内的字符串再次采用分治思想。</strong></p>
<p>举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分治：对于一个字符串来说，如果要求子串最少出现k次，那么如果某些字母出现的次数小于k,</span></span><br><span class="line"><span class="comment">//这些字母一定不会出现在最长的子串中，并且这些字母将整个字符子串分割成小段，这些小段有可能是最长的</span></span><br><span class="line"><span class="comment">//但是由于被分割了，还是要检查这一小段，如果某些字母出现的次数小于k,会将小段继续分割下去,</span></span><br><span class="line"><span class="comment">//比如字符串&quot;aacbbbdc&quot;，要求最少出现2次,我们记录左右闭区间，，</span></span><br><span class="line"><span class="comment">//第一轮[0,7]，处理&quot;aacbbbdc&quot;，d只出现了一次不满足，于是递归解决区间[0,5]、[7,7]</span></span><br><span class="line"><span class="comment">//第二轮[0,5]，处理&quot;aacbbb&quot;，  c只出现了一次不满足，于是递归解决区间[0,1]、[3,4] </span></span><br><span class="line"><span class="comment">//第二轮[7,7]，处理&quot;c&quot;，       c只出现了一次不满足，不继续递归</span></span><br><span class="line"><span class="comment">//第三轮[0,1]，处理&quot;aa&quot;，      满足出现次数&gt;=2,ret=2</span></span><br><span class="line"><span class="comment">//第三轮[3,4]，处理&quot;bbb&quot;，     满足出现次数&gt;=2 ret=3;</span></span><br></pre></td></tr></table></figure>



<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></strong></p>
<p>这题刚开始碰到是不会做的，感觉思想还是挺有意思的，记录下！</p>
<p>看下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>看下数据的范围：</p>
<ul>
<li>n == nums1.length</li>
<li>n == nums2.length</li>
<li>n == nums3.length</li>
<li>n == nums4.length</li>
<li>1 &lt;= n &lt;= 200</li>
<li>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</li>
</ul>
<p>n = 200，所以暴力肯定超时，最好想个 O(n*n) 的方法~</p>
<p>如果是两数相加要怎么做？两数相加很简单的：</p>
<p><code>target = a + b</code>，只要在 map 中记录 a，然后查到 b 的时候，查以下 map 里面有没有 a 就行了。</p>
<p>其实四数相加完全可以转化成两数相加：</p>
<p><code>target = (a + b) + (c + d)</code> ，那么我们先计算前两个数组之和，如示例1，<code>a + b</code>两两组合就会产生 4 个值 L1= [-1, 0, 0, 1]; <code>c + d</code> 两两组合就会产生 4 个值 L2 = [-1, 1, 2, 4];</p>
<p>接下来其实就是两数相加的内容了，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for x1 in L1, x2 in L2:</span><br><span class="line">	if x1 + x2 &#x3D;&#x3D; target</span><br><span class="line">		ret++</span><br></pre></td></tr></table></figure>

<p>这里还可以通过 map 进行优化，最终得到的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp1, mp2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 : nums2)</span><br><span class="line">                mp1[i1+i2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 : nums4)</span><br><span class="line">                mp2[i1+i2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = mp1.begin(); it1 != mp1.end(); ++it1) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - it1-&gt;first;</span><br><span class="line">            <span class="keyword">int</span> times = it1-&gt;second;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> it2 = mp2.find(target); it2 != mp2.end()) &#123;</span><br><span class="line">                ret += it2-&gt;second * times;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">1109. 航班预定系统</a></strong></p>
<p>这道题就是考察一个知识点，那就是：**<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分数组</a>**</p>
<p>其实一开始，我只是绝对对同一个区间进行相同的操作，没必要再遍历，但是就是找不出用什么别的方法，原来可以用差分。。。。。</p>
<p>差分数组的应用场景：对区间内 [l, r] 内的元素做同一类型的操作，那么就可以用差分数组。</p>
<p>由于差分数组是通过后一个减前一个的方式得到的即 d[i] = a[i] - a[i - 1]，i &gt; 0。因此如果在区间 [l, r] 中进行 +val 操作，就会导致：</p>
<ul>
<li>a[l] - a[l - 1] = d[l] + val</li>
<li>a[r + 1] - a[r] = d[r + 1] - val</li>
</ul>
<p>因此只要改变差分数组中的两个元素就可以了，一个是 d[l]，一个是 d[r + 1]</p>
<p>接下来看下题目：</p>
<p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p>
<p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</p>
<p>请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer &#x3D; [10,55,45,25,25]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : bookings) &#123;</span><br><span class="line">            <span class="keyword">int</span> first = e[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> last = e[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> seats = e[<span class="number">2</span>];</span><br><span class="line">            d[first] += seats;</span><br><span class="line">            <span class="keyword">if</span> (last &gt;= n + <span class="number">1</span>)   <span class="keyword">continue</span>;</span><br><span class="line">            d[last] -= seats;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n + <span class="number">1</span>;++i)</span><br><span class="line">            d[i] = d[i] + d[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> &#123;d.data() + <span class="number">1</span>, d.data()+d.size()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></strong></p>
<p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,0,0,0,1,1,1,1,0], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释：[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K &#x3D; 3</span><br><span class="line">输出：10</span><br><span class="line">解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 10。</span><br></pre></td></tr></table></figure>

<p>这题用前缀和，v[i] 表示前面有几个 0。</p>
<p>但是这里的索引以及边界问题的使用很让人不解。。。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            v[i] = v[i - <span class="number">1</span>] + <span class="number">1</span> - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 这里为什么要从 0 开始遍历</span></span><br><span class="line">            <span class="keyword">int</span> left = lower_bound(v.begin(), v.end(), v[i + <span class="number">1</span>] - k) - v.begin();</span><br><span class="line">            ret = max(ret, i - left + <span class="number">1</span>); <span class="comment">// 为什么是 i - left + 1 而不是 i - left</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></article></div></main><footer><div class="paginator"><a href="/2022/03/26/dynamic_link/" class="prev">上一篇</a><a href="/2022/03/10/fork_and_exit_error/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>