<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 多线程下 fork 与 exit 引发的连锁错误 · Codroc Blog</title><meta name="description" content="多线程下 fork 与 exit 引发的连锁错误 - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">多线程下 fork 与 exit 引发的连锁错误</h1><div class="post-info">2022年3月10日</div><div class="post-content"><h1 id="多线程下-fork-与-exit-引发的连锁错误"><a href="#多线程下-fork-与-exit-引发的连锁错误" class="headerlink" title="多线程下 fork 与 exit 引发的连锁错误"></a>多线程下 fork 与 exit 引发的连锁错误</h1><p><strong>这篇文章存在问题！！！</strong></p>
<p>问题出现在这样的情景下：</p>
<p>编译完 <code>loggerTest.cpp</code> 后，执行后，程序被阻塞不能退出,在通过 <code>ps aux|grep ./loggerTest</code> 一看，好家伙，原来是 <code>asyncLogging.cpp</code> 中的rollFile 函数 fork 出来的进程都还没释放掉，而且都处在 S 状态，也就是被阻塞了！</p>
<p><img src="https://s1.ax1x.com/2022/03/10/b4sqMV.png"></p>
<p>本来 fork 出这个进程是为了 roll file 的，也就是把 log 文件进行压缩打包用的。代码片段如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line">	<span class="comment">// 执行脚本，对原来的 日志包 解包，对每个日志文件重命名（0=&gt;1，1=&gt;2 ...），然后将 1~N                                                   的日志文件重新压缩打包，父进程等待子进程退出，这阶段父进程不能持有任何锁</span></span><br><span class="line">    <span class="keyword">char</span> *args[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> newfile[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(newfile, <span class="number">0</span>, <span class="keyword">sizeof</span>(newfile));</span><br><span class="line">    <span class="built_in">memcpy</span>(newfile, ret.c_str(), ret.size());</span><br><span class="line">    args[<span class="number">0</span>] = <span class="string">&quot;jiaoben&quot;</span>;</span><br><span class="line">    args[<span class="number">1</span>] = newfile;</span><br><span class="line">    args[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        execv(<span class="string">&quot;jiaoben&quot;</span>, args);</span><br><span class="line">    wait(<span class="number">0</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到本来的预期是 fork 出一个子进程后，立马 execv 让可执行文件 <code>jiaoben</code> 来覆盖原来的内容（包括页表，各种锁、条件变量的状态，当然还有内核数据结构）。<code>jiaoben</code> 这个可执行文件就是用来执行 python 脚本的，照理说执行完会立马退出的呀！</p>
<p>好在这个进程没退出，我们可以用 gdb 来追踪它的状态：</p>
<p><img src="https://s1.ax1x.com/2022/03/10/b4sLrT.png" alt="gdb 追踪状态"></p>
<p>这是妥妥的连 execv 都没执行成功呀（因为 如果没有子进程 wait(0) 会直接返回 -1，所以子进程相当于继续执行下去了）！然后一看目录下，我晕，<code>jiaoben.cpp</code> 忘记编译了，所以 execv 执行失败，后端日志线程就回到 while 循环了，一直执行 <code>_cond.waitForSecs(3);</code> 这也就导致该进程在 ps 命令中看上去一直被阻塞了！</p>
<p>这也是血的教训呀！每次调用函数后一定要判断是否调用成功！不然有的苦头吃啊~~接下来，自然地将代码改成如下片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line">	<span class="comment">// 执行脚本，对原来的 日志包 解包，对每个日志文件重命名（0=&gt;1，1=&gt;2 ...），然后将 1~N                                                   的日志文件重新压缩打包，父进程等待子进程退出，这阶段父进程不能持有任何锁</span></span><br><span class="line">    <span class="keyword">char</span> *args[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> newfile[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">memset</span>(newfile, <span class="number">0</span>, <span class="keyword">sizeof</span>(newfile));</span><br><span class="line">    <span class="built_in">memcpy</span>(newfile, ret.c_str(), ret.size());</span><br><span class="line">    args[<span class="number">0</span>] = <span class="string">&quot;jiaoben&quot;</span>;</span><br><span class="line">    args[<span class="number">1</span>] = newfile;</span><br><span class="line">    args[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == execv(<span class="string">&quot;jiaoben&quot;</span>, args))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    wait(<span class="number">0</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很自然呀！如果 execv 执行失败，让它退出就行了！但是好像并没那么容易，再次执行 <code>loggerTest</code>，发现连该进程都被阻塞了。当即用 <code>ps aux|grep ./loggerTest</code> 查看后，发现有两个名为<code>loggerTest</code> 的进程处在运行状态，退不出去！那没事，只要你还活着，我就能用 gdb attach 到你~~继续使用 gdb 去查看哪里出错了：</p>
<p>这一个 gdb 追踪的是原始的 <code>./loggerTest</code> 进程，因为它有 2 个线程，而 fork 只能 fork 出一个线程。</p>
<p><img src="https://s1.ax1x.com/2022/03/10/b46RAg.png" alt="原始 ./threadTest 进程"></p>
<p>可以看到测试进程<code>./loggerTest</code> 的主线程一直在 <code>AsyncLogging::stop</code> 上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 _currentBuffer 中有数据是不能让 _running 变成 False 的，不然就丢失数据了</span></span><br><span class="line">    <span class="comment">// 必须是 前端退出后，才能调用后端的 stop</span></span><br><span class="line">    assert(_running);</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexGuard <span class="title">guard</span><span class="params">(_lock)</span></span>;</span><br><span class="line">        size = _currentBuffer-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _cond.wakeup();</span><br><span class="line">        <span class="function">MutexGuard <span class="title">guard</span><span class="params">(_lock)</span></span>;</span><br><span class="line">        size = _currentBuffer-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    _running = <span class="literal">false</span>;</span><br><span class="line">    _cond.wakeup();</span><br><span class="line">    _thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个函数一直停留在 <code>stop</code> 中的唯一理由就是一直在 while 循环内出不去，也就是 wakeup 没作用，日志后端线程根本不鸟这个 wakeup。</p>
<p>再来看看打包日志的进程，它又是为什么迟迟不肯退出呢？</p>
<p><img src="https://s1.ax1x.com/2022/03/10/b46Icq.png" alt="打包日志的进程"></p>
<p>可以看到它也一直停留在 <code>AsyncLogging::stop</code> 上。<strong>并且这个进程只有一个线程，那么这个 wakeup 就很搞笑了呀，因为根本没有接收者，或者说接收这个 wakeup 的人就是你自己，而你此时在 while 循环里永远也接收不到</strong>。再回到 roll file 的代码片段，它是一直阻塞等待着子进程退出才会继续执行下去的，然而此时子进程（打包日志的进程）永远也退不出，这就导致了 <code>./loggerTest</code> 进程的后端日志线程永远被阻塞（可以通过 gdb 查看 thread 2 阻塞的位置就知道了 __GI__wait4），</p>
<p><img src="https://s1.ax1x.com/2022/03/10/b46LEF.png" alt="./loggerTest 进程的 thread 2"></p>
<p>进而导致前端日志线程退出时执行 <code>AsyncLogging::stop</code> 的 wakeup 却得不到后端日志线程的响应（因为它一直 wait(0) 等着子进程退出），这一系列连锁反应就导致了现在的尴尬局面~~</p>
<p>该怎么解决？那就是让 execv 一定要执行成功，在执行前判断脚本文件是否存在，如果不存在则不要在多线的情况下去 fork 了，很容易造成复杂的错误！</p>
<h1 id="带来的启发"><a href="#带来的启发" class="headerlink" title="带来的启发"></a>带来的启发</h1><ul>
<li>在多线程环境下，调用 fork 后一定要立马确定 execv 成功，不然的话很容易出现复杂难以诊断的错误。因为 fork 在 linux 环境下只会 fork 出一个线程，这样本质上就和 锁，条件变量 等待同步工具在概念上矛盾了（同步工具用于多线程环境，而 fork 出来的是单线程进程）。</li>
<li>不要以为调用了 exit 后 os 一定就会帮你释放掉资源，因为在 C++ 中，还存在全局对象析构这么一个环节，很有可能在这个环节 整个进程就阻塞住了，进而导致资源得不到释放，慢慢的把你的内存吃光！！！</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2022/03/07/cache_coherence/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>