<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> leveldb 源码分析 [4] —— SSTable · Codroc Blog</title><meta name="description" content="leveldb 源码分析 [4] —— SSTable - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">leveldb 源码分析 [4] —— SSTable</h1><div class="post-info">2022年8月5日</div><div class="post-content"><h1 id="LevelDB-源码分析【4】——-SSTable"><a href="#LevelDB-源码分析【4】——-SSTable" class="headerlink" title="LevelDB 源码分析【4】—— SSTable"></a>LevelDB 源码分析【4】—— SSTable</h1><p>SSTable 是一种文件的存储格式，MemTable 中的数据，最终都会被序列化然后压缩持久化存储到稳定介质中去（磁盘）；</p>
<h3 id="SSTable-物理结构"><a href="#SSTable-物理结构" class="headerlink" title="SSTable 物理结构"></a>SSTable 物理结构</h3><p>SSTable 文件被划分成固定大小的块（一般每块为 4KB），<strong>这里我就有问题了：为什么一个文件要被划分出固定的块呢？</strong></p>
<p><strong>每一个块由三部分组成：</strong></p>
<ul>
<li>Data：经过 序列化 + 压缩 后的数据</li>
<li>Compression Type：压缩算法类型，leveldb 默认使用 Snappy 算法进行压缩</li>
<li>CRC：冗余校验校验码，校验范围包括 Data 和 Compression Type</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/26/eGcVozFlOIZ96XH.png" alt="图1"></p>
<h3 id="SSTable-逻辑结构"><a href="#SSTable-逻辑结构" class="headerlink" title="SSTable 逻辑结构"></a>SSTable 逻辑结构</h3><p>在逻辑上，根据功能不同，leveldb在逻辑上又将sstable分为：</p>
<ol>
<li><strong>data block</strong>: 用来存储key value数据对；</li>
<li><strong>filter block</strong>: 用来存储一些过滤器相关的数据（布隆过滤器），但是若用户不指定leveldb使用过滤器，leveldb在该block中不会存储任何内容；</li>
<li><strong>meta Index block</strong>: 用来存储filter block的索引信息（索引信息指在该sstable文件中的偏移量以及数据长度）；</li>
<li><strong>index block</strong>：index block中用来存储每个data block的索引信息；</li>
<li><strong>footer</strong>: 用来存储meta index block及index block的索引信息；</li>
</ol>
<p><img src="https://s2.loli.net/2022/07/26/v6nlSXJqfu13ERM.png" alt="sstable1.PNG"></p>
<blockquote>
<p>注意，1-4类型的区块，其物理结构都是如1.1节所示，每个区块都会有自己的压缩信息以及CRC校验码信息。</p>
</blockquote>
<p>想要了解各类 block 的具体建造方式，可以查看  <code>table/block_builder.h</code> 和 <code>table/block_builder.cc</code></p>
<h3 id="data-block"><a href="#data-block" class="headerlink" title="data block"></a>data block</h3><p>data block 中存储的数据是 leveldb 中的 key value 键值对。其中一个 data block 中的数据部分（不包括压缩类型、CRC校验码）按逻辑又以下图进行划分：</p>
<p><img src="https://s2.loli.net/2022/07/26/MgVXsplz3mt6Of7.png" alt="sstable2.PNG"></p>
<p>第一部分用来存储 key value 数据。由于 sstable 中所有的 key value 对都是严格按序存储的，为了节省存储空间，leveldb 并不会为每一对 key value 对都存储完整的 key 值，而是存储与<strong>上一个 key 非共享的部分</strong>，避免了 key 重复内容的存储。</p>
<p>每间隔若干个 key value 对，将为该条记录重新存储一个完整的 key。重复该过程（默认间隔值为16），每个重新存储完整 key 的点称之为 Restart point；</p>
<blockquote>
<p>leveldb设计Restart point的目的是在读取sstable内容时，加速查找的过程。</p>
<p>由于每个Restart point存储的都是完整的key值，因此在sstable中进行数据查找时，可以首先利用restart point点的数据进行键值比较，以便于快速定位目标数据所在的区域；</p>
<p>当确定目标数据所在区域时，再依次对区间内所有数据项逐项比较key值，进行细粒度地查找；</p>
<p>该思想有点类似于跳表中利用高层数据迅速定位，底层数据详细查找的理念，降低查找的复杂度。</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/07/26/VBtcb2R9SJY6Gd3.png" alt="sstable3.PNG"></p>
<p>一个 entry 分为5部分内容：</p>
<ol>
<li>与前一条记录 key 共享部分的长度；</li>
<li>与前一条记录 key 不共享部分的长度；</li>
<li>value 长度；</li>
<li>与前一条记录 key 非共享的内容；</li>
<li>value 内容；</li>
</ol>
<p>那么当接收到一个 {key, value} pair 的时候，怎么把它编码成一个 Entry 呢？</p>
<p>代码展示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="function">Slice <span class="title">last_key_piece</span><span class="params">(last_key_)</span></span>;</span><br><span class="line">  assert(!finished_);</span><br><span class="line">  assert(counter_ &lt;= options_-&gt;block_restart_interval);</span><br><span class="line">  assert(buffer_.empty()  <span class="comment">// No values yet?</span></span><br><span class="line">         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">size_t</span> shared = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;</span><br><span class="line">    <span class="comment">// See how much sharing to do with previous string</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> min_length = <span class="built_in">std</span>::min(last_key_piece.size(), key.size());</span><br><span class="line">    <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;</span><br><span class="line">      shared++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Restart compression</span></span><br><span class="line">    restarts_.push_back(buffer_.size());</span><br><span class="line">    counter_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> non_shared = key.size() - shared;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOC: 制作 Entry</span></span><br><span class="line">  <span class="comment">// Add &quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; to buffer_</span></span><br><span class="line">  PutVarint32(&amp;buffer_, shared);</span><br><span class="line">  PutVarint32(&amp;buffer_, non_shared);</span><br><span class="line">  PutVarint32(&amp;buffer_, value.size());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add string delta to buffer_ followed by value</span></span><br><span class="line">  buffer_.append(key.data() + shared, non_shared);</span><br><span class="line">  buffer_.append(value.data(), value.size());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update state</span></span><br><span class="line">  last_key_.resize(shared);</span><br><span class="line">  last_key_.append(key.data() + shared, non_shared);</span><br><span class="line">  assert(Slice(last_key_) == key);</span><br><span class="line">  counter_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把 BlockBuilder 看作是一个 Block 的建造者，它的职责就是建造一个 Block；</p>
<p>现在来看看它是怎么建造 data block 的：</p>
<ul>
<li>首先它会判断是否需要开启一个新的 restart point；如果是，那么它是一个完整的 key，因此 <code>shared key length = 0</code>；如果不是则需要确定共享 key 的长度；</li>
<li>根据共享 key 的长度制作 Entry</li>
<li>把 Entry 序列化到 buffer 中</li>
</ul>
<p>当一个 data block 达到一定阈值的时候，就可以 restart points 以及 restart points length 也序列化到结尾，如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">BlockBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Append restart array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; restarts_.size(); i++) &#123;</span><br><span class="line">    PutFixed32(&amp;buffer_, restarts_[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  PutFixed32(&amp;buffer_, restarts_.size());</span><br><span class="line">  finished_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> Slice(buffer_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么什么时候调用 <strong>BlockBuilder::Finish</strong> 呢？从 <strong>TableBuilder::Add</strong> 中可见端倪：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">... ...</span><br><span class="line">  <span class="comment">// DOC: 当 data_block 的大小超过设定值时，对它 Flush</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 data_block 当前占用空间大小 &gt;= 系统设定的阈值时，就进行 <strong>Flush</strong>，那么 <strong>Flush</strong> 会调用 <strong>WriteBlock</strong>，看一下它的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::WriteBlock</span><span class="params">(BlockBuilder* block, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// File format contains a sequence of blocks where each block has:</span></span><br><span class="line">  <span class="comment">//    block_data: uint8[n]</span></span><br><span class="line">  <span class="comment">//    type: uint8</span></span><br><span class="line">  <span class="comment">//    crc: uint32</span></span><br><span class="line">  assert(ok());</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Slice raw = block-&gt;Finish(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  Slice block_contents;</span><br><span class="line">  CompressionType type = r-&gt;options.compression;</span><br><span class="line">  <span class="comment">// TODO(postrelease): Support more compression options: zlib?</span></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">case</span> kNoCompression:</span><br><span class="line">      block_contents = raw;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> kSnappyCompression: &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>* compressed = &amp;r-&gt;compressed_output;</span><br><span class="line">      <span class="keyword">if</span> (port::Snappy_Compress(raw.data(), raw.size(), compressed) &amp;&amp;</span><br><span class="line">          compressed-&gt;size() &lt; raw.size() - (raw.size() / <span class="number">8u</span>)) &#123;</span><br><span class="line">        block_contents = *compressed;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Snappy not supported, or compressed less than 12.5%, so just</span></span><br><span class="line">        <span class="comment">// store uncompressed form</span></span><br><span class="line">        block_contents = raw;</span><br><span class="line">        type = kNoCompression;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  WriteRawBlock(block_contents, type, handle); <span class="comment">// 3</span></span><br><span class="line">  r-&gt;compressed_output.clear();</span><br><span class="line">  block-&gt;Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>它直接调用了 <strong>BlockBuilder::Finish</strong>，得到了序列化后的 data block；</li>
<li>然后对 data block 进行压缩（大名鼎鼎的 Leveldb 竟然也是用 switch case  的方式来判断压缩算法，然后去执行压缩的。。。<strong>显然违反开闭原则</strong>）；</li>
<li>最后调用 <strong>WriteRawBlock</strong></li>
</ol>
<p><strong>WriteRawBlock：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 CompressionType type, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  handle-&gt;set_offset(r-&gt;offset);</span><br><span class="line">  handle-&gt;set_size(block_contents.size());</span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;Append(block_contents);</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">    <span class="keyword">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;</span><br><span class="line">    <span class="keyword">uint32_t</span> crc = crc32c::Value(block_contents.data(), block_contents.size());</span><br><span class="line">    crc = crc32c::Extend(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc to cover block type</span></span><br><span class="line">    EncodeFixed32(trailer + <span class="number">1</span>, crc32c::Mask(crc));</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(Slice(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;offset += block_contents.size() + kBlockTrailerSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它就是在 data block 后面追加了一个 compression type 和 CRC 校验码，就如图1所示；</p>
<h3 id="Index-Block"><a href="#Index-Block" class="headerlink" title="Index Block"></a>Index Block</h3><p>index block 用来存储所有 data block 的相关索引信息</p>
<p>index block 包含若干条 Entry，每一条 Entry 代表一个 data block 的索引信息。</p>
<p><strong>一条索引包括以下内容：</strong></p>
<ol>
<li><strong>data block i 中最大的 key 值；</strong></li>
<li><strong>该 data block 起始地址在 sstable 中的偏移量；</strong></li>
<li><strong>该 data block 的大小；</strong></li>
</ol>
<p>这三部分内容最终会被制作成一条 Entry，并追加到 Index Block 中去；</p>
<p><img src="https://s2.loli.net/2022/07/27/BZslgiH2481RNuh.png" alt="sstable4.PNG"></p>
<blockquote>
<p>其中，data block i最大的key值还是index block中该条记录的key值。</p>
<p>如此设计的目的是，依次比较index block中记录信息的key值即可实现快速定位目标数据在哪个data block中。</p>
</blockquote>
<p>在源码中，涉及到 Index Block 的数据变量有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BlockBuilder index_block; <span class="comment">// DOC: 就是 sstable 逻辑结构中的 Index Block</span></span><br><span class="line"><span class="keyword">bool</span> pending_index_entry; <span class="comment">// DOC: 如果是 true，表示一个 data block 刚刚 flush 到 sstable，紧接着就要制作一个 index entry 用于索引该 data block</span></span><br><span class="line">BlockHandle pending_handle; <span class="comment">// DOC: 用于制作 Index Block</span></span><br></pre></td></tr></table></figure>

<p>具体什么时候往 Index Block 追加索引 entry 呢？Leveldb 为了在 entry 中使用更短的 key，它将 index block entry 的制作时机推迟到下一个块 block data i + 1 插入第一个 key 的时候，这样它就能找到一个更短的 key 使得 key &gt;= block data i 中最大的 key，并且 key &lt; block data i + 1 中最小的 key；</p>
<blockquote>
<p>注释：   </p>
<p>   // We do not emit the index entry for a block until we have seen the<br>   // first key for the next data block.  This allows us to use shorter<br>   // keys in the index block.  For example, consider a block boundary<br>   // between the keys “the quick brown fox” and “the who”.  We can use<br>   // “the r” as the key for the index block entry since it is &gt;= all<br>   // entries in the first block and &lt; all entries in subsequent<br>   // blocks.</p>
</blockquote>
<p>因此在 <strong>TableBuilder::Add</strong> 中进行 index block entry 的制作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">  <span class="comment">// DOC: 如果是 data_block 中的第一个 key，制作 index block entry</span></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">    assert(r-&gt;data_block.empty());</span><br><span class="line">    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key); <span class="comment">// 找到一个更短的 key；其中 last_key 是 data block i 中最大的 key，而 key 则是 data block i + 1 中第一个 key，即最小的 key；从这两个 key 中找到一个中间的最小的 key 就可以满足要求了；</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding); </span><br><span class="line">    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <strong>pending_handle</strong> 会在 <strong>TableBuilder::WriteRawBlock</strong> 函数调用时（即一个 data block 需要被 flush 到 sstable 时）记住每个 data block 在 是stable</p>
<p>中的偏移位置及其大小；</p>
<p>可以看到索引记录（handle_encoding）通过 <strong>BlockBuilder::Add</strong> 的方式追加到 Index Block 中，所以它也是被制作成了 Entry 格式的；</p>
<h3 id="Filter-Block"><a href="#Filter-Block" class="headerlink" title="Filter Block"></a>Filter Block</h3><p>为了加快 sstable 中数据查询的效率，在直接查询 data block 中的内容之前，leveldb 首先根据 filter block 中的过滤数据判断指定的 data block 中是否有需要查询的数据，若判断不存在，则无需对这个 data block 进行数据查找</p>
<p>filter block 存储的是 data block 数据的一些过滤信息。这些过滤数据一般指代布隆过滤器的数据，用于加快查询的速度；</p>
<p><strong>filter block存储的数据主要可以分为两部分：（1）过滤数据（2）索引数据。</strong></p>
<p>其中索引数据中，<code>filter i offset</code> 表示第 i 个 filter data 在整个 filter block 中的起始偏移量，<code>filter offset&#39;s offset</code> 表示filter block的索引数据在 filter block 中的偏移量</p>
<p>在读取 filter block 中的内容时，可以首先读出 <code>filter offset&#39;s offset</code> 的值，然后依次读取 <code>filter i offset</code>，根据这些 offset 分别读出<code>filter data</code></p>
<p>Base Lg 默认值为11，表示每 2KB 的数据，创建一个新的过滤器来存放过滤数据；</p>
<p><strong>一个 sstable 只有一个 filter block</strong>，其内存储了所有 block 的 filter 数据；具体来说，filter data k 包含了所有起始位置处于 [base<em>k, base</em>(k+1)) 范围内的 block 的 key 的集合的 filter 数据，按数据大小而非 block 切分主要是为了尽量均匀，以应对存在一些 block 的 key 很多，另一些 block 的 key 很少的情况；</p>
<p><img src="https://s2.loli.net/2022/07/27/g4BQufCRzc1lX3q.png" alt="sstable5.PNG"></p>
<p>在 leveldb 中，怎么建造一个 Filter Block 呢？它是通过 FilterBlockBuilder 这个类来实现的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterBlockBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FilterBlockBuilder</span><span class="params">(<span class="keyword">const</span> FilterPolicy*)</span></span>;</span><br><span class="line"></span><br><span class="line">  FilterBlockBuilder(<span class="keyword">const</span> FilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  FilterBlockBuilder&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> FilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GenerateFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> FilterPolicy* policy_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> keys_;             <span class="comment">// Flattened key contents</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; start_;    <span class="comment">// Starting index in keys_ of each key</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> result_;           <span class="comment">// Filter data computed so far</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; tmp_keys_;  <span class="comment">// policy_-&gt;CreateFilter() argument</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; filter_offsets_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了可扩展性（支持多种过滤策略）它接受一个 <strong>FilterPolicy</strong> 指针；整个建造过程需要<strong>顺序调用</strong> StartBlock、AddKey、Finish；</p>
<p>每次新建一个 data block 的时候都会调用 <strong>FilterBlockBuilder::StartBlock</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kFilterBaseLg = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kFilterBase = <span class="number">1</span> &lt;&lt; kFilterBaseLg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> filter_index = (block_offset / kFilterBase);</span><br><span class="line">  assert(filter_index &gt;= filter_offsets_.size());</span><br><span class="line">  <span class="keyword">while</span> (filter_index &gt; filter_offsets_.size()) &#123;</span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码其实就是每 2KB 用 GenerateFilter 创建一个新的 Filter；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::GenerateFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> num_keys = start_.size(); <span class="comment">// DOC: start_[i] 表示第 i 个 key 的 offset</span></span><br><span class="line">  <span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Fast path if there are no keys for this filter</span></span><br><span class="line">    filter_offsets_.push_back(result_.size());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make list of keys from flattened key structure</span></span><br><span class="line">  start_.push_back(keys_.size());  <span class="comment">// Simplify length computation</span></span><br><span class="line">  tmp_keys_.resize(num_keys);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* base = keys_.data() + start_[i];</span><br><span class="line">    <span class="keyword">size_t</span> length = start_[i + <span class="number">1</span>] - start_[i];</span><br><span class="line">    tmp_keys_[i] = Slice(base, length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate filter for current set of keys and append to result_.</span></span><br><span class="line">  filter_offsets_.push_back(result_.size());</span><br><span class="line">  <span class="comment">// DOC: 我估计 CreateFilter 才会去真正的创建 Filter Data i</span></span><br><span class="line">  <span class="comment">// 将得到的 raw data 追加到 result_ 后面去</span></span><br><span class="line">  policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</span><br><span class="line"></span><br><span class="line">  tmp_keys_.clear();</span><br><span class="line">  keys_.clear();</span><br><span class="line">  start_.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FilterBlockBuilder::GenerateFilter</strong> 就是把 keys_ 中的内容追加到 result_ 中去，并且制作 Filter offset；其实这部分没有看明白~~之后再说</p>
<h2 id="footer结构"><a href="#footer结构" class="headerlink" title="footer结构"></a>footer结构</h2><p>footer 大小固定，为 48 字节，用来存储 meta index block 与 index block 在 sstable 中的索引信息，另外尾部还会存储一个 magic word，内容为：”<a target="_blank" rel="noopener" href="http://code.google.com/p/leveldb/&quot;%E5%AD%97%E7%AC%A6%E4%B8%B2">http://code.google.com/p/leveldb/&quot;字符串</a> sha1哈希的前 8 个字节。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://leveldb-handbook.readthedocs.io/zh/latest/sstable.html">sstable</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://riverferry.site/2021-10-27-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5)%20sstable%E6%96%87%E4%BB%B6/">leveldb源码分析(5) sstable文件</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://catkang.github.io/2017/01/17/leveldb-data.html">庖丁解LevelDB之数据存储</a></p>
</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2022/08/06/leveldb5_bloom_filter/" class="prev">上一篇</a><a href="/2022/08/04/leveldb3_memtable/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>