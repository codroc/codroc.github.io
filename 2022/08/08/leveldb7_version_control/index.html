<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> leveldb 源码分析 [7] —— Version Control · Codroc Blog</title><meta name="description" content="leveldb 源码分析 [7] —— Version Control - Codroc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://codroc.github.io/atom.xml" title="Codroc Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Codroc Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codroc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">leveldb 源码分析 [7] —— Version Control</h1><div class="post-info">2022年8月8日</div><div class="post-content"><h1 id="LevelDB-源码分析【7】——-Version-Control"><a href="#LevelDB-源码分析【7】——-Version-Control" class="headerlink" title="LevelDB 源码分析【7】—— Version Control"></a>LevelDB 源码分析【7】—— Version Control</h1><p><strong>涉及到的源文件：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db&#x2F;version_set.h</span><br><span class="line">db&#x2F;version_edit.h</span><br></pre></td></tr></table></figure>

<p>Leveldb 每一次删除或增加 sstable 都会从一个版本升级到另一个版本，每次 sstable 文件的更替对于 leveldb 来说是一个最小的操作单元，具有原子性。</p>
<p>Leveldb 用 Version 表示一个版本的元数据，它的定义是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Version</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">GetStats</span> &#123;</span></span><br><span class="line">    FileMetaData* seek_file;</span><br><span class="line">    <span class="keyword">int</span> seek_file_level;</span><br><span class="line">  &#125;;</span><br><span class="line">... ...</span><br><span class="line">  <span class="comment">// DOC: next_ 和 prev_ 用于双向链表</span></span><br><span class="line">  VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">  Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">  Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line">  <span class="comment">// DOC: refs_ 记录了被不同的 Version 引用的个数，保证被引用中的文件不会被删除</span></span><br><span class="line">  <span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOC: 每一层的 sstable 文件元数据</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOC: 这两个变量的作用是什么？</span></span><br><span class="line">  FileMetaData* file_to_compact_;</span><br><span class="line">  <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOC: 触发 compaction 的状态信息，这些信息会在读写请求或 compaction 的过程中更新</span></span><br><span class="line">  <span class="keyword">double</span> compaction_score_;</span><br><span class="line">  <span class="keyword">int</span> compaction_level_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以它本身就是双向链表中的一个节点，里面保存了某个版本的 Leveldb 的元数据：</p>
<ul>
<li>可以用 files_ 索引到每个 level 的所有 sstable 文件的元数据；</li>
<li>用 file_to_compact_ 和 file_to_compact_level_ 记录下一个将要被 compaction 的 sstable；</li>
<li>用 compaction_score_ 和 compaction_level_ 记录某个 level 是否需要进行 compaction；如果 compaction_score_ &gt;= 1 则要进行 compaction；</li>
</ul>
<p>然后就可以用这样的节点组成一个循环双向链表 VertionSet：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span> &#123;</span></span><br><span class="line">    ... ...</span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence_;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opened lazily</span></span><br><span class="line">  WritableFile* descriptor_file_;</span><br><span class="line">  <span class="built_in">log</span>::Writer* descriptor_log_;</span><br><span class="line">  Version    ;  <span class="comment">// Head of circular doubly-linked list of versions.</span></span><br><span class="line">  Version* current_;        <span class="comment">// == dummy_versions_.prev_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line">  <span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> compact_pointer_[config::kNumLevels];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>VersionSet <strong>是一个 Version 构成的循环双向链表，这些 Version 按时间顺序先后产生，记录了当时的元信息，链表尾部是当前最新的 Version；每个 Version 自己会维护引用计数，当其被引用时不会被删除，其对应的 sstable 也得以保留；通过这种方式，使得 leveldb 可以在</strong>任意一个稳定的快照视图上</strong>（即任意一个未被删除的 Version 上）访问文件。</p>
<h3 id="如何从-Version-i-升级到-Version-i-1"><a href="#如何从-Version-i-升级到-Version-i-1" class="headerlink" title="如何从 Version_i 升级到 Version_i+1"></a>如何从 Version_i 升级到 Version_i+1</h3><p>相邻 Version 之间的不同仅仅是一些文件被创建和另一些文件被删除。也就是说将文件变动应用在旧的 Version 上可以得到新的 Version，这也就是 Version 产生的方式。leveldb 用 <strong>VersionEdit</strong> 来表示这种相邻 Version 的差值；</p>
<p><img src="https://s2.loli.net/2022/07/31/aLUwk2ZRFA3EIoj.png" alt="version_control1.png"></p>
<p><strong>VersionEdit：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionEdit</span> &#123;</span></span><br><span class="line">    ... ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">  SequenceNumber last_sequence_;</span><br><span class="line">  <span class="keyword">bool</span> has_comparator_;</span><br><span class="line">  <span class="keyword">bool</span> has_log_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line">  DeletedFileSet deleted_files_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h3><p><strong>将 Version 和 VersionEdit 持久化存储得到的就是 Manifest 文件</strong></p>
<p>manifest 文件专用于记录版本信息。leveldb 采用了增量式的存储方式，记录每一个版本相较于上一个版本的变化情况。</p>
<p>展开来说，一个 Manifest 文件中，包含了多条 Session Record。一个 Session Record 记录了从上一个版本至该版本的变化情况。</p>
<blockquote>
<p>（1）新增了哪些sstable文件；</p>
<p>（2）删除了哪些sstable文件（由于compaction导致）；</p>
<p>（3）最新的journal日志文件标号等；</p>
</blockquote>
<p>借助这个 Manifest 文件，leveldb 启动时，可以根据一个初始的版本状态，不断地应用这些版本改动，使得系统的版本信息恢复到最近一次使用的状态。</p>
<p>一个 Manifest 文件的格式示意图如下所示：</p>
<p><img src="https://s2.loli.net/2022/07/31/C3wkzITaNyqU1X6.png" alt="version_control0.png"></p>
<p>一个 Manifest 内部包含若干条 Session Record，<strong>其中第一条 Session Record</strong> 记载了当时 leveldb 的<em>全量版本信息</em>（即 Version？），其余若干条 Session Record 仅记录每次更迭的变化情况（即 VersionEdit？）。因此，每个 manifest 文件的第一条 Session Record 都是一个记录点（checkpoint or snapshot），记载了全量的版本信息，可以作为一个初始的状态进行版本恢复。</p>
<p>一个 Session Record 可能包含以下字段：</p>
<ul>
<li>Comparer 的名称；</li>
<li>最新的 journal 文件编号；</li>
<li>下一个可以使用的文件编号；</li>
<li>数据库已经持久化数据项中最大的 sequence number；</li>
<li>新增的文件信息；</li>
<li>删除的文件信息；</li>
<li>compaction 记录信息；</li>
</ul>
<p><strong>可以看到这些信息起始都是 VersionSet 和 VersionEdit 中的成员变量；</strong></p>
<h3 id="如何从一个-Manifest-文件恢复数据库"><a href="#如何从一个-Manifest-文件恢复数据库" class="headerlink" title="如何从一个 Manifest 文件恢复数据库"></a>如何从一个 Manifest 文件恢复数据库</h3><p>当 leveldb 要根据 manifest 进行恢复时，会读出最早的一个 Version 然后不断应用 VersionEdit 恢复到最近的状态，这就会产生一堆的中间 Version 状态，但这可能是不需要的，我们只需要最新最近的数据库状态；leveldb 引入<strong>VersionSet::Builder</strong> 来避免这种中间变量，方法是先将所有的 VersoinEdit 内容整理到 VersionBuilder 中，然后一次应用产生最终的 Version，这种实现上的优化如下图所示：</p>
<p><img src="https://s2.loli.net/2022/07/31/34v86KjOhkLxaC9.png" alt="version_control2.png"></p>
<h5 id="VersionSet-Builder"><a href="#VersionSet-Builder" class="headerlink" title="VersionSet::Builder"></a>VersionSet::Builder</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>:</span>:Builder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BySmallestKey</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> InternalKeyComparator* internal_comparator;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> FileMetaData*, <span class="keyword">const</span> FileMetaData*)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;FileMetaData*, BySmallestKey&gt; FileSet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LevelState</span> &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; deleted_files;</span><br><span class="line">        FileSet* added_files;</span><br><span class="line">    &#125;;</span><br><span class="line">    VersionSet* vset_;</span><br><span class="line">    Version* base_;</span><br><span class="line">    LevelState levels_[config::kNumLevels]; <span class="comment">// DOC: 每一层删了哪些旧文件，增加了哪些新文件</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Builder(VersionSet* vset, Version* base) : vset_(vset), base_(base) &#123;</span><br><span class="line">        base_-&gt;Ref();</span><br><span class="line">        BySmallestKey cmp;</span><br><span class="line">        cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">          levels_[level].added_files = <span class="keyword">new</span> FileSet(cmp);</span><br><span class="line">    	 &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 引用所有的 *edit 到当前状态（由 current version 表示）</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(<span class="keyword">const</span> VersionEdit* edit)</span></span>;</span><br><span class="line">     <span class="comment">// 保存当前状态到 Version v</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过 Builder，我们可以先把所有的 VersionEdit 通过 Builder::Apply 保存到 Builder::levels_ 中；当所有的 VersionEdit 都添加完之后再调用 Builder::SaveTo 一次性从 Version i 升级到 Version i + 1；</p>
<h3 id="compaction-后对-VersionSet-的变更"><a href="#compaction-后对-VersionSet-的变更" class="headerlink" title="compaction 后对 VersionSet 的变更"></a>compaction 后对 VersionSet 的变更</h3><p>看着一部前先可以先看下 compaction 的流程<a href>LevelDB 源码分析【8】—— Compaction</a></p>
<ul>
<li>compaction 的调用者首先有责任填充 <strong>VersionEdit</strong></li>
<li>通过 <strong>VersionSet::LogAndApply</strong>，把 VersionEdit 序列化追加到 manifest 文件中去当作一条 session record，然后通过 VersionSet::Builder 和当前状态生成一个最先的版本 v，并让 current_ = v</li>
<li>把 current_ 插入 VersionSet 循环双向链表的尾部，更新 VersionSet 的状态（例如 **log_number_<strong>，</strong>prev_log_number_**）</li>
</ul>
<blockquote>
<p>所以整个流程中，串起 compaction 和 VersionSet 以及 Version 的关键类就是 VersionEdit</p>
</blockquote>
<p>看下 compaction 是怎么创建一个 VersionEdit 的，首先得了解下 compaction 的函数调用栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DBImpl::Write-&gt;DBImpl::MakeRoomForWrite</span><br><span class="line">	DBImpl::MaybeScheduleCompaction</span><br><span class="line">		DBImpl::BGWork</span><br><span class="line">			DBImpl::BackgroundCall</span><br><span class="line">				DBImpl::BackgroundCompaction &#x2F;&#x2F; 这里就去做真正的压缩了！</span><br><span class="line">					DBImlp::CompactMemTable &#x2F;&#x2F; minor compaction</span><br><span class="line">					VersionSet::CompactRange &#x2F;&#x2F; manual compaction</span><br><span class="line">					VersionSet::PickCompaction &#x2F;&#x2F; major compaction</span><br></pre></td></tr></table></figure>



<h4 id="对于-minor-compaction-来说是怎么创建-VersionEdit-的？"><a href="#对于-minor-compaction-来说是怎么创建-VersionEdit-的？" class="headerlink" title="对于 minor compaction 来说是怎么创建 VersionEdit 的？"></a>对于 minor compaction 来说是怎么创建 VersionEdit 的？</h4><p>先写下我的猜想：</p>
<p>肯定是创建一个 VersionEdit 对象 edit，然后让 DBImlp::CompactMemTable 去填充这个 edit；edit 中最重要的三个成员就是 <strong>deleted_files_</strong> ，<strong>new_files_</strong>  和 <strong>compact_pointers_</strong>  了吧！</p>
<p>对于 minor compaction 它只会增加新的 sstable 文件，而不会删除旧的 sstable 文件，并且只会往 level 0 层增加文件；</p>
<p>那么 VersionEdit::deleted_files_ 自然为空，VersionEdit::new_files_ 则是新添加的 sstable 文件对应的元数据；</p>
<p>因为 level 0~i 层 compaction 时对于输入文件的选择是通过轮转的方式进行的，因此需要记住本次 compaction 后输出文件中最大的 key 值，保存到 VersionEdit::compact_pointers_ 中去；</p>
<p>看下代码：</p>
<h4 id="DBImlp-CompactMemTable"><a href="#DBImlp-CompactMemTable" class="headerlink" title="DBImlp::CompactMemTable"></a>DBImlp::CompactMemTable</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;current();</span><br><span class="line">  base-&gt;Ref();</span><br><span class="line">  Status s = WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">  base-&gt;Unref();</span><br><span class="line">... ...</span><br><span class="line">  <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);</span><br><span class="line">    edit.SetLogNumber(logfile_number_);  <span class="comment">// Earlier logs no longer needed</span></span><br><span class="line">    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Commit to the new state</span></span><br><span class="line">    imm_-&gt;Unref();</span><br><span class="line">    imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    RemoveObsoleteFiles();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RecordBackgroundError(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如我所预测的，它首先拿到一个 VersionEdit 对象 edit；其次让 <strong>WriteLevel0Table</strong> 根据 immutable memtable 去填充 edit；然后调用 <strong>VersionSet::LogAndApply</strong> 将该 edit 应用到当前状态生成一个全新的 leveldb 版本并插入循环双向链表尾部；最后就可以删除 immutable memtable 了；</p>
<p>所以对于 minor compaction 来说是通过 <strong>WriteLevel0Table</strong> 来创建 VersionEdit 的</p>
<h4 id="DBImlp-WriteLevel0Table"><a href="#DBImlp-WriteLevel0Table" class="headerlink" title="DBImlp::WriteLevel0Table"></a>DBImlp::WriteLevel0Table</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::WriteLevel0Table</span><span class="params">(MemTable* mem, VersionEdit* edit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Version* base)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line">    ... ...</span><br><span class="line">  Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta); <span class="comment">// 创建 sstable 并把元数据存入 meta</span></span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">  edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line">                  meta.largest);</span><br><span class="line">    ... ...</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看下这段代码，它其实就是创建一个 FileMetaData 对象 meta，也就是 sstable 的元数据，怎么填充它呢？把填充任务交给 <strong>BuildTable</strong>，因为它会持久化 immutable memtable 中的数据变成 sstable，那么它最懂怎么填充 meta！</p>
<p>因为是 minor compaction 因此只会新增一个 sstable，因此 edit 仅仅调用以下 AddFile 就可以了！至此 edit 就填充完全了，就可以后续的更新 Version 和 VersionSet 了！</p>
<h4 id="对于-major-compaction-来说是怎么创建-VersionEdit-的？"><a href="#对于-major-compaction-来说是怎么创建-VersionEdit-的？" class="headerlink" title="对于 major compaction 来说是怎么创建 VersionEdit 的？"></a>对于 major compaction 来说是怎么创建 VersionEdit 的？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBImpl::BackgroundCompaction</span><br><span class="line">	VersionSet::PickCompaction &#x2F;&#x2F; major compaction</span><br><span class="line">	DBImpl::DoCompactionWork</span><br><span class="line">		</span><br></pre></td></tr></table></figure>



<p>这个流程在<a href>LevelDB 源码分析【8】—— Compaction</a>中进行了分析：</p>
<ol>
<li>获取输入文件</li>
<li>扩大输入文件集合</li>
<li>多路归并</li>
<li>积分计算</li>
</ol>
<p><strong>VersionSet::PickCompaction</strong> 主要做 1 和 2 两步，把需要 compact 的所有 sstable 文件放到 Compaction 对象中返回；</p>
<p><strong>DBImpl::DoCompactionWork</strong> 主要做 3 和 4 两步；</p>
<h4 id="VersionSet-PickCompaction"><a href="#VersionSet-PickCompaction" class="headerlink" title="VersionSet::PickCompaction"></a>VersionSet::PickCompaction</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compaction* <span class="title">VersionSet::PickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(level + <span class="number">1</span> &lt; config::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="comment">// DOC: 从 level i 层选择输入文件</span></span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].empty() || <span class="comment">// DOC: 如果 level i 层第一次做 compaction</span></span><br><span class="line">          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123; <span class="comment">// DOC: 如果 sstable 的最大的 key &gt; compact_pointer_</span></span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</span><br><span class="line">    level = current_-&gt;file_to_compact_level_;</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c-&gt;input_version_ = current_;</span><br><span class="line">  c-&gt;input_version_-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line">  <span class="comment">// DOC: level 0 层可能出现 sstable 之间 overlap 的情况，因此在 level 0 层就可以扩大输入文件集合</span></span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">    <span class="comment">// which will include the picked file.</span></span><br><span class="line">    current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOC: 在 level i + 1 层扩到输入文件集合</span></span><br><span class="line">  SetupOtherInputs(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html">版本控制</a></li>
<li><a target="_blank" rel="noopener" href="http://catkang.github.io/2017/02/03/leveldb-version.html">庖丁解LevelDB之版本控制</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2022/08/08/leveldb8_compaction/" class="prev">上一篇</a><a href="/2022/08/08/leveldb6_cache/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://codroc.github.io">Codroc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>